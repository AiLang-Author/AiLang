This file contains a consolidated set of diffs representing the architectural
upgrade to the AILANG parser to support postfix expressions (member access,
method calls) and structured assignment targets, including the required
backend infrastructure changes.

===================================================================
File: c:\Users\Sean\Documents\AiLang\ailang\Librarys\Library.SortedSet.ailang
Reason: Fixes original syntax errors that led to parser investigation.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang\ailang\Librarys\Library.SortedSet.ailang
+++ b/c:\Users\Sean\Documents\AiLang\ailang\Librarys\Library.SortedSet.ailang
@@ -3,8 +3,8 @@
     
     // Simple memory pool
     DynamicPool.Pool.SortedSet.Main {
-        "nodes": ElementType-Address, MaximumLength-10000000,
-        "headers": ElementType-Address, MaximumLength-1000
+        "nodes": ElementType=Address, MaximumLength=10000000,
+        "headers": ElementType=Address, MaximumLength=1000
     }
     
     // Constants
@@ -141,9 +141,9 @@
         Input: (zset: Address, member: Text, increment: FloatingPoint)
         Output: FloatingPoint
         Body: {
-            current = RunTask.ZSet.Score(zset-zset, member-member)
+            current = ZSet.Score(zset, member)
             new_score = Add(current, increment)
-            RunTask.ZSet.Add(zset-zset, member-member, score-new_score)
+            ZSet.Add(zset, member, new_score)
             ReturnValue(new_score)
         }
     }
 }

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ailang_ast.py
Reason: Adds MemberAccess to the list of exported AST nodes.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ailang_ast.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ailang_ast.py
@@ -23,7 +23,7 @@
     
     # Expressions
     'TypeExpression', 'MathExpression', 'FunctionCall', 'Apply', 'RunMacro',
-    'Identifier', 'Number', 'String', 'Boolean', 'ArrayLiteral', 'MapLiteral',
+    'Identifier', 'Number', 'String', 'Boolean', 'ArrayLiteral', 'MapLiteral', 'MemberAccess',
     'Array',
     
     # Program

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_expressions.py
Reason: Upgrades AST nodes to support structured expressions.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_expressions.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_expressions.py
@@ -13,7 +13,8 @@
 
 @dataclass
 class FunctionCall(ASTNode):
-    function: str
+    # Changed to ASTNode to support obj.method() calls
+    function: ASTNode
     arguments: List[ASTNode]
 
 @dataclass
@@ -45,5 +46,11 @@
 class MapLiteral(ASTNode):
     pairs: List[Tuple[ASTNode, ASTNode]]
 
+@dataclass
+class MemberAccess(ASTNode):
+    """Represents accessing a member of an object, e.g., my_object.field"""
+    obj: ASTNode
+    member: 'Identifier'
+
 # Convenience alias
 Array = ArrayLiteral  # Some code might use Array instead of ArrayLiteral

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_statements.py
Reason: Upgrades Assignment AST node for structured targets.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_statements.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\ast_modules\ast_statements.py
@@ -20,7 +20,8 @@
 
 @dataclass
 class Assignment(ASTNode):
-    target: str
+    # Changed to ASTNode to support assignment to obj.field
+    target: ASTNode
     value: ASTNode
 
 @dataclass

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_expressions.py
Reason: Implements the full postfix parsing logic.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_expressions.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_expressions.py
@@ -8,7 +8,7 @@
     def parse_expression(self) -> ASTNode:
         # Skip newlines at the start of expressions
         self.skip_newlines()
-        return self.parse_strict_expression()
+        return self.parse_postfix_expression()
 
     def _init_namespacing(self):
         """Initialize namespace-related attributes."""
@@ -43,6 +43,50 @@
         self.current_namespace = namespace_token.value
         self.skip_newlines()
     
+    def parse_postfix_expression(self) -> ASTNode:
+        """
+        Parses a primary expression and then any subsequent postfix operations
+        like member access (.), function calls (()), or array access ([]).
+        This creates a more explicit and structured AST.
+        """
+        # First, parse a "base" expression (e.g., an identifier, number, or parenthesized expression).
+        expr = self.parse_primary()
+
+        # Loop to handle a chain of postfix operations, e.g., obj.field()
+        while True:
+            if self.match(TokenType.DOT):
+                # --- Member Access: obj.field ---
+                self.consume(TokenType.DOT)
+                member_token = self.consume(TokenType.IDENTIFIER)
+                member_ident = Identifier(name=member_token.value, line=member_token.line, column=member_token.column)
+                # Create an explicit MemberAccess node in the AST
+                expr = MemberAccess(obj=expr, member=member_ident, line=expr.line, column=expr.column)
+
+            elif self.match(TokenType.LPAREN):
+                # --- Function Call: func(...) or obj.method(...) ---
+                expr = self.parse_function_call(expr)
+
+            # TODO: Add elif for LBRACKET to handle IndexAccess
+
+            else:
+                # No more postfix operators, break the loop.
+                break
+        return expr
+
+    def parse_function_call(self, function_node: ASTNode) -> FunctionCall:
+        """Helper to parse the argument list for a function call, given the function node."""
+        self.consume(TokenType.LPAREN)
+        arguments = self.parse_argument_list()
+        self.consume(TokenType.RPAREN)
+
+        # The FunctionCall AST node now takes an ASTNode for the function, not a string.
+        return FunctionCall(function=function_node, arguments=arguments,
+                            line=function_node.line, column=function_node.column)
+
     def parse_strict_expression(self) -> ASTNode:
         self.skip_newlines()
         if self.match(TokenType.LPAREN):
@@ -355,11 +399,9 @@
         elif self.match(TokenType.RUNMACRO):
             return self.parse_runmacro()
         
-        elif self.match(TokenType.IDENTIFIER, TokenType.FIXEDPOOL, TokenType.DYNAMICPOOL,
-                       TokenType.TEMPORALPOOL, TokenType.NEURALPOOL, TokenType.KERNELPOOL,
-                       TokenType.ACTORPOOL, TokenType.SECURITYPOOL, TokenType.CONSTRAINEDPOOL,
-                       TokenType.FILEPOOL):
+        # The old complex match is simplified. `parse_identifier` now only handles IDENTIFIER.
+        # The postfix parser will handle calls and member access.
+        elif self.match(TokenType.IDENTIFIER):
             return self.parse_identifier()
         
         elif self.match(TokenType.LPAREN):
@@ -649,48 +691,25 @@
         return RunMacro(macro_path=macro_path, arguments=arguments,
                         line=start_token.line, column=start_token.column)
 
-    def parse_identifier(self) -> ASTNode:
-        """Parse an identifier, which might be a variable or function call"""
-        start_token = self.current_token
-        name = self.parse_qualified_name()
-        
-        if self.match(TokenType.LPAREN):
-            self.consume(TokenType.LPAREN)
-            arguments = []
-            
-            if not self.check(TokenType.RPAREN):
-                arguments.append(self.parse_expression())
-                while self.match(TokenType.COMMA):
-                    self.consume(TokenType.COMMA)
-                    self.skip_newlines()
-                    arguments.append(self.parse_expression())
-            
-            self.consume(TokenType.RPAREN)
-            return FunctionCall(
-                function=name,
-                arguments=arguments,
-                line=start_token.line,
-                column=start_token.column
-            )
-        
-        ident_node = Identifier(
-            name=name,
-            line=start_token.line,
-            column=start_token.column
-        )
-        # Store the original, unprefixed name for contextual analysis (e.g., assignments).
-        ident_node.original_name = name
-        return ident_node
-       
+    def parse_argument_list(self) -> List[ASTNode]:
+        """Parses a comma-separated list of arguments inside parentheses."""
+        arguments = []
+        if not self.check(TokenType.RPAREN):
+            arguments.append(self.parse_expression())
+            while self.match(TokenType.COMMA):
+                self.consume(TokenType.COMMA)
+                self.skip_newlines()
+                arguments.append(self.parse_expression())
+        return arguments
+
+    def parse_identifier(self) -> Identifier:
+        """
+        Parses a single identifier token. No longer handles dotted names or function calls,
+        as that is now managed by the more explicit parse_postfix_expression.
+        """
+        start_token = self.consume(TokenType.IDENTIFIER)
+        return Identifier(name=start_token.value, line=start_token.line, column=start_token.column)
 
     def parse_array_literal(self):
         """Parse array literal [...]"""

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_statements.py
Reason: Fixes assignment parsing and adds robustness against common parsing errors.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_statements.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\parser_modules\parse_statements.py
@@ -68,28 +68,28 @@
                     TokenType.TLB, TokenType.MEMORYBARRIER):
             return self.parse_vm_operation()
         else:
+            # Before eagerly parsing an expression, check for tokens that cannot
+            # start a statement. This prevents errors if a calling loop fails to
+            # terminate and calls parse_statement() on a '}' or 'ElseBlock'.
+            if self.current_token and self.current_token.type in (TokenType.RBRACE, TokenType.ELSEBLOCK, TokenType.EOF):
+                # Return None to allow the calling loop to terminate correctly.
+                return None
+
             # This branch handles both expression statements (like function calls)
-            # and assignments. We parse the left-hand side as an expression.
-            expr = self.parse_expression()
+            # and assignments. We use the new postfix parser to correctly handle
+            # member access (e.g., obj.field) on the left-hand side.
+            lhs = self.parse_postfix_expression()
 
             # If the next token is '=', it's an assignment.
             if self.match(TokenType.EQUALS):
-                if not isinstance(expr, Identifier):
-                    self.error(f"Invalid assignment target. Cannot assign to a {type(expr).__name__}.")
+                # The target of an assignment (L-value) must be something that can be
+                # assigned to, like a variable (Identifier) or an object field (MemberAccess).
+                if not isinstance(lhs, (Identifier, MemberAccess)):
+                    self.error(f"Invalid assignment target. Cannot assign to a {type(lhs).__name__}.")
                 
                 self.consume(TokenType.EQUALS)
-                value = self.parse_expression()
-                return Assignment(target=expr.name, value=value, line=expr.line, column=expr.column)
+                rhs = self.parse_expression()
+                # The Assignment AST node now correctly stores the structured target node.
+                return Assignment(target=lhs, value=rhs, line=lhs.line, column=lhs.column)
             
             # Otherwise, it's just an expression statement.
-            if expr:
-                return expr
+            if lhs:
+                return lhs
             
             # If parsing an expression returned nothing and we're not at EOF,
             # advance to avoid getting stuck.

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\visitor.py
Reason: Updates the ASTPrinter to correctly handle the new structured AST nodes.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\visitor.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\visitor.py
@@ -1,11 +1,11 @@
 # visitor.py
 from ailang_ast import (
     ASTNode, Program, Library, Pool, ResourceItem, Loop, SubRoutine, Function, 
-    RunTask, PrintMessage, ReturnValue, If, While, ForEvery, Assignment, 
+    RunTask, PrintMessage, ReturnValue, If, While, ForEvery, Assignment, MemberAccess,
     MathExpression, FunctionCall, Identifier, Number, String, Boolean,
     ArrayLiteral, TypeExpression, Try, SendMessage, ReceiveMessage,
     EveryInterval, WithSecurity, BreakLoop, ContinueLoop, HaltProgram, Lambda, 
@@ -24,6 +24,10 @@
     def generic_visit(self, node: ASTNode):
         """Called if no explicit visitor method exists for a node"""
         raise NotImplementedError(f"No visitor method for {type(node).__name__}")
+
+    def visit_MemberAccess(self, node: MemberAccess) -> str:
+        """Pretty print a MemberAccess node."""
+        return f"{self.visit(node.obj)}.{self.visit(node.member)}"
 
 class ASTPrinter(ASTVisitor):
     """Pretty print AST for debugging"""
@@ -298,11 +302,11 @@
         return result
     
     def visit_Assignment(self, node: Assignment) -> str:
-        return f"{node.target} = {self.visit(node.value)}"
+        return f"{self.visit(node.target)} = {self.visit(node.value)}"
     
     def visit_BreakLoop(self, node: BreakLoop) -> str:
         return "BreakLoop"
@@ -318,7 +322,7 @@
     
     def visit_FunctionCall(self, node: FunctionCall) -> str:
         args = ', '.join(self.visit(arg) for arg in node.arguments)
-        return f"{node.function}({args})"
+        return f"{self.visit(node.function)}({args})"
     
     def visit_Apply(self, node: Apply) -> str:
         args = ', '.join(self.visit(arg) for arg in node.arguments)

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\compiler.py
Reason: Updates symbol collection to correctly handle new Assignment AST.
===================================================================
--- a/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\compiler.py
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\compiler.py
@@ -71,7 +71,12 @@
             if node_type in ('Function', 'FunctionDefinition', 'SubRoutine', 'Constant',
                              'LoopMain', 'LoopActor', 'LoopStart', 'LoopShadow'):
                 original_name = decl.name
-            elif node_type == 'Assignment':
-                original_name = getattr(decl, 'target', None) # This is the variable name
+            elif node_type == 'Assignment':
+                # Only consider simple assignments to an Identifier as global variable declarations.
+                if isinstance(decl.target, Identifier):
+                    original_name = decl.target.name
+                else:
+                    # Assignments to obj.field are not global symbol declarations.
+                    continue
             elif node_type == 'Pool':
                 # Pools need special handling. The namespace should apply to the pool's
                 # name, not its type (e.g., "FixedPool.NS123_store" not "NS123_FixedPool.store").

===================================================================
File: c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\backend_compiler_draft.py
Reason: New file drafting the required backend changes for code generation.
===================================================================
--- /dev/null
+++ b/c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\backend_compiler_draft.py
@@ -0,0 +1,128 @@
+# c:\Users\Sean\Documents\AiLang_v_2.0\ailang_parser\backend_compiler_draft.py
+"""
+Draft of backend compiler changes required to support the new
+structured AST (MemberAccess, updated Assignment/FunctionCall).
+
+This is a conceptual guide for adapting a code generator (e.g., to x64).
+It assumes a visitor pattern is used for AST traversal.
+"""
+
+from .ailang_ast import ASTNode, Assignment, FunctionCall, MemberAccess, Identifier
+from .parser_modules.namespace_manager import NamespaceManager
+
+class AILANGBackendCompiler:
+    """
+    Conceptual backend compiler showing how to handle the new AST nodes.
+    """
+    def __init__(self, ns_manager: NamespaceManager):
+        self.ns_manager = ns_manager
+        # self.emitter = ... (e.g., an x64 emitter)
+
+    def compile_node(self, node: ASTNode):
+        """Dispatch to the correct visitor method."""
+        method_name = f'visit_{type(node).__name__}'
+        visitor = getattr(self, method_name, self.generic_visit)
+        return visitor(node)
+
+    def generic_visit(self, node: ASTNode):
+        raise NotImplementedError(f"Backend compiler has no method for {type(node).__name__}")
+
+    # --- NEW/UPDATED VISITOR METHODS ---
+
+    def visit_Assignment(self, node: Assignment):
+        """
+        Compiles an assignment statement. Handles both simple variables
+        and member access assignments (obj.field = value).
+        """
+        # First, compile the right-hand side value. The result will be
+        # on top of the stack (or in a register like RAX).
+        self.compile_node(node.value)
+        # self.emitter.emit("PUSH RAX") # Or similar to save the value
+
+        # Now, determine where to store the value by processing the target.
+        target_node = node.target
+        if isinstance(target_node, Identifier):
+            # --- Case 1: Simple assignment (e.g., x = 10) ---
+            variable_name = self.ns_manager.resolve(target_node.name)
+            # self.emitter.emit("POP RBX") # Get value
+            # self.emitter.emit(f"MOV [_{variable_name}], RBX")
+            print(f"BACKEND: Storing value into variable '{variable_name}'")
+
+        elif isinstance(target_node, MemberAccess):
+            # --- Case 2: Member assignment (e.g., my_stream.last_id = 10) ---
+            # This is the new, critical logic path.
+
+            # 1. Compile the object part of the access (e.g., `my_stream`).
+            # This should result in the base address of the object/struct
+            # being placed in a register (e.g., RCX).
+            self.compile_node(target_node.obj)
+            # self.emitter.emit("MOV RCX, RAX") # Assume result is in RAX
+
+            # 2. Get the member name (e.g., "last_id").
+            member_name = target_node.member.name
+
+            # 3. Look up the offset of this member within its struct.
+            # This requires a symbol table that knows about struct layouts.
+            # Let's assume a helper function `get_member_offset`.
+            # struct_type = self.get_type_of_node(target_node.obj)
+            # offset = self.get_member_offset(struct_type, member_name)
+            offset = 8 # Placeholder offset
+            print(f"BACKEND: Found offset {offset} for member '{member_name}'")
+
+            # 4. Emit code to store the value.
+            # self.emitter.emit("POP RBX") # Get value
+            # self.emitter.emit(f"MOV [RCX + {offset}], RBX")
+            print(f"BACKEND: Storing value at base address (from '{target_node.obj.name}') + offset {offset}")
+
+        else:
+            # This was already checked by the parser, but defensive coding is good.
+            raise TypeError(f"Invalid assignment target: {type(target_node).__name__}")
+
+    def visit_FunctionCall(self, node: FunctionCall):
+        """
+        Compiles a function call. Handles both direct calls (e.g., MyFunc())
+        and method calls (e.g., ZSet.Score()).
+        """
+        # 1. Compile arguments first and push them onto the stack
+        for arg in reversed(node.arguments):
+            self.compile_node(arg)
+            # self.emitter.emit("PUSH RAX")
+
+        # 2. Determine the function to call.
+        function_node = node.function
+        if isinstance(function_node, Identifier):
+            # --- Case 1: Simple function call (e.g., Add(1, 2)) ---
+            function_name = self.ns_manager.resolve(function_node.name)
+            # self.emitter.emit(f"CALL {function_name}")
+            print(f"BACKEND: Calling function '{function_name}'")
+
+        elif isinstance(function_node, MemberAccess):
+            # --- Case 2: Method call (e.g., ZSet.Score(zset)) ---
+            qualified_name = self._get_qualified_name_from_ast(function_node)
+            mangled_name = self.ns_manager.resolve(qualified_name)
+            # self.emitter.emit(f"CALL {mangled_name}")
+            print(f"BACKEND: Calling method '{qualified_name}' (mangled to '{mangled_name}')")
+
+        else:
+            raise TypeError(f"Unsupported function call target: {type(function_node).__name__}")
+
+    def _get_qualified_name_from_ast(self, node: ASTNode) -> str:
+        """
+        Helper to convert a MemberAccess chain back into a dotted string for lookup.
+        e.g., MemberAccess(obj=Identifier('ZSet'), member=Identifier('Score')) -> "ZSet.Score"
+        """
+        if isinstance(node, Identifier):
+            return node.name
+        if isinstance(node, MemberAccess):
+            base = self._get_qualified_name_from_ast(node.obj)
+            return f"{base}.{node.member.name}"
+        raise TypeError("Can only get qualified name from Identifier or MemberAccess nodes.")
+
+    def visit_MemberAccess(self, node: MemberAccess):
+        """
+        Compiles a member access read (e.g., the `s.last_id` in `x = s.last_id`).
+        """
+        self.compile_node(node.obj) # Puts base address in RAX
+        # self.emitter.emit("MOV RCX, RAX")
+        member_name = node.member.name
+        # offset = self.get_member_offset(struct_type, member_name)
+        offset = 8 # Placeholder
+        # self.emitter.emit(f"MOV RAX, [RCX + {offset}]")
+        print(f"BACKEND: Loading value from base address + offset {offset} for member '{member_name}'")