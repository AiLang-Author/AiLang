// test_stringextract_corruption.ailang
// Test if StringExtract is corrupting memory that affects function calls

PrintMessage("=== StringExtract Memory Corruption Test ===")
PrintMessage("")

// Test 1: Check if StringExtract corrupts the stack
PrintMessage("[Test 1] Stack integrity check")

Function.CheckStack {
    Body: {
        PrintMessage("  In function - stack is OK")
        x = 42
        y = 100
        z = Add(x, y)
        PrintMessage("  Calculation: ")
        PrintNumber(z)
    }
}

PrintMessage("Before StringExtract:")
CheckStack()

PrintMessage("After StringExtract:")
str1 = StringExtract("TEST", 0, 2)
CheckStack()

PrintMessage("")

// Test 2: Check if it's the allocation size
PrintMessage("[Test 2] Different StringExtract sizes")

Function.TestFunc {
    Body: {
        PrintMessage("  Function called successfully")
    }
}

// Try different sizes
s1 = StringExtract("A", 0, 1)
PrintMessage("After extracting 1 byte: ")
TestFunc()

s2 = StringExtract("AB", 0, 2)  
PrintMessage("After extracting 2 bytes: ")
TestFunc()

s3 = StringExtract("ABCD", 0, 4)
PrintMessage("After extracting 4 bytes: ")
TestFunc()

s4 = StringExtract("ABCDEFGH", 0, 8)
PrintMessage("After extracting 8 bytes: ")
TestFunc()

PrintMessage("")

// Test 3: Check if it's related to the source buffer
PrintMessage("[Test 3] Different source patterns")

// From a literal
s5 = StringExtract("LITERAL", 0, 3)
PrintMessage("From literal: ")
PrintMessage(s5)
TestFunc()

// From a concatenated string
concat = StringConcat("CON", "CAT")
s6 = StringExtract(concat, 0, 3)
PrintMessage("From concat: ")
PrintMessage(s6)
TestFunc()

PrintMessage("")

// Test 4: Multiple extracts in sequence
PrintMessage("[Test 4] Multiple StringExtracts")

Function.CountExtracts {
    Body: {
        PrintMessage("  Still working after extracts")
    }
}

i = 0
WhileLoop LessThan(i, 5) {
    s = StringExtract("TEST", 0, 2)
    PrintMessage("  Extract ")
    PrintNumber(i)
    PrintMessage(": ")
    PrintMessage(s)
    i = Add(i, 1)
}

CountExtracts()

PrintMessage("")

// Test 5: Check memory alignment
PrintMessage("[Test 5] Memory alignment test")

// Extract at different offsets
buf = "0123456789ABCDEF"
e1 = StringExtract(buf, 0, 4)  // Aligned
e2 = StringExtract(buf, 1, 4)  // Offset by 1
e3 = StringExtract(buf, 2, 4)  // Offset by 2
e4 = StringExtract(buf, 3, 4)  // Offset by 3

PrintMessage("Extracted at different offsets:")
PrintMessage("  0: ")
PrintMessage(e1)
PrintMessage("  1: ")
PrintMessage(e2)
PrintMessage("  2: ")
PrintMessage(e3)
PrintMessage("  3: ")
PrintMessage(e4)

TestFunc()

PrintMessage("")

// Test 6: The specific failing case
PrintMessage("[Test 6] Specific Redis pattern")

FixedPool.TestPool {
    "counter": Initialize=1
}

Function.AccessPool {
    Body: {
        PrintMessage("  Accessing pool...")
        val = TestPool.counter  // This is where it crashes
        PrintMessage("  Value: ")
        PrintNumber(val)
    }
}

PrintMessage("Before extract:")
AccessPool()

// This specific extract pattern from Redis
redis_buf = "*1\r\n$4\r\nPING\r\n"
redis_extract = StringExtract(redis_buf, 8, 4)
PrintMessage("Extracted from RESP: '")
PrintMessage(redis_extract)
PrintMessage("'")

PrintMessage("After extract:")
AccessPool()  // CRASH HERE

PrintMessage("")
PrintMessage("=== TEST COMPLETE ===")
PrintMessage("The crash point tells us what's being corrupted!")