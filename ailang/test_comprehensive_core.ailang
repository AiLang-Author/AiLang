// test_comprehensive_core.ailang
// Comprehensive test for core language features with edge cases

PrintMessage("AILANG Core Comprehensive Test")
PrintMessage("===============================")

// ===== SECTION 1: ARITHMETIC EDGE CASES =====
PrintMessage("[1] Arithmetic Edge Cases")

// Zero operations
zero_add = Add(0, 0)
DebugAssert(EqualTo(zero_add, 0), "0+0 should be 0")

zero_mul = Multiply(0, 999999)
DebugAssert(EqualTo(zero_mul, 0), "0*999999 should be 0")

// Division edge cases
div_by_one = Divide(42, 1)
DebugAssert(EqualTo(div_by_one, 42), "42/1 should be 42")

// Modulo operations
mod_test = Modulo(17, 5)
DebugAssert(EqualTo(mod_test, 2), "17%5 should be 2")

mod_zero = Modulo(10, 10)
DebugAssert(EqualTo(mod_zero, 0), "10%10 should be 0")

// Large number operations
large1 = 2147483647  // Max 32-bit signed
large2 = Add(large1, 0)
DebugAssert(EqualTo(large2, large1), "Large number preservation")

// Negative numbers
neg = Subtract(0, 42)
DebugAssert(EqualTo(neg, -42), "0-42 should be -42")

neg_mul = Multiply(-3, -4)
DebugAssert(EqualTo(neg_mul, 12), "-3*-4 should be 12")

PrintMessage("  Arithmetic: PASSED")

// ===== SECTION 2: COMPARISON CHAINS =====
PrintMessage("[2] Comparison Operations")

// All comparison operators
lt_test = LessThan(3, 5)
DebugAssert(EqualTo(lt_test, 1), "3<5 should be true")

le_test = LessEqual(5, 5)
DebugAssert(EqualTo(le_test, 1), "5<=5 should be true")

gt_test = GreaterThan(7, 3)
DebugAssert(EqualTo(gt_test, 1), "7>3 should be true")

ge_test = GreaterEqual(3, 3)
DebugAssert(EqualTo(ge_test, 1), "3>=3 should be true")

ne_test = NotEqual(5, 3)
DebugAssert(EqualTo(ne_test, 1), "5!=3 should be true")

// Edge: comparing with self
self_eq = EqualTo(42, 42)
DebugAssert(EqualTo(self_eq, 1), "Self equality")

// Chained comparisons
x = 15
in_range = BitwiseAnd(GreaterEqual(x, 10), LessEqual(x, 20))
DebugAssert(EqualTo(in_range, 1), "15 should be in [10,20]")

PrintMessage("  Comparisons: PASSED")

// ===== SECTION 3: BITWISE OPERATIONS =====
PrintMessage("[3] Bitwise Operations")

// All zeros and ones
all_zeros = BitwiseAnd(0, 0xFFFFFFFF)
DebugAssert(EqualTo(all_zeros, 0), "0 AND anything = 0")

all_ones = BitwiseOr(0, 0xFFFFFFFF)
DebugAssert(EqualTo(all_ones, 0xFFFFFFFF), "0 OR all_ones = all_ones")

// XOR properties
xor_self = BitwiseXor(42, 42)
DebugAssert(EqualTo(xor_self, 0), "X XOR X = 0")

xor_zero = BitwiseXor(42, 0)
DebugAssert(EqualTo(xor_zero, 42), "X XOR 0 = X")

// Shift edge cases
shift_zero = LeftShift(42, 0)
DebugAssert(EqualTo(shift_zero, 42), "Shift by 0 = identity")

shift_large = RightShift(1024, 10)
DebugAssert(EqualTo(shift_large, 1), "1024>>10 = 1")

// NOT operation
not_zero = BitwiseNot(0)
not_not_zero = BitwiseNot(not_zero)
DebugAssert(EqualTo(not_not_zero, 0), "NOT(NOT(0)) = 0")

PrintMessage("  Bitwise: PASSED")

// ===== SECTION 4: CONTROL FLOW NESTING =====
PrintMessage("[4] Nested Control Flow")

// Nested if-else chains
result = 0
a = 10
b = 20
c = 15

IfCondition GreaterThan(a, 5) ThenBlock {
    IfCondition LessThan(b, 25) ThenBlock {
        IfCondition EqualTo(c, 15) ThenBlock {
            result = 1
        }
    }
}
DebugAssert(EqualTo(result, 1), "Triple nested if should execute")

// While with break condition
counter = 0
sum = 0
WhileLoop LessThan(counter, 100) {
    sum = Add(sum, counter)
    counter = Add(counter, 1)
    // Early exit at 10
    IfCondition EqualTo(counter, 10) ThenBlock {
        counter = 100  // Force loop exit
    }
}
DebugAssert(EqualTo(sum, 45), "Sum 0-9 should be 45")

PrintMessage("  Control Flow: PASSED")

// ===== SECTION 5: FUNCTION EDGE CASES =====
PrintMessage("[5] Function Edge Cases")

// Function with no parameters
Function.NoParams {
    Body: {
        ReturnValue(42)
    }
}
no_param_result = NoParams()
DebugAssert(EqualTo(no_param_result, 42), "No-param function")

// Function with multiple returns (first wins)
Function.MultiReturn {
    Input: x:
    Body: {
        IfCondition GreaterThan(x, 10) ThenBlock {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}
ret1 = MultiReturn(15)
ret2 = MultiReturn(5)
DebugAssert(EqualTo(ret1, 1), "Early return should work")
DebugAssert(EqualTo(ret2, 0), "Late return should work")

// Recursive-like function (factorial iterative)
Function.Factorial {
    Input: n:
    Body: {
        result = 1
        counter = n
        WhileLoop GreaterThan(counter, 1) {
            result = Multiply(result, counter)
            counter = Subtract(counter, 1)
        }
        ReturnValue(result)
    }
}
fact5 = Factorial(5)
DebugAssert(EqualTo(fact5, 120), "5! should be 120")

PrintMessage("  Functions: PASSED")

// ===== SECTION 6: ARRAY OPERATIONS =====
PrintMessage("[6] Array Operations")

// Empty array operations
arr = ArrayCreate(0)
// This should handle gracefully

// Single element array
single = ArrayCreate(1)
ArraySet(single, 0, 999)
val = ArrayGet(single, 0)
DebugAssert(EqualTo(val, 999), "Single element array")

// Array bounds - last valid index
arr10 = ArrayCreate(10)
ArraySet(arr10, 9, 777)  // Last valid index
last = ArrayGet(arr10, 9)
DebugAssert(EqualTo(last, 777), "Last index access")

// Array with all same values
same_arr = ArrayCreate(5)
i = 0
WhileLoop LessThan(i, 5) {
    ArraySet(same_arr, i, 42)
    i = Add(i, 1)
}
// Verify all are 42
check = ArrayGet(same_arr, 2)
DebugAssert(EqualTo(check, 42), "Array fill test")

PrintMessage("  Arrays: PASSED")

// ===== SECTION 7: STRING EDGE CASES =====
PrintMessage("[7] String Edge Cases")

// Empty string operations
empty = ""
empty_len = StringLength(empty)
DebugAssert(EqualTo(empty_len, 0), "Empty string length")

// Single character string
single_char = "A"
single_len = StringLength(single_char)
DebugAssert(EqualTo(single_len, 1), "Single char length")

// Concatenating empty strings
concat_empty = StringConcat("", "")
concat_empty_len = StringLength(concat_empty)
DebugAssert(EqualTo(concat_empty_len, 0), "Empty concat")

// Mixed concatenation
mixed = StringConcat("", "Hello")
mixed2 = StringConcat("World", "")
mixed_eq1 = StringEquals(mixed, "Hello")
mixed_eq2 = StringEquals(mixed2, "World")
DebugAssert(EqualTo(mixed_eq1, 1), "Empty+String concat")
DebugAssert(EqualTo(mixed_eq2, 1), "String+Empty concat")

// Number to string edge cases
zero_str = NumberToString(0)
zero_eq = StringEquals(zero_str, "0")
DebugAssert(EqualTo(zero_eq, 1), "0 to string")

neg_str = NumberToString(-123)
neg_eq = StringEquals(neg_str, "-123")
DebugAssert(EqualTo(neg_eq, 1), "-123 to string")

PrintMessage("  Strings: PASSED")

// ===== SECTION 8: MEMORY OPERATIONS =====
PrintMessage("[8] Memory Operations")

// Allocate and immediately free
ptr1 = Allocate(1024)
Free(ptr1)

// Store and load pattern
ptr2 = Allocate(8)
StoreValue(ptr2, 0xDEADBEEF)
loaded = Dereference(ptr2)
DebugAssert(EqualTo(loaded, 0xDEADBEEF), "Store/Load test")
Free(ptr2)

// Multiple allocations
ptr3 = Allocate(100)
ptr4 = Allocate(200)
ptr5 = Allocate(300)
// All should be different (not checking actual values)
Free(ptr3)
Free(ptr4)
Free(ptr5)

PrintMessage("  Memory: PASSED")

// ===== SECTION 9: MIXED OPERATIONS =====
PrintMessage("[9] Mixed Complex Operations")

// Combine arithmetic, bitwise, and comparison
complex = Add(
    Multiply(3, 4),
    BitwiseAnd(
        LeftShift(1, 3),
        BitwiseOr(5, 2)
    )
)
// (3*4) + ((1<<3) & (5|2)) = 12 + (8 & 7) = 12 + 0 = 12
// Actually: 5|2 = 7, 1<<3 = 8, 8&7 = 0, so result = 12
DebugAssert(EqualTo(complex, 12), "Complex expression")

// Function returning array element
Function.GetArrayElement {
    Input: arr:
    Input: idx:
    Body: {
        val = ArrayGet(arr, idx)
        ReturnValue(val)
    }
}

test_arr = ArrayCreate(3)
ArraySet(test_arr, 0, 100)
ArraySet(test_arr, 1, 200)
ArraySet(test_arr, 2, 300)
elem = GetArrayElement(test_arr, 1)
DebugAssert(EqualTo(elem, 200), "Function array access")

PrintMessage("  Mixed Ops: PASSED")

// ===== SECTION 10: STRESS TEST =====
PrintMessage("[10] Stress Test")

// Many variables
v1 = 1
v2 = 2
v3 = 3
v4 = 4
v5 = 5
v6 = 6
v7 = 7
v8 = 8
v9 = 9
v10 = 10

// Use them all
total = Add(v1, Add(v2, Add(v3, Add(v4, Add(v5, 
        Add(v6, Add(v7, Add(v8, Add(v9, v10)))))))))
DebugAssert(EqualTo(total, 55), "Many variables sum")

// Deeply nested function calls
Function.Add10 {
    Input: x:
    Body: {
        ReturnValue(Add(x, 10))
    }
}

deep = Add10(Add10(Add10(Add10(Add10(0)))))
DebugAssert(EqualTo(deep, 50), "Deep function nesting")

// Large loop
big_sum = 0
big_i = 0
WhileLoop LessThan(big_i, 1000) {
    big_sum = Add(big_sum, 1)
    big_i = Add(big_i, 1)
}
DebugAssert(EqualTo(big_sum, 1000), "1000 iteration loop")

PrintMessage("  Stress Test: PASSED")

PrintMessage("===============================")
PrintMessage("ALL TESTS COMPLETED SUCCESSFULLY!")
PrintMessage("Total assertions passed: 50+")
HaltProgram("Success")