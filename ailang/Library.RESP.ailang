// Library.RESP.ailang
// Redis Serialization Protocol (RESP) Library - FIXED SYNTAX
// Provides parsing and building functions for RESP protocol

// ============================================================================
// RESP Parser Functions
// ============================================================================

// Variables for RESP.Array function
count = 0
count_str = 0
count_len = 0
total_size = 0
elem = 0
elem_len = 0
elem_len_str = 0
len_digits = 0
elem_size = 0
response = 0
pos = 0
elem_len_digits = 0
j = 0

// Variables for RESP.IntToString (if not already there)
absolute_value = 0
num_param = 0
is_negative = 0
value = 0
temp = 0
digit_count = 0
buffer_size = 0
buffer = 0
digit = 0
result = 0
final_pos = 0
end_pos = 0
current_pos = 0

// Variables for other RESP functions that might be missing
i = 0
len = 0
str_param = 0
msg_param = 0
prefix = 0
full_msg = 0
num_str = 0
len_str = 0
len_str_len = 0
total = 0

// Variables for parsing functions
comparison = 0
offset = 0
type_byte = 0
length = 0
str = 0
start = 0
negative = 0
byte = 0


// Build an array response: *<count>\r\n<elements>
Function.RESP.Array {
    Input: elements: Array
    Output: Address
    Body: {
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Array: Building array with ")
            PrintNumber(ArrayLength(elements))
            PrintMessage(" elements.")
        }
        count = ArrayLength(elements)
        count_str = RESP.IntToString(count)
        count_len = StringLength(count_str)
        
        // Calculate total size needed
        // Start with header: * + count + \r\n
        total_size = Add(count_len, 3)
        
        // Add size for each element (bulk strings)
        i = 0
        WhileLoop LessThan(i, count) {
            elem = ArrayGet(elements, i)
            elem_len = StringLength(elem)
            elem_len_str = RESP.IntToString(elem_len)
            len_digits = StringLength(elem_len_str)
            Deallocate(elem_len_str, 0)
            
            // Calculate bulk string size: $ + len_digits + \r\n + string + \r\n
            elem_size = Add(Add(len_digits, elem_len), 5)
            total_size = Add(total_size, elem_size)
            i = Add(i, 1)
        }
        
        // Allocate response buffer
        response = Allocate(Add(total_size, 1))
        pos = 0
        
        // Write header: *<count>\r\n
        SetByte(response, pos, 42)  // '*'
        pos = Add(pos, 1)
        
        i = 0
        WhileLoop LessThan(i, count_len) {
            SetByte(response, pos, GetByte(count_str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        SetByte(response, pos, 13)  // '\r'
        pos = Add(pos, 1)
        SetByte(response, pos, 10)  // '\n'
        pos = Add(pos, 1)
        
        // Write each element as bulk string
        i = 0
        WhileLoop LessThan(i, count) {
            elem = ArrayGet(elements, i)
            elem_len = StringLength(elem)
            elem_len_str = RESP.IntToString(elem_len)
            elem_len_digits = StringLength(elem_len_str)
            
            // Write $<length>\r\n
            SetByte(response, pos, 36)  // '$'
            pos = Add(pos, 1)
            
            j = 0
            WhileLoop LessThan(j, elem_len_digits) {
                SetByte(response, pos, GetByte(elem_len_str, j))
                pos = Add(pos, 1)
                j = Add(j, 1)
            }
            
            SetByte(response, pos, 13)  // '\r'
            pos = Add(pos, 1)
            SetByte(response, pos, 10)  // '\n'
            pos = Add(pos, 1)
            
            // Write string content
            j = 0
            WhileLoop LessThan(j, elem_len) {
                SetByte(response, pos, GetByte(elem, j))
                pos = Add(pos, 1)
                j = Add(j, 1)
            }
            
            // Write trailing \r\n
            SetByte(response, pos, 13)  // '\r'
            pos = Add(pos, 1)
            SetByte(response, pos, 10)  // '\n'
            pos = Add(pos, 1)
            
            Deallocate(elem_len_str, 0)
            i = Add(i, 1)
        }
        
        // Null terminate
        SetByte(response, pos, 0)
        
        Deallocate(count_str, 0)
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.Array: Final response string:\n")
            PrintMessage(response)
        }

        ReturnValue(response)
    }
}

Function.RESP.ParseArray {
    Input: buffer: Address
    Input: size: Integer
    Output: Array
    Body: {
        // Check for array marker '*'
        IfCondition NotEqual(GetByte(buffer, 0), 42) ThenBlock: {
            ReturnValue(0)  // Not an array
        }
        
        // Parse array count
        count = RESP.ParseInteger(buffer, 1)
        
        // Create array to hold results
        result = ArrayCreate(count)
        
        // Find start of first element
        offset = 1
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)  // Skip LF
        
        // Parse each element
        i = 0
        WhileLoop LessThan(i, count) {
            element = RESP.ParseElement(buffer, offset, size)
            ArraySet(result, i, element)
            
            // Move offset past this element
            offset = RESP.SkipElement(buffer, offset, size)
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Parse a single RESP element starting at offset
Function.RESP.ParseElement {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        type_byte = GetByte(buffer, offset)
        
        // Bulk string ($)
        IfCondition EqualTo(type_byte, 36) ThenBlock: {
            ReturnValue(RESP.ParseBulkString(buffer, offset, size))
        }
        
        // Simple string (+)
        IfCondition EqualTo(type_byte, 43) ThenBlock: {
            ReturnValue(RESP.ParseSimpleString(buffer, offset, size))
        }
        
        // Integer (:)
        IfCondition EqualTo(type_byte, 58) ThenBlock: {
            num = RESP.ParseInteger(buffer, Add(offset, 1))
            ReturnValue(NumberToString(num))
        }
        
        // Error (-)
        IfCondition EqualTo(type_byte, 45) ThenBlock: {
            ReturnValue(RESP.ParseSimpleString(buffer, offset, size))
        }
        
        ReturnValue(0)  // Unknown type
    }
}

// Parse a bulk string from buffer
Function.RESP.ParseBulkString {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip '$'
        offset = Add(offset, 1)
        
        // Parse length
        length = RESP.ParseInteger(buffer, offset)
        
        // Check for null bulk string
        IfCondition LessThan(length, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Find start of actual string (after \r\n)
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)
        
        // Allocate and copy string
        str = Allocate(Add(length, 1))
        i = 0
        WhileLoop LessThan(i, length) {
            SetByte(str, i, GetByte(buffer, Add(offset, i)))
            i = Add(i, 1)
        }
        SetByte(str, length, 0)  // Null terminate
        
        ReturnValue(str)
    }
}

// Parse a simple string (ends with \r\n)
Function.RESP.ParseSimpleString {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip type marker
        offset = Add(offset, 1)
        
        // Find end of string
        start = offset
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 13)) {
            offset = Add(offset, 1)
        }
        
        // Allocate and copy
        length = Subtract(offset, start)
        str = Allocate(Add(length, 1))
        i = 0
        WhileLoop LessThan(i, length) {
            SetByte(str, i, GetByte(buffer, Add(start, i)))
            i = Add(i, 1)
        }
        SetByte(str, length, 0)
        
        ReturnValue(str)
    }
}

// Parse an integer from buffer (until \r)
Function.RESP.ParseInteger {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        result = 0
        negative = 0
        
        // Check for negative
        IfCondition EqualTo(GetByte(buffer, offset), 45) ThenBlock: {  // '-'
            negative = 1
            offset = Add(offset, 1)
        }
        
        // Parse digits
        WhileLoop 1 {
            byte = GetByte(buffer, offset)
            
            // Check for CR or non-digit
            IfCondition Or(EqualTo(byte, 13), Or(LessThan(byte, 48), GreaterThan(byte, 57))) ThenBlock: {
                BreakLoop
            }
            
            // Add digit
            result = Multiply(result, 10)
            result = Add(result, Subtract(byte, 48))
            
            offset = Add(offset, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Skip past a RESP element, return new offset
Function.RESP.SkipElement {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Integer
    Body: {
        type_byte = GetByte(buffer, offset)
        
        // Simple types - skip to \r\n
        IfCondition Or(EqualTo(type_byte, 43), Or(EqualTo(type_byte, 45), EqualTo(type_byte, 58))) ThenBlock: {
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            ReturnValue(Add(offset, 1))  // Past \n
        }
        
        // Bulk string - parse length then skip
        IfCondition EqualTo(type_byte, 36) ThenBlock: {
            offset = Add(offset, 1)  // Skip '$'
            length = RESP.ParseInteger(buffer, offset)
            
            // Skip to start of string
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            offset = Add(offset, 1)  // Past \n
            
            // Skip string + \r\n
            offset = Add(offset, Add(length, 2))
            ReturnValue(offset)
        }
        
        // Array - recursive skip
        IfCondition EqualTo(type_byte, 42) ThenBlock: {
            offset = Add(offset, 1)  // Skip '*'
            count = RESP.ParseInteger(buffer, offset)
            
            // Skip to first element
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            offset = Add(offset, 1)
            
            // Skip each element
            i = 0
            WhileLoop LessThan(i, count) {
                offset = RESP.SkipElement(buffer, offset, size)
                i = Add(i, 1)
            }
            
            ReturnValue(offset)
        }
        
        ReturnValue(offset)
    }
}

// ============================================================================
// RESP Builder Functions
// ============================================================================

// Build a simple string response: +OK\r\n
Function.RESP.SimpleString {
    Input: str: Address
    Output: Address
    Body: {
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.SimpleString: Building simple string '")
            PrintMessage(str)
            PrintMessage("'")
        }
        len = StringLength(str)
        response = Allocate(Add(len, 4))  // + str \r\n \0
        
        SetByte(response, 0, 43)  // '+'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(str, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)  // '\r'
        SetByte(response, Add(len, 2), 10)  // '\n'
        SetByte(response, Add(len, 3), 0)   // '\0'
        
        ReturnValue(response)
    }
}

// Build a bulk string response: $<len>\r\n<data>\r\n
Function.RESP.BulkString {
    Input: str: Address
    Output: Address
    Body: {
        Debug("resp.build", level=2) {
            IfCondition EqualTo(str, 0) ThenBlock: {
                PrintMessage("[DEBUG] RESP.BulkString: Building NULL bulk string.")
            } ElseBlock: {
                PrintMessage("[DEBUG] RESP.BulkString: Building bulk string.")
            }
        }

        // Handle null
        IfCondition EqualTo(str, 0) ThenBlock: {
            // Return a newly allocated null bulk string "$-1\r\n".
            // This is critical to ensure the caller can safely deallocate
            // the response without trying to free a constant string literal.
            null_resp = Allocate(6)
            MemoryCopy(null_resp, "$-1\r\n", 5)
            SetByte(null_resp, 5, 0) // Ensure null termination
            Debug("resp.build", level=3) {
                PrintMessage("[DEBUG] RESP.BulkString: Final response string:\n")
                PrintMessage(null_resp)
            }
            ReturnValue(null_resp)
        }
        
        len = StringLength(str)
        len_str = RESP.IntToString(len)
        len_str_len = StringLength(len_str)
        
        // Calculate total size: $ + len_str + \r\n + str + \r\n + \0
        total = Add(Add(Add(len_str_len, len), 6), 1)
        response = Allocate(total)
        
        pos = 0
        
        // Add '$'
        SetByte(response, pos, 36)
        pos = Add(pos, 1)
        
        // Add length
        i = 0
        WhileLoop LessThan(i, len_str_len) {
            SetByte(response, pos, GetByte(len_str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Add \r\n
        SetByte(response, pos, 13)
        pos = Add(pos, 1)
        SetByte(response, pos, 10)
        pos = Add(pos, 1)
        
        // Add string
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, pos, GetByte(str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Add final \r\n
        SetByte(response, pos, 13)
        pos = Add(pos, 1)
        SetByte(response, pos, 10)
        pos = Add(pos, 1)
        SetByte(response, pos, 0)
        
        // Deallocate the temporary string used for the length
        Deallocate(len_str, 0)
        
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.BulkString: Final response string:\n")
            PrintMessage(response)
        }

        ReturnValue(response)
    }
}

// Build an error response: -ERR <message>\r\n
Function.RESP.Error {
    Input: message: Address
    Output: Address
    Body: {
        Debug("resp.build", level=1) {
            PrintMessage("[DEBUG] RESP.Error: Building error response '")
            PrintMessage(message)
            PrintMessage("'")
        }
        prefix = "ERR "
        full_msg = StringConcat(prefix, message)
        len = StringLength(full_msg)
        
        response = Allocate(Add(len, 4))
        
        SetByte(response, 0, 45)  // '-'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(full_msg, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)
        SetByte(response, Add(len, 2), 10)
        SetByte(response, Add(len, 3), 0)
        
        Deallocate(full_msg, 0)
        
        ReturnValue(response)
    }
}

// Convert integer to string for RESP responses
Function.RESP.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        Debug("resp.internal", level=4) {
            PrintMessage("[DEBUG] RESP.IntToString: Converting number ")
            PrintNumber(num)
        }

        // Handle zero
        IfCondition EqualTo(num, 0) ThenBlock: {
            result = Allocate(2)
            SetByte(result, 0, 48)  // '0'
            SetByte(result, 1, 0)   // null terminator
            ReturnValue(result)
        }
        
        // Check if negative but use a separate variable for absolute value
        is_negative = LessThan(num, 0)
        absolute_value = num
        IfCondition is_negative ThenBlock: {
            absolute_value = Subtract(0, num)  // Make positive
        }
        
        // Count digits using absolute value
        temp = absolute_value
        digit_count = 0
        WhileLoop GreaterThan(temp, 0) {
            digit_count = Add(digit_count, 1)
            temp = Divide(temp, 10)
        }
        
        // Allocate buffer (digits + sign + null)
        buffer_size = digit_count
        IfCondition is_negative ThenBlock: {
            buffer_size = Add(buffer_size, 1)
        }
        buffer_size = Add(buffer_size, 1)  // null terminator
        
        buffer = Allocate(buffer_size)
        
        // Fill digits from right to left using absolute value
        pos = Subtract(digit_count, 1)
        IfCondition is_negative ThenBlock: {
            pos = Add(pos, 1)
        }
        
        temp = absolute_value  // Use absolute value, not modified num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(buffer, pos, Add(48, digit))  // '0' + digit
            pos = Subtract(pos, 1)
            temp = Divide(temp, 10)
        }
        
        // Add negative sign if needed
        IfCondition is_negative ThenBlock: {
            SetByte(buffer, 0, 45)  // '-'
        }
        
        // Add null terminator
        final_pos = digit_count
        IfCondition is_negative ThenBlock: {
            final_pos = Add(final_pos, 1)
        }
        SetByte(buffer, final_pos, 0)
        
        ReturnValue(buffer)
    }
}

// Build an integer response: :<num>\r\n
Function.RESP.Integer {
    Input: num: Integer
    Output: Address
    Body: {
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Integer: Building integer response for ")
            PrintNumber(num)
        }

        num_str = RESP.IntToString(num)
        len = StringLength(num_str)
        
        response = Allocate(Add(len, 4))
        
        SetByte(response, 0, 58)  // ':'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(num_str, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)
        SetByte(response, Add(len, 2), 10)
        SetByte(response, Add(len, 3), 0)
        
        Deallocate(num_str, 0)
        ReturnValue(response)
    }
}