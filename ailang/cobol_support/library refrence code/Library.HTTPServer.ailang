// Library.HTTPServer.ailang
// Lightweight HTTP/1.1 server for web UIs

LibraryImport.Socket
LibraryImport.XArrays

FixedPool.HTTPConfig {
    "port": Initialize=8080
    "max_connections": Initialize=100
    "static_root": Initialize=0  // Path to HTML/CSS/JS files
}

// HTTP request structure: [method, path, headers, body]
Function.HTTP.ParseRequest {
    Input: request_data: Address
    Output: Address
    Body: {
        req = Allocate(32)
        
        // Parse first line: GET /index.html HTTP/1.1
        method_end = StringFind(request_data, " ")
        method = StringSubstring(request_data, 0, method_end)
        
        // Extract path
        path_start = Add(method_end, 1)
        path_end = StringFind(Add(request_data, path_start), " ")
        path = StringSubstring(request_data, path_start, path_end)
        
        StoreValue(req, method)
        StoreValue(Add(req, 8), path)
        StoreValue(Add(req, 16), 0)  // headers (simplified)
        StoreValue(Add(req, 24), 0)  // body (simplified)
        
        ReturnValue(req)
    }
}

Function.HTTP.BuildResponse {
    Input: status: Integer       // 200, 404, etc.
    Input: content_type: Address // "text/html", "application/json"
    Input: body: Address
    Output: Address
    Body: {
        body_len = StringLength(body)
        
        // Build status line
        response = "HTTP/1.1 "
        
        IfCondition EqualTo(status, 200) ThenBlock: {
            response = StringConcat(response, "200 OK\r\n")
        } ElseBlock: {
            IfCondition EqualTo(status, 404) ThenBlock: {
                response = StringConcat(response, "404 Not Found\r\n")
            } ElseBlock: {
                response = StringConcat(response, "500 Internal Server Error\r\n")
            }
        }
        
        // Add headers
        response = StringConcat(response, "Content-Type: ")
        response = StringConcat(response, content_type)
        response = StringConcat(response, "\r\n")
        
        response = StringConcat(response, "Content-Length: ")
        response = StringConcat(response, NumberToString(body_len))
        response = StringConcat(response, "\r\n")
        
        response = StringConcat(response, "Connection: close\r\n")
        response = StringConcat(response, "\r\n")
        
        // Add body
        response = StringConcat(response, body)
        
        ReturnValue(response)
    }
}

// Add to HTTP server
Function.HandleJobSubmit {
    Input: req: Address
    Output: Address
    Body: {
        // POST /api/jobs/submit
        // Body: { "program": "CLAIMS01.exec", "params": {...} }
        
        body = ParseJSON(Dereference(Add(req, 24)))
        program = JSONGet(body, "program")
        
        // Create JCL on-the-fly
        jcl = StringConcat("JOB WEB_", GetTimestamp())
        jcl = StringConcat(jcl, "\nEXEC ")
        jcl = StringConcat(jcl, program)
        
        // Write to temp JCL file
        jcl_file = StringConcat("/tmp/job_", GetTimestamp())
        jcl_file = StringConcat(jcl_file, ".jcl")
        
        WriteTextFile(jcl_file, jcl)
        
        // Submit job
        job_id = Daemon.SubmitJob(jcl_file)
        
        // Return job ID
        response_json = StringConcat("{\"job_id\":", NumberToString(job_id))
        response_json = StringConcat(response_json, "}")
        
        ReturnValue(HTTP.BuildResponse(200, "application/json", response_json))
    }
}

Function.HTTP.ServeStaticFile {
    Input: path: Address
    Output: Address              // Response string
    Body: {
        // Sanitize path - prevent directory traversal
        is_root = StringCompare(path, "/")
        IfCondition EqualTo(is_root, 0) ThenBlock: {
            path = "/index.html"
        }
        
        // Build full file path
        static_root = "/opt/ailang/web"  // Configurable
        full_path = StringConcat(static_root, path)
        
        // Check if file exists
        exists = FileExists(full_path)
        
        IfCondition EqualTo(exists, 0) ThenBlock: {
            // 404 Not Found
            body = "<html><body><h1>404 Not Found</h1></body></html>"
            response = HTTP.BuildResponse(404, "text/html", body)
            ReturnValue(response)
        }
        
        // Read file
        content = LoadTextFile(full_path)
        
        // Determine content type from extension
        content_type = HTTP.GetContentType(path)
        
        // Build response
        response = HTTP.BuildResponse(200, content_type, content)
        
        Deallocate(content, 0)
        Deallocate(full_path, 0)
        
        ReturnValue(response)
    }
}

Function.HTTP.GetContentType {
    Input: path: Address
    Output: Address
    Body: {
        // Check file extension
        is_html = StringEndsWith(path, ".html")
        IfCondition EqualTo(is_html, 1) ThenBlock: {
            ReturnValue("text/html")
        }
        
        is_css = StringEndsWith(path, ".css")
        IfCondition EqualTo(is_css, 1) ThenBlock: {
            ReturnValue("text/css")
        }
        
        is_js = StringEndsWith(path, ".js")
        IfCondition EqualTo(is_js, 1) ThenBlock: {
            ReturnValue("application/javascript")
        }
        
        is_json = StringEndsWith(path, ".json")
        IfCondition EqualTo(is_json, 1) ThenBlock: {
            ReturnValue("application/json")
        }
        
        // Default
        ReturnValue("text/plain")
    }
}

Function.HTTP.StartServer {
    Input: port: Integer
    Input: handler: Address      // Function pointer for request handling
    Body: {
        // Create listening socket
        server_sock = Socket.Create(SocketConstants.AF_INET, SocketConstants.SOCK_STREAM)
        
        IfCondition LessThan(server_sock, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to create server socket")
            ReturnValue()
        }
        
        // Bind to port
        addr = Socket.CreateAddr("0.0.0.0", port)
        
        // syscall: bind(sockfd, addr, addrlen)
        bind_result = Syscall3(49, server_sock, addr, 16)
        
        IfCondition LessThan(bind_result, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to bind to port ")
            PrintNumber(port)
            ReturnValue()
        }
        
        // Listen for connections
        // syscall: listen(sockfd, backlog)
        listen_result = Syscall2(50, server_sock, 100)
        
        IfCondition LessThan(listen_result, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to listen on socket")
            ReturnValue()
        }
        
        PrintMessage("HTTP Server listening on port ")
        PrintNumber(port)
        
        // Accept loop
        WhileLoop True {
            // syscall: accept(sockfd, addr, addrlen)
            client_sock = Syscall3(43, server_sock, 0, 0)
            
            IfCondition GreaterEqual(client_sock, 0) ThenBlock: {
                // Handle request
                HTTP.HandleClient(client_sock, handler)
            }
        }
    }
}

Function.HTTP.HandleClient {
    Input: client_sock: Integer
    Input: handler: Address
    Body: {
        // Read request
        request_data = Socket.Recv(client_sock, 8192)
        
        IfCondition NotEqual(request_data, 0) ThenBlock: {
            // Parse request
            req = HTTP.ParseRequest(request_data)
            
            // Call handler function
            response = CallIndirect(handler, req)
            
            // Send response
            response_len = StringLength(response)
            Socket.Send(client_sock, response, response_len)
            
            // Cleanup
            Deallocate(request_data, 0)
            Deallocate(response, 0)
            
            // Free request structure
            method = Dereference(req)
            path = Dereference(Add(req, 8))
            Deallocate(method, 0)
            Deallocate(path, 0)
            Deallocate(req, 32)
        }
        
        // Close client connection
        Socket.Close(client_sock)
    }
}

// Helper: Check if string ends with suffix
Function.StringEndsWith {
    Input: str: Address
    Input: suffix: Address
    Output: Integer
    Body: {
        str_len = StringLength(str)
        suffix_len = StringLength(suffix)
        
        IfCondition LessThan(str_len, suffix_len) ThenBlock: {
            ReturnValue(0)
        }
        
        start_pos = Subtract(str_len, suffix_len)
        ending = StringSubstring(str, start_pos, suffix_len)
        
        result = StringCompare(ending, suffix)
        Deallocate(ending, 0)
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}