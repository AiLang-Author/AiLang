// aimacro_parser_v2.0.ailang
// AIMacro to AILANG transpiler
// Version 2.0 - Proper AIMacro syntax support

// Global variables for parameter passing
g_param1 = ""
g_return_value = ""

// Parser state
parser_input = ""
parser_pos = 0
parser_length = 0
output = ""
current_indent = 0

// Initialize parser
SubRoutine.InitParser {
    parser_input = g_param1
    parser_pos = 0
    parser_length = StringLength(parser_input)
    output = ""
    current_indent = 0
}

// Get current character
SubRoutine.GetChar {
    IfCondition LessThan(parser_pos, parser_length) ThenBlock {
        g_return_value = StringCharAt(parser_input, parser_pos)
    } ElseBlock {
        g_return_value = 0  // EOF
    }
}

// Advance position
SubRoutine.NextChar {
    IfCondition LessThan(parser_pos, parser_length) ThenBlock {
        parser_pos = Add(parser_pos, 1)
    }
}

// Skip whitespace and tabs (not newlines)
SubRoutine.SkipSpaces {
    RunTask(GetChar)
    ch = g_return_value
    WhileLoop Or(EqualTo(ch, 32), EqualTo(ch, 9)) {
        RunTask(NextChar)
        RunTask(GetChar)
        ch = g_return_value
    }
}

// Read until end of line
SubRoutine.GetLine {
    start = parser_pos
    RunTask(GetChar)
    ch = g_return_value
    WhileLoop And(NotEqual(ch, 10), NotEqual(ch, 0)) {
        RunTask(NextChar)
        RunTask(GetChar)
        ch = g_return_value
    }
    line = StringSubstring(parser_input, start, parser_pos)
    IfCondition EqualTo(ch, 10) ThenBlock {
        RunTask(NextChar)  // consume newline
    }
    g_return_value = line
}

// Read a word/identifier
SubRoutine.GetWord {
    RunTask(SkipSpaces)
    start = parser_pos
    RunTask(GetChar)
    ch = g_return_value
    
    // Check valid start char
    is_alpha = Or(And(GreaterEqual(ch, 65), LessEqual(ch, 90)),
                  And(GreaterEqual(ch, 97), LessEqual(ch, 122)))
    is_at = EqualTo(ch, 64)  // @ for macros
    
    IfCondition Not(Or(Or(is_alpha, is_at), EqualTo(ch, 95))) ThenBlock {
        g_return_value = ""
        ReturnValue(0)
    }
    
    // Continue reading word
    WhileLoop NotEqual(ch, 0) {
        is_alpha = Or(And(GreaterEqual(ch, 65), LessEqual(ch, 90)),
                      And(GreaterEqual(ch, 97), LessEqual(ch, 122)))
        is_digit = And(GreaterEqual(ch, 48), LessEqual(ch, 57))
        is_valid = Or(Or(Or(is_alpha, is_digit), EqualTo(ch, 95)), EqualTo(ch, 46))
        
        IfCondition Not(is_valid) ThenBlock {
            word = StringSubstring(parser_input, start, parser_pos)
            g_return_value = word
            ReturnValue(0)
        }
        
        RunTask(NextChar)
        RunTask(GetChar)
        ch = g_return_value
    }
    
    word = StringSubstring(parser_input, start, parser_pos)
    g_return_value = word
}

// Emit with indentation
SubRoutine.EmitIndented {
    line = g_param1
    
    i = 0
    WhileLoop LessThan(i, current_indent) {
        output = StringConcat(output, "    ")
        i = Add(i, 1)
    }
    
    output = StringConcat(output, line)
    output = StringConcat(output, "\n")
}

// Parse a single statement
SubRoutine.ParseStatement {
    line = g_param1
    
    // Skip empty lines and comments
    IfCondition EqualTo(StringLength(line), 0) ThenBlock {
        ReturnValue(0)
    }
    
    // Skip comments
    first_ch = StringCharAt(line, 0)
    IfCondition EqualTo(first_ch, 35) ThenBlock {  // #
        ReturnValue(0)
    }
    
    // Get first word
    temp_pos = parser_pos
    temp_input = parser_input
    parser_input = line
    parser_pos = 0
    
    RunTask(GetWord)
    first_word = g_return_value
    
    // Handle AIMacro keywords
    IfCondition StringEquals(first_word, "func") ThenBlock {
        // func name params:
        RunTask(GetWord)
        func_name = g_return_value
        
        // Skip to colon
        RunTask(GetChar)
        ch = g_return_value
        WhileLoop And(NotEqual(ch, 58), NotEqual(ch, 0)) {  // :
            RunTask(NextChar)
            RunTask(GetChar)
            ch = g_return_value
        }
        
        g_param1 = StringConcat("Function.", func_name)
        g_param1 = StringConcat(g_param1, " {")
        RunTask(EmitIndented)
        current_indent = Add(current_indent, 1)
        
        g_param1 = "Body: {"
        RunTask(EmitIndented)
        current_indent = Add(current_indent, 1)
        
    } ElseBlock {
        IfCondition StringEquals(first_word, "end") ThenBlock {
            // end; - close block
            IfCondition GreaterThan(current_indent, 0) ThenBlock {
                current_indent = Subtract(current_indent, 1)
                g_param1 = "}"
                RunTask(EmitIndented)
            }
            IfCondition GreaterThan(current_indent, 0) ThenBlock {
                current_indent = Subtract(current_indent, 1)
                g_param1 = "}"
                RunTask(EmitIndented)
            }
            
        } ElseBlock {
            IfCondition StringEquals(first_word, "return") ThenBlock {
                // return value;
                RunTask(SkipSpaces)
                rest_start = parser_pos
                
                // Find semicolon
                RunTask(GetChar)
                ch = g_return_value
                WhileLoop And(NotEqual(ch, 59), NotEqual(ch, 0)) {  // ;
                    RunTask(NextChar)
                    RunTask(GetChar)
                    ch = g_return_value
                }
                
                value = StringSubstring(parser_input, rest_start, parser_pos)
                g_param1 = StringConcat("ReturnValue(", value)
                g_param1 = StringConcat(g_param1, ")")
                RunTask(EmitIndented)
                
            } ElseBlock {
                IfCondition StringEquals(first_word, "loop") ThenBlock {
                    // loop:
                    g_param1 = "WhileLoop True {"
                    RunTask(EmitIndented)
                    current_indent = Add(current_indent, 1)
                    
                } ElseBlock {
                    IfCondition StringEquals(first_word, "if") ThenBlock {
                        // if condition:
                        RunTask(SkipSpaces)
                        cond_start = parser_pos
                        
                        // Find colon
                        RunTask(GetChar)
                        ch = g_return_value
                        WhileLoop And(NotEqual(ch, 58), NotEqual(ch, 0)) {
                            RunTask(NextChar)
                            RunTask(GetChar)
                            ch = g_return_value
                        }
                        
                        condition = StringSubstring(parser_input, cond_start, parser_pos)
                        g_param1 = StringConcat("IfCondition ", condition)
                        g_param1 = StringConcat(g_param1, " ThenBlock {")
                        RunTask(EmitIndented)
                        current_indent = Add(current_indent, 1)
                        
                    } ElseBlock {
                        // Check for macro call (@)
                        IfCondition EqualTo(StringCharAt(first_word, 0), 64) ThenBlock {  // @
                            // Convert @print to PrintMessage, etc
                            macro_name = StringSubstring(first_word, 1, StringLength(first_word))
                            
                            IfCondition StringEquals(macro_name, "print") ThenBlock {
                                // @print arg;
                                RunTask(SkipSpaces)
                                arg_start = parser_pos
                                
                                // Find end of line or semicolon
                                RunTask(GetChar)
                                ch = g_return_value
                                WhileLoop And(And(NotEqual(ch, 59), NotEqual(ch, 10)), NotEqual(ch, 0)) {
                                    RunTask(NextChar)
                                    RunTask(GetChar)
                                    ch = g_return_value
                                }
                                
                                arg = StringSubstring(parser_input, arg_start, parser_pos)
                                g_param1 = StringConcat("PrintMessage(", arg)
                                g_param1 = StringConcat(g_param1, ")")
                                RunTask(EmitIndented)
                                
                            } ElseBlock {
                                // Other macros - pass through for now
                                g_param1 = StringConcat("// Macro: ", line)
                                RunTask(EmitIndented)
                            }
                            
                        } ElseBlock {
                            // Assignment: var = value;
                            RunTask(SkipSpaces)
                            RunTask(GetChar)
                            ch = g_return_value
                            
                            IfCondition EqualTo(ch, 61) ThenBlock {  // =
                                RunTask(NextChar)
                                RunTask(SkipSpaces)
                                value_start = parser_pos
                                
                                // Find semicolon
                                RunTask(GetChar)
                                ch = g_return_value
                                WhileLoop And(NotEqual(ch, 59), NotEqual(ch, 0)) {
                                    RunTask(NextChar)
                                    RunTask(GetChar)
                                    ch = g_return_value
                                }
                                
                                value = StringSubstring(parser_input, value_start, parser_pos)
                                g_param1 = StringConcat(first_word, " = ")
                                g_param1 = StringConcat(g_param1, value)
                                RunTask(EmitIndented)
                            }
                        }
                    }
                }
            }
        }
    }
    
    parser_input = temp_input
    parser_pos = temp_pos
}

// Main transpiler
SubRoutine.TranspileAIMacro {
    source = g_param1
    
    g_param1 = source
    RunTask(InitParser)
    
    g_param1 = "// Generated from AIMacro"
    RunTask(EmitIndented)
    g_param1 = ""
    RunTask(EmitIndented)
    
    WhileLoop LessThan(parser_pos, parser_length) {
        RunTask(GetLine)
        line = g_return_value
        
        // Trim the line
        start = 0
        len = StringLength(line)
        WhileLoop And(LessThan(start, len), Or(EqualTo(StringCharAt(line, start), 32), EqualTo(StringCharAt(line, start), 9))) {
            start = Add(start, 1)
        }
        
        IfCondition LessThan(start, len) ThenBlock {
            trimmed = StringSubstring(line, start, len)
            g_param1 = trimmed
            RunTask(ParseStatement)
        }
    }
    
    // Close any remaining blocks
    WhileLoop GreaterThan(current_indent, 0) {
        current_indent = Subtract(current_indent, 1)
        g_param1 = "}"
        RunTask(EmitIndented)
    }
    
    g_return_value = output
}

// Test program
LoopMain.TestAIMacro {
    test_code = "# AIMacro test
func calculate x y:
    result = x + y;
    @print \"Calculating...\";
    return result;
end;

func main:
    temp = 42;
    value = calculate(10, 20);
    @print value;
    
    loop:
        @sensor.cpu.temp;
        @time.sleep 1000;
    end;
    
    return 0;
end;"
    
    PrintMessage("AIMacro Parser v2.0")
    PrintMessage("====================")
    PrintMessage("Input AIMacro code:")
    PrintMessage(test_code)
    PrintMessage("")
    
    g_param1 = test_code
    RunTask(TranspileAIMacro)
    result = g_return_value
    
    PrintMessage("Output AILANG code:")
    PrintMessage(result)
}

// Version History:
// v2.0.1 - Fixed line parsing issues
//        - Now works directly with line strings instead of switching parser context
// v2.0   - Complete rewrite for proper AIMacro syntax
//        - Supports: func/end; blocks, @macros, semicolon terminators
//        - Clean : and end; syntax (no whitespace issues)
// v1.x   - Python-like syntax attempts (deprecated)