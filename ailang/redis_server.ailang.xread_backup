// redis_server_extended.ailang
// Extended Redis server with more commands

LibraryImport.RESP
LibraryImport.XArrays

FixedPool.RedisData {
    "store_ptr": Initialize=0
}

// State for stream ID generation
FixedPool.StreamState {
    "last_id_ms": Initialize=0
}

// Type constants for our Redis-like objects
FixedPool.DataTypes {
    "TYPE_STRING": Initialize=0
    "TYPE_LIST": Initialize=1
    "TYPE_STREAM": Initialize=2
    "TYPE_SET": Initialize=3
}

// Mailbox for passing new client sockets to actors
FixedPool.Mailbox {
    "new_client_socket": Initialize=0
}

// Define standard system call numbers for clarity and maintainability
 // Linux x86-64 syscall number for time(NULL)
FixedPool.SyscallNumbers {
   
    "TIME": Initialize=201
}

// Helper function to convert string to integer
Function.Helpers.StringToInt {
    Input: str:
    Body: {
        // Simple string to integer conversion
        result = 0
        i = 0
        len = StringLength(str)
        negative = 0
        
        // Check for negative sign
        IfCondition GreaterThan(len, 0) ThenBlock: {
            first = GetByte(str, 0)
            IfCondition EqualTo(first, 45) ThenBlock: {  // '-'
                negative = 1
                i = 1
            }
        }
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            // Check if digit (48-57 are '0'-'9')
            IfCondition And(GreaterEqual(byte, 48), LessEqual(byte, 57)) ThenBlock: {
                digit = Subtract(byte, 48)
                result = Multiply(result, 10)
                result = Add(result, digit)
            }
            i = Add(i, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Helper to convert integer to string
Function.Helpers.IntToString {
    Input: num:
    Body: {
        // Allocate buffer for result
        buffer = Allocate(32)
        pos = 0
        value = num
        
        // Handle negative
        IfCondition LessThan(value, 0) ThenBlock: {
            SetByte(buffer, pos, 45)  // '-'
            pos = Add(pos, 1)
            value = Subtract(0, value)
        }
        
        // Handle zero
        IfCondition EqualTo(value, 0) ThenBlock: {
            SetByte(buffer, pos, 48)  // '0'
            pos = Add(pos, 1)
            SetByte(buffer, pos, 0)   // null terminate
            ReturnValue(buffer)
        }
        
        // Convert digits (simplified - assumes small numbers)
        start_pos = pos
        WhileLoop GreaterThan(value, 0) {
            digit = Modulo(value, 10)
            SetByte(buffer, pos, Add(48, digit))
            pos = Add(pos, 1)
            value = Divide(value, 10)
        }
        
        // Reverse the digits
        end_pos = Subtract(pos, 1)
        WhileLoop LessThan(start_pos, end_pos) {
            temp = GetByte(buffer, start_pos)
            SetByte(buffer, start_pos, GetByte(buffer, end_pos))
            SetByte(buffer, end_pos, temp)
            start_pos = Add(start_pos, 1)
            end_pos = Subtract(end_pos, 1)
        }
        
        SetByte(buffer, pos, 0)  // null terminate
        ReturnValue(buffer)
    }
}

// Helper to parse a stream ID string "ms-seq" into an array of two integers.
Function.Helpers.ParseStreamID {
    Input: id_str: Address
    Output: Address // Pointer to an XArray with 2 integers [ms, seq]
    Body: {
        // Find the position of the '-' separator
        dash_pos = StringIndexOf(id_str, "-")
        
        IfCondition EqualTo(dash_pos, -1) ThenBlock: {
            // Invalid ID format, return null
            ReturnValue(0)
        }
        
        // Extract and convert the milliseconds part
        ms_str = StringSubstring(id_str, 0, dash_pos)
        ms_val = Helpers.StringToInt(ms_str)
        Deallocate(ms_str, 0)
        
        // Extract and convert the sequence part
        len = StringLength(id_str)
        seq_start = Add(dash_pos, 1)
        seq_len = Subtract(len, seq_start)
        seq_str = StringSubstring(id_str, seq_start, seq_len)
        seq_val = Helpers.StringToInt(seq_str)
        Deallocate(seq_str, 0)
        
        // Create an XArray to hold the two integer parts.
        // WARNING: The current XArray library does not have a destructor, so this will leak memory.
        result_arr = XArray.XCreate(2)
        XArray.XPush(result_arr, ms_val)
        XArray.XPush(result_arr, seq_val)
        
        ReturnValue(result_arr)
    }
}

// Helper to compare two stream ID strings (e.g., "1-0" vs "0-10").
Function.Helpers.CompareStreamIDs {
    Input: id1_str: Address
    Input: id2_str: Address
    Output: Integer // Returns 1 if id1 > id2, -1 if id1 < id2, 0 if equal.
    Body: {
        id1_parts = Helpers.ParseStreamID(id1_str)
        id2_parts = Helpers.ParseStreamID(id2_str)
        
        // Handle parsing errors
        IfCondition Or(EqualTo(id1_parts, 0), EqualTo(id2_parts, 0)) ThenBlock: {
            // Proper cleanup would free the parsed arrays here.
            ReturnValue(-2) // Indicate error
        }
        
        id1_ms = XArray.XGet(id1_parts, 0)
        id1_seq = XArray.XGet(id1_parts, 1)
        id2_ms = XArray.XGet(id2_parts, 0)
        id2_seq = XArray.XGet(id2_parts, 1)
        
        // Clean up the temporary XArray objects created by ParseStreamID.
        // The integer values inside are not pointers, so we don't need to free them.
        XArray.XDestroy(id1_parts)
        XArray.XDestroy(id2_parts)
        
        result = 0
        IfCondition GreaterThan(id1_ms, id2_ms) ThenBlock: {
            result = 1
        } ElseBlock: {
            IfCondition LessThan(id1_ms, id2_ms) ThenBlock: {
                result = -1
            } ElseBlock: {
                // Milliseconds are equal, so compare sequence numbers
                IfCondition GreaterThan(id1_seq, id2_seq) ThenBlock: { result = 1 }
                IfCondition LessThan(id1_seq, id2_seq) ThenBlock: { result = -1 }
            }
        }
        
        ReturnValue(result)
    }
}

// Helper to get the system time in milliseconds.
Function.Helpers.GetSystemTime {
    Output: Integer // Returns current time in milliseconds
    Body: {
        // Per your hint, we can use a syscall to get real time.
        // This is much more accurate than the simulated clock.
        // Assuming syscall #201 is 'time' which returns seconds since epoch,
        // similar to Linux. A more advanced implementation might use a
        // higher resolution clock syscall if available.
        time_in_seconds = SystemCall(SyscallNumbers.TIME, 0) // Arg 0 for time(NULL)
        time_in_ms = Multiply(time_in_seconds, 1000)
        ReturnValue(time_in_ms)
    }
}

// Helper to check for and handle key expiration (passive eviction)
Function.Helpers.CheckAndEvictExpiredKey {
    Input: key: Address
    Input: wrapper: Address
    Output: Integer // Returns 1 if key was expired and evicted, 0 otherwise.
    Body: {
        // Expiration is stored at offset 8
        expiration_ms = Dereference(Add(wrapper, 8))
        
        // A value of 0 means no expiration is set.
        IfCondition NotEqual(expiration_ms, 0) ThenBlock: {
            now = Helpers.GetSystemTime()
            IfCondition LessThan(expiration_ms, now) ThenBlock: {
                // --- Key is expired, evict it now ---
                // This logic is a safe subset of the DEL command.
                // We can call XDelete, which returns the wrapper for us to free.
                deleted_wrapper = XSHash.XDelete(RedisData.store_ptr, key)
                IfCondition NotEqual(deleted_wrapper, XArrays.XNULL) ThenBlock: {
                    type = Dereference(deleted_wrapper)
                    value_ptr = Dereference(Add(deleted_wrapper, 16)) // New offset for value
                    
                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                    IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                    IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                    IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                    
                    Deallocate(deleted_wrapper, 0)
                }
                ReturnValue(1) // Key was expired and evicted.
            }
        }
        
        ReturnValue(0) // Key is not expired.
    }
}

// --- START: Pipelining-aware RESP Parser ---
// This logic is added here to fix a crash caused by the server's main loop
// expecting a pipelining-aware parser that did not exist in the RESP library.

// Finds the next CRLF (\r\n) in the buffer from a given offset.
// Returns the index of the \r, or -1 if not found.
Function.Helpers.Internal.FindCRLF {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Integer
    Body: {
        PrintMessage("[DEBUG FindCRLF] Starting search from offset ")
        PrintNumber(offset)
        PrintMessage(" in buffer of length ")
        PrintNumber(length)
        PrintMessage("\n")
        
        i = offset
        // Stop one before the end to allow checking i and i+1
        limit = Subtract(length, 1)
        
        WhileLoop LessThan(i, limit) {
            char1 = GetByte(buffer, i)
            IfCondition EqualTo(char1, 13) ThenBlock: { // '\r'
                char2 = GetByte(buffer, Add(i, 1))
                IfCondition EqualTo(char2, 10) ThenBlock: { // '\n'
                    PrintMessage("[DEBUG FindCRLF] Found CRLF at position ")
                    PrintNumber(i)
                    PrintMessage("\n")
                    ReturnValue(i) // Found it
                }
            }
            i = Add(i, 1)
        }
        
        PrintMessage("[DEBUG FindCRLF] No CRLF found, returning -1\n")
        ReturnValue(-1) // Not found
    }
}

// Parses an integer from a slice of the buffer.
Function.Helpers.Internal.ParseIntFromSlice {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        // Declare local variables explicitly
        parse_result = 0
        parse_pos = start
        parse_negative = 0
        parse_byte = 0
        parse_digit = 0
        
        // Check for negative at start
        parse_byte = GetByte(buffer, parse_pos)
        IfCondition EqualTo(parse_byte, 45) ThenBlock: { // '-'
            parse_negative = 1
            parse_pos = Add(parse_pos, 1)
        }
        
        // Parse each digit
        WhileLoop LessThan(parse_pos, end) {
            parse_byte = GetByte(buffer, parse_pos)
            parse_digit = Subtract(parse_byte, 48)
            parse_result = Multiply(parse_result, 10)
            parse_result = Add(parse_result, parse_digit)
            parse_pos = Add(parse_pos, 1)
        }
        
        IfCondition parse_negative ThenBlock: {
            parse_result = Subtract(0, parse_result)
        }
        
        ReturnValue(parse_result)
    }
}

// The main recursive parser. Parses one RESP value from the buffer.
// Returns an XArray: [parsed_value_ptr, bytes_consumed]
// Returns [0, 0] if the buffer has incomplete data.
Function.Helpers.Internal.ParseValue {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Address
    Body: {
        Debug("parser.value", level=1) {
            PrintMessage("[DEBUG] ParseValue: length=")
            PrintNumber(length)
            PrintMessage(" offset=")
            PrintNumber(offset)
            PrintMessage("\n")
        }

        // Check if we have at least one byte for the type prefix
        IfCondition GreaterEqual(offset, length) ThenBlock: {
            Debug("parser.error", level=1) {
                PrintMessage("[DEBUG] ParseValue: No data to parse (offset >= length)\n")
            }
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, 0)
            XArray.XPush(res_arr, 0)
            ReturnValue(res_arr)
        }
        
        type_char = GetByte(buffer, offset)
        Debug("parser.type", level=1) {
            PrintMessage("[DEBUG] ParseValue: type char = ")
            PrintNumber(type_char)
            PrintMessage(" (42=*, 36=$, 43=+, 45=-, 58=:)\n")
        }
        
        // --- Case: Bulk String ($) ---
        IfCondition EqualTo(type_char, 36) ThenBlock: { // '$'
            line_end_pos = Helpers.Internal.FindCRLF(buffer, length, offset)
            IfCondition EqualTo(line_end_pos, -1) ThenBlock: { // Incomplete line
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            
            str_len = Helpers.Internal.ParseIntFromSlice(buffer, Add(offset, 1), line_end_pos)
            
            IfCondition EqualTo(str_len, -1) ThenBlock: { // RESP Null Bulk String "$-1\r\n"
                total_consumed = Add(Subtract(line_end_pos, offset), 2)
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0) // Represent nil as a null pointer
                XArray.XPush(res_arr, total_consumed)
                ReturnValue(res_arr)
            }
            
            data_start = Add(line_end_pos, 2)
            total_needed = Add(data_start, Add(str_len, 2))
            IfCondition GreaterThan(total_needed, length) ThenBlock: { // Incomplete data
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            
            new_str = Allocate(Add(str_len, 1))
            data_ptr = Add(buffer, data_start)
            MemoryCopy(new_str, data_ptr, str_len)
            SetByte(new_str, str_len, 0) // Null terminate
            
            total_consumed = Subtract(total_needed, offset)
            
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, new_str)
            XArray.XPush(res_arr, total_consumed)
            ReturnValue(res_arr)
        }
        
        // --- Case: Array (*) ---
        IfCondition EqualTo(type_char, 42) ThenBlock: { // '*'
            PrintMessage("[DEBUG] Parsing array...\n")
            
            arr_crlf = Helpers.Internal.FindCRLF(buffer, length, offset)  // Unique name
            PrintMessage("[DEBUG] arr_crlf after FindCRLF: ")
            PrintNumber(arr_crlf)
            PrintMessage("\n")
            
            IfCondition EqualTo(arr_crlf, -1) ThenBlock: { // Incomplete line
                PrintMessage("[DEBUG] Array: no CRLF for count\n")
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            
            array_len = Helpers.Internal.ParseIntFromSlice(buffer, Add(offset, 1), arr_crlf)
            PrintMessage("[DEBUG] arr_crlf after ParseIntFromSlice: ")
            PrintNumber(arr_crlf)
            PrintMessage("\n")
            
            PrintMessage("[DEBUG] Array length: ")
            PrintNumber(array_len)
            PrintMessage("\n")
            
            parsed_elements = XArray.XCreate(array_len)
            PrintMessage("[DEBUG] arr_crlf after XArray.XCreate: ")
            PrintNumber(arr_crlf)
            PrintMessage("\n")
            
            current_offset = Add(arr_crlf, 2)
            PrintMessage("[DEBUG] current_offset = Add(")
            PrintNumber(arr_crlf)
            PrintMessage(", 2) = ")
            PrintNumber(current_offset)
            PrintMessage("\n")
            
            i = 0
            WhileLoop LessThan(i, array_len) {
                element_res = Helpers.Internal.ParseValue(buffer, length, current_offset)
                element_val = XArray.XGet(element_res, 0)
                consumed = XArray.XGet(element_res, 1)
                
                IfCondition EqualTo(consumed, 0) ThenBlock: {
                    // Incomplete data for a sub-element. Abort and clean up.
                    j = 0
                    parsed_count = XArray.XSize(parsed_elements)
                    WhileLoop LessThan(j, parsed_count) {
                        item = XArray.XGet(parsed_elements, j)
                        Deallocate(item, 0)
                        j = Add(j, 1)
                    }
                    XArray.XDestroy(parsed_elements)
                    XArray.XDestroy(element_res)
                    
                    res_arr = XArray.XCreate(2)
                    XArray.XPush(res_arr, 0)
                    XArray.XPush(res_arr, 0)
                    ReturnValue(res_arr)
                }
                
                XArray.XPush(parsed_elements, element_val)
                current_offset = Add(current_offset, consumed)
                XArray.XDestroy(element_res)
                i = Add(i, 1)
            }
            
            total_consumed = Subtract(current_offset, offset)
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, parsed_elements)
            XArray.XPush(res_arr, total_consumed)
            ReturnValue(res_arr)
        }

// Unsupported type for client commands
res_arr = XArray.XCreate(2)
XArray.XPush(res_arr, 0)
XArray.XPush(res_arr, 0)
ReturnValue(res_arr)
    }
}

// The public function to be called by the server's main loop.
Function.Helpers.ParsePipelinedArray {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Address // Returns XArray: [native_command_array, bytes_consumed]
    Body: {
        Debug("parser.entry", level=1) {
            PrintMessage("[DEBUG] ParsePipelinedArray called with length: ")
            PrintNumber(length)
            PrintMessage(" offset: ")
            PrintNumber(offset)
            PrintMessage("\n")
        }
        parse_result = Helpers.Internal.ParseValue(buffer, length, offset)
        parsed_value = XArray.XGet(parse_result, 0)
        bytes_consumed = XArray.XGet(parse_result, 1)
        
        IfCondition EqualTo(bytes_consumed, 0) ThenBlock: {
            XArray.XDestroy(parse_result)
            final_res = XArray.XCreate(2)
            XArray.XPush(final_res, 0)
            XArray.XPush(final_res, 0)
            ReturnValue(final_res)
        }
        
        // Convert the parsed XArray of strings to a native Array of strings.
        num_elements = XArray.XSize(parsed_value)
        native_array = ArrayCreate(num_elements)
        
        i = 0
        WhileLoop LessThan(i, num_elements) {
            element_str = XArray.XGet(parsed_value, i)
            ArraySet(native_array, i, element_str)
            i = Add(i, 1)
        }
        
        XArray.XDestroy(parsed_value)
        XArray.XDestroy(parse_result)
        
        final_res = XArray.XCreate(2)
        XArray.XPush(final_res, native_array)
        XArray.XPush(final_res, bytes_consumed)
        ReturnValue(final_res)
    }
}
// --- END: Pipelining-aware RESP Parser ---

Function.Server.HandleClient {
    Input: client_socket: Integer
    Input: store_ptr: Integer
    Body: {
        // --- CRITICAL FIX: Get a local, reliable pointer to the global store ---
        // This ensures we are using the runtime-initialized value from Main.
        // Use the passed store pointer

        store = store_ptr

        Debug("client.connect", level=1) { PrintMessage("[DEBUG] New client connected.") }

        buffer = Allocate(4096)
        // --- FIX: Add buffer state for pipelining support ---
        buffer_data_len = 0
        buffer_offset = 0
        client_connected = 1
        
        WhileLoop client_connected {
            Debug("loop.state", level=1) {
                PrintMessage("[DEBUG] Main loop iteration - buffer_offset: ")
                PrintNumber(buffer_offset)
                PrintMessage(" buffer_data_len: ")
                PrintNumber(buffer_data_len)
                PrintMessage("\n")
            }
            // --- FIX: Process all commands in the buffer before reading more ---
            // This loop handles pipelined commands sent in a single batch.
            WhileLoop And(client_connected, LessThan(buffer_offset, buffer_data_len)) {
                // NOTE: This change assumes RESP.ParseArray is modified to take an offset and
                // return an XArray: [command_array, bytes_consumed]. We now use our local helper.
                parse_result = Helpers.ParsePipelinedArray(buffer, buffer_data_len, buffer_offset)
                
                command_array = XArray.XGet(parse_result, 0)
                bytes_consumed = XArray.XGet(parse_result, 1)
                XArray.XDestroy(parse_result) // Clean up the result container

                // If no full command could be parsed, break to read more data
                IfCondition EqualTo(bytes_consumed, 0) ThenBlock: {
                    BreakLoop
                }

                // Advance the buffer offset
                buffer_offset = Add(buffer_offset, bytes_consumed)

                IfCondition NotEqual(command_array, 0) ThenBlock: {
                    // --- Existing command processing logic starts here ---
                    array_len = ArrayLength(command_array)
                    
                    IfCondition GreaterThan(array_len, 0) ThenBlock: {
                        cmd_str = ArrayGet(command_array, 0)
                        command = StringToUpper(cmd_str)

                        Debug("command.parse", level=1) {
                            PrintMessage("[DEBUG] Parsed command:")
                            PrintMessage(command)
                        }
                        
                        // --- FIX: Make command dispatch more robust ---
                        // Use a flag to distinguish between "unhandled command" and "handled command with no response".
                        command_handled = 0
                        response = 0
                        // --- FIX: Add tracking variables for response data structures ---
                        response_source_array = 0
                        response_source_xarray_deep = 0
                        
                        PrintMessage("[DEBUG] About to do first StringCompare for PING\n")

                        // PING
                        is_ping = StringCompare(command, "PING")

                        PrintMessage("[DEBUG] PING comparison done, result: ")
                        PrintNumber(is_ping)
                        PrintMessage("\n")

                        IfCondition EqualTo(is_ping, 0) ThenBlock: {
                            PrintMessage("[DEBUG] Inside PING handler\n")
                            response = RESP.SimpleString("PONG")
                            command_handled = 1
                        }

                        PrintMessage("[DEBUG] About to do ECHO StringCompare\n")

                        // ECHO
                        is_echo = StringCompare(command, "ECHO")

                        PrintMessage("[DEBUG] ECHO comparison done, result: ")
                        PrintNumber(is_echo)
                        PrintMessage("\n")

                        IfCondition EqualTo(is_echo, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'echo' command")
                            } ElseBlock: {
                                echo_msg = ArrayGet(command_array, 1)
                                response = RESP.BulkString(echo_msg)
                            }
                            command_handled = 1
                        }

                        PrintMessage("[DEBUG] About to do SET StringCompare\n")

                        // SET
                        is_set = StringCompare(command, "SET")

                        PrintMessage("[DEBUG] SET comparison done, result: ")
                        PrintNumber(is_set)
                        PrintMessage("\n")

                        IfCondition EqualTo(is_set, 0) ThenBlock: {
                            PrintMessage("[DEBUG] Inside SET condition block\n")
                            IfCondition LessThan(array_len, 3) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'set' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                value = ArrayGet(command_array, 2)
                                Debug("command.set", level=1) {
                                    PrintMessage("[DEBUG] SET Key:")
                                    PrintMessage(key)
                                    PrintMessage("[DEBUG] SET Value:")
                                    PrintMessage(value)
                                }

                                PrintMessage("[DEBUG] SET Value: ")
                                PrintMessage(value)
                                PrintMessage("\n")

                                // ADD THIS:
                                PrintMessage("[DEBUG] About to access store variable\n")
                                PrintMessage("[DEBUG] Address of store: ")
                               // PrintNumber(AddressOf(store))
                                PrintMessage("\n")
                                PrintMessage("[DEBUG] Value of store: ")
                                PrintNumber(store)
                                PrintMessage("\n")

                                // If store is 0, try forcing a reinit:
                                IfCondition EqualTo(store, 0) ThenBlock: {
                                    PrintMessage("[ERROR] Store is NULL! Attempting reinit...\n")
                                    RedisData.store_ptr = XSHash.XCreate(1024)
                                    PrintMessage("[DEBUG] After reinit, store = ")
                                    PrintNumber(RedisData.store_ptr)
                                    PrintMessage("\n")
                                }

                                // --- FIX: Properly handle overwriting existing keys to prevent memory leaks ---
                                // To safely overwrite, we first delete the old key if it exists.
                                // This ensures any complex data types (like lists) are properly freed.
                                old_value_wrapper = XSHash.XDelete(store, key)

                                is_found = NotEqual(old_value_wrapper, XArrays.XNULL)
                                IfCondition is_found ThenBlock: {
                                    // An old value was found and removed. Free its memory.
                                    // The value pointer is now at offset 16.
                                    type = Dereference(old_value_wrapper)
                                    value_ptr = Dereference(Add(old_value_wrapper, 16))

                                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }

                                    Deallocate(old_value_wrapper, 0) // Finally, free the wrapper itself
                                }

                                // Create a wrapper object: [type, expiration_ms, value_ptr] - 24 bytes
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING) // type at offset 0
                                StoreValue(Add(new_wrapper, 8), 0) // expiration_ms at offset 8, 0=persistent
                                // The wrapper now owns the value, so we must copy it.
                                value_copy = Helpers.StringCopy(value)
                                StoreValue(Add(new_wrapper, 16), value_copy) // value_ptr at offset 16

                                // Now, insert the new value. Since we deleted the old key, this is always a clean insert.
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.SimpleString("OK")
                            }
                            command_handled = 1
                        }

                        // SETEX - Set with expiration in seconds
                        is_setex = StringCompare(command, "SETEX")
                        IfCondition EqualTo(is_setex, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 4) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'setex' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                seconds_str = ArrayGet(command_array, 2)
                                value = ArrayGet(command_array, 3)

                                // Calculate expiration time
                                now = Helpers.GetSystemTime()
                                seconds = Helpers.StringToInt(seconds_str)
                                expire_time_ms = Add(now, Multiply(seconds, 1000))

                                // Delete existing key if present (same logic as SET)
                                old_value_wrapper = XSHash.XDelete(store, key)
                                is_found = NotEqual(old_value_wrapper, XArrays.XNULL)
                                IfCondition is_found ThenBlock: {
                                    type = Dereference(old_value_wrapper)
                                    value_ptr = Dereference(Add(old_value_wrapper, 16))

                                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }

                                    Deallocate(old_value_wrapper, 0)
                                }

                                // Create new wrapper with expiration
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), expire_time_ms)  // Set expiration
                                value_copy = Helpers.StringCopy(value)
                                StoreValue(Add(new_wrapper, 16), value_copy)
                                XSHash.XInsert(store, key, new_wrapper)

                                response = RESP.SimpleString("OK")
                            }
                            command_handled = 1
                        }

                        // MSET - Multi-SET (set multiple key-value pairs at once)
                        is_mset = StringCompare(command, "MSET")
                        IfCondition EqualTo(is_mset, 0) ThenBlock: {
                            num_args = Subtract(array_len, 1)
                            is_even = EqualTo(Modulo(num_args, 2), 0)
                            IfCondition Or(LessThan(num_args, 2), Not(is_even)) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'mset' command")
                            } ElseBlock: {
                                // Process all key-value pairs
                                i = 1
                                WhileLoop LessThan(i, array_len) {
                                    key = ArrayGet(command_array, i)
                                    value = ArrayGet(command_array, Add(i, 1))

                                    // Delete existing key (same logic as SET)
                                    old_value_wrapper = XSHash.XDelete(store, key)
                                    is_found = NotEqual(old_value_wrapper, XArrays.XNULL)
                                    IfCondition is_found ThenBlock: {
                                        type = Dereference(old_value_wrapper)
                                        value_ptr = Dereference(Add(old_value_wrapper, 16))

                                        IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                        IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                        IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                        IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }

                                        Deallocate(old_value_wrapper, 0)
                                    }

                                    // Create new wrapper
                                    new_wrapper = Allocate(24)
                                    StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                    StoreValue(Add(new_wrapper, 8), 0)  // No expiration
                                    value_copy = Helpers.StringCopy(value)
                                    StoreValue(Add(new_wrapper, 16), value_copy)
                                    XSHash.XInsert(store, key, new_wrapper)

                                    i = Add(i, 2)  // Skip to next key-value pair
                                }

                                response = RESP.SimpleString("OK")
                            }
                            command_handled = 1
                        }

                        // GET
                        is_get = StringCompare(command, "GET")
                        IfCondition EqualTo(is_get, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'get' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                // --- PERFORMANCE OPTIMIZATION: Avoid double lookup ---
                                // Call XLookup once and check the result instead of calling XExists then XLookup.
                                wrapper = XSHash.XLookup(store, key)

                                // XLookup returns XNULL (-1) if not found.
                                is_found = NotEqual(wrapper, XArrays.XNULL)

                                IfCondition is_found ThenBlock: {
                                    // Check for expiration before proceeding
                                    is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                    IfCondition is_expired ThenBlock: {
                                        response = RESP.BulkString(0) // Act as if not found
                                    } ElseBlock: {
                                        // Key is valid, proceed with GET
                                        type = Dereference(wrapper)
                                        IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                            value_ptr = Dereference(Add(wrapper, 16))
                                            response = RESP.BulkString(value_ptr)
                                        } ElseBlock: {
                                            // Tried to GET a non-string type
                                            response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                        }
                                    }
                                } ElseBlock: {
                                    response = RESP.BulkString(0)  // nil
                                }
                            }
                            command_handled = 1
                        }

                        // MGET - Multi-GET (get multiple keys at once)
                        is_mget = StringCompare(command, "MGET")
                        IfCondition EqualTo(is_mget, 0) ThenBlock: {
                            IfCondition LessThan(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'mget' command")
                            } ElseBlock: {
                                // --- FIX: Manually build the array response to prevent a crash from RESP.Array(nil) ---
                                num_keys = Subtract(array_len, 1)
                                num_keys_str = Helpers.IntToString(num_keys)
                                response = StringConcat("*", num_keys_str, "\r\n")
                                Deallocate(num_keys_str, 0)

                                i = 1
                                WhileLoop LessThan(i, array_len) {
                                    key = ArrayGet(command_array, i)
                                    wrapper = XSHash.XLookup(store, key)

                                    part_response = 0
                                    is_found = NotEqual(wrapper, XArrays.XNULL)
                                    IfCondition is_found ThenBlock: {
                                        // Check expiration
                                        is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                        IfCondition is_expired ThenBlock: {
                                            part_response = RESP.BulkString(0) // nil for expired
                                        } ElseBlock: {
                                            type = Dereference(wrapper)
                                            IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                                value_ptr = Dereference(Add(wrapper, 16))
                                                part_response = RESP.BulkString(value_ptr)
                                            } ElseBlock: {
                                                part_response = RESP.BulkString(0) // nil for wrong type
                                            }
                                        }
                                    } ElseBlock: {
                                        part_response = RESP.BulkString(0) // nil for not found
                                    }

                                    // Append the part to the main response
                                    temp_response = StringConcat(response, part_response)
                                    Deallocate(response, 0)
                                    Deallocate(part_response, 0)
                                    response = temp_response

                                    i = Add(i, 1)
                                }
                                // Since we built the response string manually, no source array needs cleanup.
                            }
                            command_handled = 1
                        }

                        // DEL
                        is_del = StringCompare(command, "DEL")
                        IfCondition And(EqualTo(is_del, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            // --- FIX: Implement proper DEL with type-aware memory cleanup ---
                            key = ArrayGet(command_array, 1)

                            // XSHash.XDelete finds, unlinks, and frees the hash node and its key.
                            // It returns the pointer to the value wrapper for us to clean up.
                            value_wrapper_ptr = XSHash.XDelete(store, key)

                            is_found = NotEqual(value_wrapper_ptr, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                // Now, inspect the wrapper to free the actual value correctly.
                                type = Dereference(value_wrapper_ptr)
                                value_ptr = Dereference(Add(value_wrapper_ptr, 16))

                                IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    Deallocate(value_ptr, 0) // Free the string
                                }
                                IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    XList.XDestroyDeep(value_ptr) // Free the list and its contents
                                }
                                IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }

                                Deallocate(value_wrapper_ptr, 0) // Finally, free the wrapper itself
                                response = RESP.Integer(1) // Return 1 for deleted key
                            } ElseBlock: {
                                response = RESP.Integer(0) // Return 0 if key was not found
                            }
                            command_handled = 1
                        }

                        // --- SET COMMANDS ---

                        // SADD - Add members to a set
                        is_sadd = StringCompare(command, "SADD")
                        IfCondition And(EqualTo(is_sadd, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            set_ptr = 0

                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_SET) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    set_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                // Create a new set (which is just a hash table)
                                set_ptr = XSHash.XCreate(16)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_SET)
                                StoreValue(Add(new_wrapper, 8), 0) // expiration
                                StoreValue(Add(new_wrapper, 16), set_ptr)
                                XSHash.XInsert(store, key, new_wrapper)
                            }

                            // If we have a valid set_ptr, add the members
                            IfCondition NotEqual(set_ptr, 0) ThenBlock: {
                                added_count = 0
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    member = ArrayGet(command_array, i)
                                    // Use XExists to check for presence before inserting
                                    exists = XSHash.XExists(set_ptr, member)
                                    IfCondition Not(exists) ThenBlock: {
                                        // The value in a set's hash table is irrelevant, use 1
                                        XSHash.XInsert(set_ptr, member, 1)
                                        added_count = Add(added_count, 1)
                                    }
                                    i = Add(i, 1)
                                }
                                response = RESP.Integer(added_count)
                            }
                            command_handled = 1
                        }

                        // SMEMBERS - Get all members of a set
                        is_smembers = StringCompare(command, "SMEMBERS")
                        IfCondition EqualTo(is_smembers, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'smembers' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                wrapper = XSHash.XLookup(store, key)
                                is_found = NotEqual(wrapper, XArrays.XNULL)

                                IfCondition Not(is_found) ThenBlock: {
                                    empty_arr = ArrayCreate(0)
                                    response = RESP.Array(empty_arr)
                                    response_source_array = empty_arr
                                } ElseBlock: {
                                    type = Dereference(wrapper)
                                    IfCondition NotEqual(type, DataTypes.TYPE_SET) ThenBlock: {
                                        response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                    } ElseBlock: {
                                        set_ptr = Dereference(Add(wrapper, 16))
                                        keys_xarray = XSHash.XKeys(set_ptr)

                                        num_members = XArray.XSize(keys_xarray)
                                        members_array = ArrayCreate(num_members)

                                        i = 0
                                        WhileLoop LessThan(i, num_members) {
                                            member_str = XArray.XGet(keys_xarray, i)
                                            ArraySet(members_array, i, member_str)
                                            i = Add(i, 1)
                                        }

                                        response = RESP.Array(members_array)

                                        // --- FIX: Track created arrays for proper cleanup ---
                                        response_source_array = members_array
                                        response_source_xarray_deep = keys_xarray
                                    }
                                }
                            }
                            command_handled = 1
                        }

                        // SCARD - Get set cardinality (number of members)
                        is_scard = StringCompare(command, "SCARD")
                        IfCondition EqualTo(is_scard, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'scard' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                wrapper = XSHash.XLookup(store, key)

                                IfCondition NotEqual(wrapper, XArrays.XNULL) ThenBlock: {
                                    // Check expiration
                                    is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                    IfCondition is_expired ThenBlock: {
                                        response = RESP.Integer(0)
                                    } ElseBlock: {
                                        type = Dereference(wrapper)
                                        IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: {
                                            set_ptr = Dereference(Add(wrapper, 16))
                                            // XSHash stores count at offset 8
                                            set_size = Dereference(Add(set_ptr, 8))
                                            response = RESP.Integer(set_size)
                                        } ElseBlock: {
                                            response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                        }
                                    }
                                } ElseBlock: {
                                    response = RESP.Integer(0)  // Non-existent key has 0 members
                                }
                            }
                            command_handled = 1
                        }

                        // SISMEMBER - Test if member is in set
                        is_sismember = StringCompare(command, "SISMEMBER")
                        IfCondition EqualTo(is_sismember, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 3) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'sismember' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                member = ArrayGet(command_array, 2)
                                wrapper = XSHash.XLookup(store, key)

                                IfCondition NotEqual(wrapper, XArrays.XNULL) ThenBlock: {
                                    // Check expiration
                                    is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                    IfCondition is_expired ThenBlock: {
                                        response = RESP.Integer(0)
                                    } ElseBlock: {
                                        type = Dereference(wrapper)
                                        IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: {
                                            set_ptr = Dereference(Add(wrapper, 16))
                                            exists = XSHash.XExists(set_ptr, member)
                                            response = RESP.Integer(exists)
                                        } ElseBlock: {
                                            response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                        }
                                    }
                                } ElseBlock: {
                                    response = RESP.Integer(0)  // Member not in non-existent set
                                }
                            }
                            command_handled = 1
                        }

                        // EXISTS
                        is_exists = StringCompare(command, "EXISTS")
                        IfCondition And(EqualTo(is_exists, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            // With a proper DEL command, XExists is now sufficient.
                            exists = XSHash.XExists(store, key)
                            response = RESP.Integer(exists)
                            command_handled = 1
                        }

                        // INCR
                        is_incr = StringCompare(command, "INCR")
                        IfCondition And(EqualTo(is_incr, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            // --- FIX: Update INCR to work with the type system ---
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    val_str = Dereference(Add(wrapper, 16))
                                    current = Helpers.StringToInt(val_str)
                                    new_val = Add(current, 1)
                                    new_str = Helpers.IntToString(new_val)

                                    // Free the old string and update the wrapper with the new one
                                    Deallocate(val_str, 0)
                                    StoreValue(Add(wrapper, 16), new_str)
                                    response = RESP.Integer(new_val)
                                }
                            } ElseBlock: {
                                // Key doesn't exist, create it with value "1"
                                new_val = 1
                                new_str = Helpers.IntToString(new_val)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), new_str)
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.Integer(new_val)
                            }
                            command_handled = 1
                        }

                        // DECR
                        is_decr = StringCompare(command, "DECR")
                        IfCondition And(EqualTo(is_decr, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            // --- FIX: Update DECR to work with the type system ---
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    val_str = Dereference(Add(wrapper, 16))
                                    current = Helpers.StringToInt(val_str)
                                    new_val = Subtract(current, 1)
                                    new_str = Helpers.IntToString(new_val)

                                    // Free the old string and update the wrapper with the new one
                                    Deallocate(val_str, 0)
                                    StoreValue(Add(wrapper, 16), new_str)
                                    response = RESP.Integer(new_val)
                                }
                            } ElseBlock: {
                                // Key doesn't exist, create it with value "-1"
                                new_val = -1
                                new_str = Helpers.IntToString(new_val)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), new_str)
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.Integer(new_val)
                            }
                            command_handled = 1
                        }

                        // --- STREAM COMMANDS ---

                        // XADD - Add an entry to a stream
                        is_xadd = StringCompare(command, "XADD")
                        IfCondition And(EqualTo(is_xadd, 0), GreaterEqual(array_len, 4)) ThenBlock: {
                            num_args = Subtract(array_len, 3)
                            is_odd = Modulo(num_args, 2)
                            IfCondition NotEqual(is_odd, 0) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for XADD command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                id_str_arg = ArrayGet(command_array, 2)

                                // --- FIX: Make XADD type-aware ---
                                // Get or create the stream (an XArray of entries)
                                stream_ptr = 0
                                wrapper = XSHash.XLookup(store, key)
                                is_found = NotEqual(wrapper, XArrays.XNULL)

                                IfCondition is_found ThenBlock: {
                                    type = Dereference(wrapper)
                                    IfCondition NotEqual(type, DataTypes.TYPE_STREAM) ThenBlock: {
                                        response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                    } ElseBlock: {
                                        stream_ptr = Dereference(Add(wrapper, 16))
                                    }
                                } ElseBlock: {
                                    stream_ptr = XArray.XCreate(16)
                                    new_wrapper = Allocate(24)
                                    StoreValue(new_wrapper, DataTypes.TYPE_STREAM)
                                    StoreValue(Add(new_wrapper, 8), 0)
                                    StoreValue(Add(new_wrapper, 16), stream_ptr)
                                    XSHash.XInsert(store, key, new_wrapper)
                                }

                                // If we have a valid stream_ptr, proceed
                                IfCondition NotEqual(stream_ptr, 0) ThenBlock: {
                                // Handle ID generation if '*' is provided
                                is_auto_id = StringCompare(id_str_arg, "*")
                                generated_id = 0
                                IfCondition EqualTo(is_auto_id, 0) ThenBlock: {
                                    // Generate a new ID. A real implementation uses time.
                                    // We use a simple incrementing counter for the 'ms' part.
                                    last_id_val = StreamState.last_id_ms
                                    new_id_val = Add(last_id_val, 1)
                                    StreamState.last_id_ms = new_id_val

                                    id_ms_str = Helpers.IntToString(new_id_val)
                                    generated_id = StringConcat(id_ms_str, "-0")
                                    Deallocate(id_ms_str, 0)
                                } ElseBlock: {
                                    // Use the provided ID. A real implementation would validate it.
                                    generated_id = Helpers.StringCopy(id_str_arg)
                                }

                                // Create the stream entry: an XArray of [id, f1, v1, f2, v2, ...]
                                num_fields = Add(1, num_args)
                                entry_ptr = XArray.XCreate(num_fields)

                                // Add the ID to the entry. The entry now owns this memory.
                                XArray.XPush(entry_ptr, generated_id)

                                // Add field-value pairs to the entry, copying each one.
                                i = 3
                                WhileLoop LessThan(i, array_len) {
                                    field_or_value = ArrayGet(command_array, i)
                                    copy = Helpers.StringCopy(field_or_value)
                                    XArray.XPush(entry_ptr, copy)
                                    i = Add(i, 1)
                                }

                                // Add the new entry to the stream
                                XArray.XPush(stream_ptr, entry_ptr)

                                // The response is the ID of the newly added entry.
                                response = RESP.BulkString(generated_id)
                                }
                            }
                            command_handled = 1
                        }

                        PrintMessage("[DEBUG] About to compare XREAD\n")
                        // XREAD - Read entries from a stream (simplified)
                        is_xread = StringCompare(command, "XREAD")
                        PrintMessage("[DEBUG] XREAD comparison result: ")
                        PrintNumber(is_xread)
                        PrintMessage("\n")

                        IfCondition EqualTo(is_xread, 0) ThenBlock: {
                            PrintMessage("[DEBUG] Entering XREAD handler\n")
                            IfCondition LessThan(array_len, 4) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'xread' command")
                            } ElseBlock: {
                                PrintMessage("[DEBUG] XREAD: Getting arg 1\n")
                                arg1 = ArrayGet(command_array, 1)
                                PrintMessage("[DEBUG] XREAD: arg1 = ")
                                PrintNumber(arg1)
                                PrintMessage("\n")
                                
                                PrintMessage("[DEBUG] XREAD: About to StringToUpper\n")
                                streams_keyword = StringToUpper(arg1)
                                PrintMessage("[DEBUG] XREAD: StringToUpper completed\n")
                                PrintMessage("[DEBUG] XREAD: streams_keyword = ")
                                PrintNumber(streams_keyword)
                                PrintMessage("\n")

                                PrintMessage("[DEBUG] XREAD: About to StringCompare with STREAMS\n")
                                is_streams = StringCompare(streams_keyword, "STREAMS")
                                PrintMessage("[DEBUG] XREAD: StringCompare result = ")
                                PrintNumber(is_streams)
                                PrintMessage("\n")

                                // Try without deallocating
                                // Deallocate(streams_keyword, 0)

                                IfCondition NotEqual(is_streams, 0) ThenBlock: {
                                    PrintMessage("[DEBUG] XREAD: Missing STREAMS keyword\n")
                                    response = RESP.Error("ERR Syntax error, missing STREAMS keyword")
                                } ElseBlock: {
                                    PrintMessage("[DEBUG] XREAD: STREAMS confirmed, getting key\n")
                                    key = ArrayGet(command_array, 2)
                                    PrintMessage("[DEBUG] XREAD: key = ")
                                    PrintNumber(key)
                                    PrintMessage("\n")
                                    
                                    PrintMessage("[DEBUG] XREAD: Getting start_id\n")
                                    start_id_str = ArrayGet(command_array, 3)
                                    PrintMessage("[DEBUG] XREAD: start_id_str = ")
                                    PrintNumber(start_id_str)
                                    PrintMessage("\n")
                                    
                                    PrintMessage("[DEBUG] XREAD: Looking up stream in store\n")
                                    wrapper = XSHash.XLookup(store, key)
                                    PrintMessage("[DEBUG] XREAD: Lookup completed\n")
                                    is_found = NotEqual(wrapper, XArrays.XNULL)

                                    IfCondition Not(is_found) ThenBlock: {
                                        empty_arr = ArrayCreate(0)
                                        response = RESP.Array(empty_arr)
                                        response_source_array = empty_arr
                                    } ElseBlock: {
                                        type = Dereference(wrapper)
                                        IfCondition NotEqual(type, DataTypes.TYPE_STREAM) ThenBlock: {
                                            response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                        } ElseBlock: {
                                            stream_ptr = Dereference(Add(wrapper, 16))
                                            stream_len = XArray.XSize(stream_ptr)

                                            matching_entries = XArray.XCreate(8)

                                            i = 0
                                            WhileLoop LessThan(i, stream_len) {
                                                entry_ptr = XArray.XGet(stream_ptr, i)
                                                entry_id_ptr = XArray.XGet(entry_ptr, 0)

                                                comparison = Helpers.CompareStreamIDs(entry_id_ptr, start_id_str)
                                                IfCondition EqualTo(comparison, 1) ThenBlock: {
                                                    XArray.XPush(matching_entries, entry_ptr)
                                                }
                                                i = Add(i, 1)
                                            }

                                            num_found = XArray.XSize(matching_entries)
                                            IfCondition EqualTo(num_found, 0) ThenBlock: {
                                                empty_arr = ArrayCreate(0)
                                                response = RESP.Array(empty_arr)
                                                response_source_array = empty_arr
                                            } ElseBlock: {
                                                // --- FIX: Defensively copy stream elements before creating response ---
                                                // This avoids passing pointers from a complex nested structure directly
                                                // to the RESP library, preventing potential memory corruption.
                                                first_entry = XArray.XGet(matching_entries, 0)
                                                num_elements = XArray.XSize(first_entry)
                                                
                                                // Create a native array for RESP.Array and an XArray to track our copies for cleanup.
                                                native_arr = ArrayCreate(num_elements)
                                                copies_to_free = XArray.XCreate(num_elements)
                                                
                                                j = 0
                                                WhileLoop LessThan(j, num_elements) {
                                                    element_ptr = XArray.XGet(first_entry, j)
                                                    element_copy = Helpers.StringCopy(element_ptr)
                                                    ArraySet(native_arr, j, element_copy)
                                                    XArray.XPush(copies_to_free, element_copy)
                                                    j = Add(j, 1)
                                                }
                                                response = RESP.Array(native_arr)
                                                response_source_array = native_arr
                                                response_source_xarray_deep = copies_to_free // Mark copies for cleanup
                                            }
                                            XArray.XDestroy(matching_entries)
                                        }
                                    }
                                }
                            }
                            command_handled = 1
                        }

                        // LPUSH - Add elements to the head of a list
                        is_lpush = StringCompare(command, "LPUSH")
                        IfCondition And(EqualTo(is_lpush, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            list_ptr = 0

                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    list_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                list_ptr = XList.XCreate()
                                wrapper = Allocate(24)
                                StoreValue(wrapper, DataTypes.TYPE_LIST)
                                StoreValue(Add(wrapper, 8), 0)
                                StoreValue(Add(wrapper, 16), list_ptr)
                                XSHash.XInsert(store, key, wrapper)
                            }

                            // If we have a valid list_ptr, proceed
                            IfCondition NotEqual(list_ptr, 0) ThenBlock: {
                                // Push all values to the head of the list
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    value_to_push = ArrayGet(command_array, i)
                                    value_copy = Helpers.StringCopy(value_to_push)
                                    Debug("command.lpush", level=1) {
                                        PrintMessage("[DEBUG] LPUSH Key:")
                                        PrintMessage(key)
                                        PrintMessage("[DEBUG] LPUSH Value:")
                                        PrintMessage(value_to_push)
                                    }
                                    XList.XPrepend(list_ptr, value_copy)
                                    i = Add(i, 1)
                                }

                                new_len = XList.XSize(list_ptr)
                                response = RESP.Integer(new_len)
                            }
                            command_handled = 1
                        }

                        // RPUSH - Add elements to the tail of a list
                        is_rpush = StringCompare(command, "RPUSH")
                        IfCondition And(EqualTo(is_rpush, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            list_ptr = 0

                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    list_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                list_ptr = XList.XCreate()
                                wrapper = Allocate(24)
                                StoreValue(wrapper, DataTypes.TYPE_LIST)
                                StoreValue(Add(wrapper, 8), 0)
                                StoreValue(Add(wrapper, 16), list_ptr)
                                XSHash.XInsert(store, key, wrapper)
                            }

                            // If we have a valid list_ptr, proceed
                            IfCondition NotEqual(list_ptr, 0) ThenBlock: {
                                // Append all values to the tail of the list
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    value_to_push = ArrayGet(command_array, i)
                                    value_copy = Helpers.StringCopy(value_to_push)
                                    Debug("command.rpush", level=1) {
                                        PrintMessage("[DEBUG] RPUSH Key:")
                                        PrintMessage(key)
                                        PrintMessage("[DEBUG] RPUSH Value:")
                                        PrintMessage(value_to_push)
                                    }
                                    XList.XAppend(list_ptr, value_copy)
                                    i = Add(i, 1)
                                }

                                new_len = XList.XSize(list_ptr)
                                response = RESP.Integer(new_len)
                            }
                            command_handled = 1
                        }

                        // LRANGE - Get a range of elements from a list
                        is_lrange = StringCompare(command, "LRANGE")
                        IfCondition EqualTo(is_lrange, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 4) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'lrange' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                wrapper = XSHash.XLookup(store, key)
                                is_found = NotEqual(wrapper, XArrays.XNULL)

                                IfCondition Not(is_found) ThenBlock: {
                                    empty_arr = ArrayCreate(0)
                                    response = RESP.Array(empty_arr)
                                    response_source_array = empty_arr
                                } ElseBlock: {
                                    type = Dereference(wrapper)
                                    IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                        response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                    } ElseBlock: {
                                        list_ptr = Dereference(Add(wrapper, 16))

                                        start_str = ArrayGet(command_array, 2)
                                        stop_str = ArrayGet(command_array, 3)

                                        start_idx = Helpers.StringToInt(start_str)
                                        stop_idx = Helpers.StringToInt(stop_str)
                                        list_size = XList.XSize(list_ptr)

                                        IfCondition LessThan(start_idx, 0) ThenBlock: { start_idx = Add(list_size, start_idx) }
                                        IfCondition LessThan(stop_idx, 0) ThenBlock: { stop_idx = Add(list_size, stop_idx) }
                                        IfCondition LessThan(start_idx, 0) ThenBlock: { start_idx = 0 }
                                        IfCondition GreaterEqual(stop_idx, list_size) ThenBlock: { stop_idx = Subtract(list_size, 1) }

                                        range_len = 0
                                        IfCondition LessEqual(start_idx, stop_idx) ThenBlock: { range_len = Add(Subtract(stop_idx, start_idx), 1) }

                                        results_array = ArrayCreate(range_len)

                                        IfCondition GreaterThan(range_len, 0) ThenBlock: {
                                            current_node = Dereference(list_ptr)
                                            i = 0
                                            WhileLoop LessThan(i, start_idx) {
                                                current_node = Dereference(Add(current_node, 8))
                                                i = Add(i, 1)
                                            }
                                            i = 0
                                            WhileLoop LessThan(i, range_len) {
                                                element = Dereference(current_node)
                                                ArraySet(results_array, i, element)
                                                current_node = Dereference(Add(current_node, 8))
                                                i = Add(i, 1)
                                            }
                                        }
                                        response = RESP.Array(results_array)
                                        response_source_array = results_array
                                    }
                                }
                            }
                            command_handled = 1
                        }

                        // LLEN - Get list length
                        is_llen = StringCompare(command, "LLEN")
                        IfCondition EqualTo(is_llen, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'llen' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                wrapper = XSHash.XLookup(store, key)
                                IfCondition NotEqual(wrapper, XArrays.XNULL) ThenBlock: {
                                    // Check for expiration first
                                    is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                    IfCondition is_expired ThenBlock: {
                                        response = RESP.Integer(0)
                                    } ElseBlock: {
                                        type = Dereference(wrapper)
                                        IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: {
                                            list_ptr = Dereference(Add(wrapper, 16))
                                            list_size = XList.XSize(list_ptr)
                                            response = RESP.Integer(list_size)
                                        } ElseBlock: {
                                            response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                        }
                                    }
                                } ElseBlock: {
                                    response = RESP.Integer(0)  // Non-existent key has length 0
                                }
                            }
                            command_handled = 1
                        }


                        // APPEND
                        is_append = StringCompare(command, "APPEND")
                        IfCondition And(EqualTo(is_append, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            // --- FIX: Update APPEND to work with the type system ---
                            key = ArrayGet(command_array, 1)
                            append_val = ArrayGet(command_array, 2)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    current_str = Dereference(Add(wrapper, 16))
                                    new_str = StringConcat(current_str, append_val)
                                    new_len = StringLength(new_str)

                                    // Free the old string and update the wrapper
                                    Deallocate(current_str, 0)
                                    StoreValue(Add(wrapper, 16), new_str)
                                    response = RESP.Integer(new_len)
                                }
                            } ElseBlock: {
                                // Key doesn't exist, create it with the appended value
                                new_str = Helpers.StringCopy(append_val)
                                new_len = StringLength(new_str)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), new_str)
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.Integer(new_len)
                            }
                            command_handled = 1
                        }

                        // STRLEN
                        is_strlen = StringCompare(command, "STRLEN")
                        IfCondition And(EqualTo(is_strlen, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            // --- FIX: Update STRLEN to work with the type system ---
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    // Redis returns an error for STRLEN on a non-string key
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    val_str = Dereference(Add(wrapper, 16))
                                    len = StringLength(val_str)
                                    response = RESP.Integer(len)
                                }
                            } ElseBlock: {
                                // Key does not exist, return 0
                                response = RESP.Integer(0)
                            }
                            command_handled = 1
                        }

                        // EXPIRE - Set a timeout on a key
                        is_expire = StringCompare(command, "EXPIRE")
                        IfCondition And(EqualTo(is_expire, 0), EqualTo(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            seconds_str = ArrayGet(command_array, 2)
                            seconds = Helpers.StringToInt(seconds_str)

                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition is_found ThenBlock: {
                                now = Helpers.GetSystemTime()
                                expire_time_ms = Add(now, Multiply(seconds, 1000))
                                StoreValue(Add(wrapper, 8), expire_time_ms)
                                response = RESP.Integer(1)
                            } ElseBlock: {
                                response = RESP.Integer(0) // Key does not exist
                            }
                            command_handled = 1
                        }

                        // TTL - Get the time to live for a key
                        is_ttl = StringCompare(command, "TTL")
                        IfCondition And(EqualTo(is_ttl, 0), EqualTo(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)

                            IfCondition Not(is_found) ThenBlock: {
                                response = RESP.Integer(-2) // Key does not exist
                            } ElseBlock: {
                                // --- FIX: Refactor TTL to avoid double GetSystemTime call and potential hang ---
                                expiration_ms = Dereference(Add(wrapper, 8))
                                IfCondition EqualTo(expiration_ms, 0) ThenBlock: {
                                    response = RESP.Integer(-1) // Key exists but has no associated expire
                                } ElseBlock: {
                                    now = Helpers.GetSystemTime()
                                    is_expired = LessThan(expiration_ms, now)

                                    IfCondition is_expired ThenBlock: {
                                        // Key is expired, evict it now and return -2
                                        deleted_wrapper = XSHash.XDelete(store, key)
                                        IfCondition NotEqual(deleted_wrapper, XArrays.XNULL) ThenBlock: {
                                            type = Dereference(deleted_wrapper)
                                            value_ptr = Dereference(Add(deleted_wrapper, 16))
                                            IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                            IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                            IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                            IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                                            Deallocate(deleted_wrapper, 0)
                                        }
                                        response = RESP.Integer(-2)
                                    } ElseBlock: {
                                        remaining_ms = Subtract(expiration_ms, now)
                                        remaining_s = Divide(remaining_ms, 1000)
                                        response = RESP.Integer(remaining_s)
                                    }
                                }
                            }
                            command_handled = 1
                        }

                        // QUIT
                        is_quit = StringCompare(command, "QUIT")
                        IfCondition EqualTo(is_quit, 0) ThenBlock: {
                            response = RESP.SimpleString("OK")
                            client_connected = 0
                            command_handled = 1
                        }

                        // CONFIG command handler
                        is_config = StringCompare(command, "CONFIG")
                        IfCondition EqualTo(is_config, 0) ThenBlock: {
                            subcommand = ArrayGet(command_array, 1)
                            subcommand_upper = StringToUpper(subcommand)

                            // CONFIG GET
                            is_get = StringCompare(subcommand_upper, "GET")
                            IfCondition EqualTo(is_get, 0) ThenBlock: {
                                // redis-benchmark often asks for specific configs
                                temp_array = 0
                                IfCondition GreaterEqual(array_len, 3) ThenBlock: {
                                    param = ArrayGet(command_array, 2)

                                    // Check for save parameter (common benchmark query)
                                    is_save = StringCompare(param, "save")
                                    is_appendonly = StringCompare(param, "appendonly")
                                    is_wildcard = StringCompare(param, "*")

                                    IfCondition EqualTo(is_save, 0) ThenBlock: {
                                        // Return array with ["save", ""] - indicating no save
                                        temp_array = ArrayCreate(2)
                                        ArraySet(temp_array, 0, "save")
                                        ArraySet(temp_array, 1, "")
                                    } ElseBlock: {
                                        IfCondition EqualTo(is_appendonly, 0) ThenBlock: {
                                            // Return array with ["appendonly", "no"]
                                            temp_array = ArrayCreate(2)
                                            ArraySet(temp_array, 0, "appendonly")
                                            ArraySet(temp_array, 1, "no")
                                        } ElseBlock: {
                                            IfCondition EqualTo(is_wildcard, 0) ThenBlock: {
                                                // Handle CONFIG GET * by returning a minimal set of configs
                                                temp_array = ArrayCreate(4)
                                                ArraySet(temp_array, 0, "save")
                                                ArraySet(temp_array, 1, "")
                                                ArraySet(temp_array, 2, "appendonly")
                                                ArraySet(temp_array, 3, "no")
                                            }
                                        }
                                    }
                                }

                                // If no array was created by the specific checks, create an empty one.
                                IfCondition EqualTo(temp_array, 0) ThenBlock: {
                                    temp_array = ArrayCreate(0)
                                }

                                response = RESP.Array(temp_array)
                                response_source_array = temp_array
                            }

                            // CONFIG SET (just return OK for now)
                            is_set = StringCompare(subcommand_upper, "SET")
                            IfCondition EqualTo(is_set, 0) ThenBlock: {
                                response = RESP.SimpleString("OK")
                            }

                            // Clean up the temporary uppercase subcommand string
                            Deallocate(subcommand_upper, 0)
                            command_handled = 1
                        }

                        // INFO command (often requested by clients)
                        is_info = StringCompare(command, "INFO")
                        IfCondition EqualTo(is_info, 0) ThenBlock: {
                            // Return minimal server info
                            info_text = "# Server\r\nredis_version:AILANG-1.0\r\nprocess_id:1\r\ntcp_port:6379\r\n\r\n# Clients\r\nconnected_clients:1\r\n\r\n# Memory\r\nused_memory:1024\r\n\r\n# Stats\r\ntotal_connections_received:1\r\ntotal_commands_processed:1\r\n"
                            response = RESP.BulkString(info_text)
                            command_handled = 1
                        }

                        // MONITOR command (minimal implementation)
                        is_monitor = StringCompare(command, "MONITOR")
                        IfCondition EqualTo(is_monitor, 0) ThenBlock: {
                            // A real monitor implementation is complex and requires concurrency
                            // to watch other clients. This server is single-threaded and can only
                            // handle one client at a time.
                            // This minimal implementation just acknowledges the command
                            // to satisfy redis-cli, then keeps the connection open.
                            ok_response = RESP.SimpleString("OK")
                            ok_len = StringLength(ok_response)
                            SocketWrite(client_socket, ok_response, ok_len)
                            Deallocate(ok_response, 0)

                            // Now, we enter a state where this client does nothing but wait.
                            // We loop here, consuming from the socket until the client disconnects.
                            WhileLoop client_connected {
                                bytes_read = SocketRead(client_socket, buffer, 4096)
                                IfCondition LessEqual(bytes_read, 0) ThenBlock: { client_connected = 0 }
                            }
                            response = -1 // Special flag to skip the normal response logic below
                            command_handled = 1
                        }

                        // COMMAND command (returns command info, needed by some clients)
                        is_command = StringCompare(command, "COMMAND")
                        IfCondition EqualTo(is_command, 0) ThenBlock: {
                            // Return empty array - we don't provide detailed command info
                            empty_array = ArrayCreate(0)
                            response = RESP.Array(empty_array)
                            response_source_array = empty_array
                            command_handled = 1
                        }

                        // SELECT command (select database - we only have db 0)
                        is_select = StringCompare(command, "SELECT")
                        IfCondition EqualTo(is_select, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'select' command")
                            } ElseBlock: {
                                db_num_str = ArrayGet(command_array, 1)
                                is_zero = StringCompare(db_num_str, "0")
                                IfCondition EqualTo(is_zero, 0) ThenBlock: {
                                    response = RESP.SimpleString("OK")
                                } ElseBlock: {
                                    response = RESP.Error("ERR DB index out of range")
                                }
                            }
                            command_handled = 1
                        }

                        // Fixed FLUSHDB implementation that avoids segfault
                        // The issue: XSHash.XKeys might be returning invalid data or the cleanup is corrupting memory

                        // FLUSHDB command (clear current database)
                        is_flushdb = StringCompare(command, "FLUSHDB")
                        IfCondition EqualTo(is_flushdb, 0) ThenBlock: {
                            Debug("command.flushdb", level=1) {
                                PrintMessage("[DEBUG] FLUSHDB: Starting safe deep clean of data store...")
                            }

                            // --- CRITICAL FIX: Validate store pointer first ---
                            IfCondition EqualTo(store, 0) ThenBlock: {
                                PrintMessage("[ERROR] FLUSHDB: Store is NULL!")
                                response = RESP.Error("ERR internal error - store not initialized")
                                command_handled = 1
                            } ElseBlock: {
                                // Get the current state of the hash table
                                key_count = Dereference(Add(store, 8))
                                
                                Debug("command.flushdb", level=2) {
                                    PrintMessage("[DEBUG] FLUSHDB: Key count = ")
                                    PrintNumber(key_count)
                                }
                                
                                IfCondition GreaterThan(key_count, 0) ThenBlock: {
                                    // --- ALTERNATIVE APPROACH: Clear buckets directly without XKeys ---
                                    // This avoids the complexity of XKeys and potential memory issues
                                    
                                    buckets = Dereference(Add(store, 16))
                                    bucket_count = Dereference(store)
                                    
                                    Debug("command.flushdb", level=2) {
                                        PrintMessage("[DEBUG] FLUSHDB: Clearing buckets, count = ")
                                        PrintNumber(bucket_count)
                                    }
                                    
                                    // Iterate through each bucket
                                    bucket_idx = 0
                                    WhileLoop LessThan(bucket_idx, bucket_count) {
                                        current = ArrayGet(buckets, bucket_idx)
                                        
                                        // Process all nodes in this bucket
                                        WhileLoop NotEqual(current, 0) {
                                            // Save next before we free current
                                            next_node = Dereference(Add(current, 16))
                                            
                                            // Get the key and value wrapper
                                            stored_key = Dereference(current)
                                            value_wrapper_ptr = Dereference(Add(current, 8))
                                            
                                            Debug("command.flushdb", level=3) {
                                                PrintMessage("[DEBUG] FLUSHDB: Freeing key: ")
                                                PrintString(stored_key)
                                            }
                                            
                                            // Free the value based on its type
                                            IfCondition NotEqual(value_wrapper_ptr, 0) ThenBlock: {
                                                type = Dereference(value_wrapper_ptr)
                                                value_ptr = Dereference(Add(value_wrapper_ptr, 16))
                                                
                                                IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                                    IfCondition NotEqual(value_ptr, 0) ThenBlock: {
                                                        Deallocate(value_ptr, 0)
                                                    }
                                                }
                                                IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: {
                                                    IfCondition NotEqual(value_ptr, 0) ThenBlock: {
                                                        XList.XDestroyDeep(value_ptr)
                                                    }
                                                }
                                                IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: {
                                                    IfCondition NotEqual(value_ptr, 0) ThenBlock: {
                                                        XSHash.XDestroy(value_ptr)
                                                    }
                                                }
                                                IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: {
                                                    IfCondition NotEqual(value_ptr, 0) ThenBlock: {
                                                        XStream.XDestroy(value_ptr)
                                                    }
                                                }
                                                
                                                // Free the wrapper
                                                Deallocate(value_wrapper_ptr, 0)
                                            }
                                            
                                            // Free the key string
                                            IfCondition NotEqual(stored_key, 0) ThenBlock: {
                                                Deallocate(stored_key, 0)
                                            }
                                            
                                            // Free the node itself
                                            Deallocate(current, 0)
                                            
                                            // Move to next node
                                            current = next_node
                                        }
                                        
                                        // Clear the bucket head
                                        ArraySet(buckets, bucket_idx, 0)
                                        
                                        bucket_idx = Add(bucket_idx, 1)
                                    }
                                    
                                    // Reset the item count to 0
                                    StoreValue(Add(store, 8), 0)
                                    
                                    Debug("command.flushdb", level=1) {
                                        PrintMessage("[DEBUG] FLUSHDB: Successfully cleared all entries")
                                    }
                                } ElseBlock: {
                                    Debug("command.flushdb", level=1) {
                                        PrintMessage("[DEBUG] FLUSHDB: Store already empty, nothing to clear")
                                    }
                                }
                                
                                response = RESP.SimpleString("OK")
                                command_handled = 1
                            }
                        }

                        // DBSIZE command (number of keys)
                        is_dbsize = StringCompare(command, "DBSIZE")
                        IfCondition EqualTo(is_dbsize, 0) ThenBlock: {
                            // The XSHash library tracks the item count at offset 8 of the hash table struct.
                            key_count = Dereference(Add(store, 8))
                            response = RESP.Integer(key_count)
                            command_handled = 1
                        }

                        // TYPE - Get the type of a key
                        is_type = StringCompare(command, "TYPE")
                        IfCondition EqualTo(is_type, 0) ThenBlock: {
                            IfCondition NotEqual(array_len, 2) ThenBlock: {
                                response = RESP.Error("ERR wrong number of arguments for 'type' command")
                            } ElseBlock: {
                                key = ArrayGet(command_array, 1)
                                wrapper = XSHash.XLookup(store, key)

                                IfCondition NotEqual(wrapper, XArrays.XNULL) ThenBlock: {
                                    // Check expiration
                                    is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                    IfCondition is_expired ThenBlock: {
                                        response = RESP.SimpleString("none")
                                    } ElseBlock: {
                                        type = Dereference(wrapper)
                                        IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                            response = RESP.SimpleString("string")
                                        }
                                        IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: {
                                            response = RESP.SimpleString("list")
                                        }
                                        IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: {
                                            response = RESP.SimpleString("set")
                                        }
                                        IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: {
                                            response = RESP.SimpleString("stream")
                                        }
                                    }
                                } ElseBlock: {
                                    response = RESP.SimpleString("none")
                                }
                            }
                            command_handled = 1
                        }

                        // Send response
                        // Use NotEqual(response, -1) to check against our special flag from MONITOR
                        IfCondition NotEqual(response, -1) ThenBlock: {
                            IfCondition command_handled ThenBlock: {
                                // Command was handled. If it produced a response, send it.
                                IfCondition NotEqual(response, 0) ThenBlock: {
                                    Debug("client.write", level=1) {
                                        PrintMessage("[DEBUG] Sending response to client:")
                                        PrintMessage(response)
                                    }
                                    response_len = StringLength(response)
                                    SocketWrite(client_socket, response, response_len)
                                    Deallocate(response, 0)
                                }
                            } ElseBlock: {
                                // Command was not handled by any block, so it's unknown.
                                error_msg = RESP.Error("unknown command")
                                error_len = StringLength(error_msg)
                                SocketWrite(client_socket, error_msg, error_len)
                                Deallocate(error_msg, 0)
                            }
                        }
                        
                        // --- FIX: Proper cleanup for response data structures ---
                        // This block must come after the response is sent, but before the command array is cleaned up.
                        IfCondition NotEqual(response_source_array, 0) ThenBlock: {
                            ArrayDestroy(response_source_array)
                        }
                        IfCondition NotEqual(response_source_xarray_deep, 0) ThenBlock: {
                            // This is for XArrays that own their string elements, like from XSHash.XKeys
                            num_elements = XArray.XSize(response_source_xarray_deep)
                            i = 0
                            WhileLoop LessThan(i, num_elements) {
                                element_ptr = XArray.XGet(response_source_xarray_deep, i)
                                Deallocate(element_ptr, 0)
                                i = Add(i, 1)
                            }
                            XArray.XDestroy(response_source_xarray_deep)
                        }

                        // Clean up the uppercase command string created by StringToUpper
                        Deallocate(command, 0)

                        // Clean up array
                        i = 0
                        WhileLoop LessThan(i, array_len) {
                            element = ArrayGet(command_array, i)
                            IfCondition NotEqual(element, 0) ThenBlock: {
                                Deallocate(element, 0)
                            }
                            i = Add(i, 1)
                        }
                    }
                    
                    ArrayDestroy(command_array)
                } ElseBlock: {
                    // Parser returned null, but consumed bytes. Indicates a protocol error.
                    // Disconnect the client to be safe.
                    client_connected = 0
                }
            } // --- End of inner processing loop ---

            // If the client is still connected, manage the buffer for the next read
            IfCondition client_connected ThenBlock: {
                // If we've processed the whole buffer, reset it
                IfCondition EqualTo(buffer_offset, buffer_data_len) ThenBlock: {
                    buffer_offset = 0
                    buffer_data_len = 0
                } ElseBlock: {
                    // If there's a partial command left, move it to the start of the buffer
                    remaining_data = Subtract(buffer_data_len, buffer_offset)
                    MemoryCopy(buffer, Add(buffer, buffer_offset), remaining_data)
                    buffer_offset = 0
                    buffer_data_len = remaining_data
                }

                // Read more data from the socket, appending to what's left in the buffer
                read_target_ptr = Add(buffer, buffer_data_len)
                read_max_len = Subtract(4096, buffer_data_len)
                bytes_read = SocketRead(client_socket, read_target_ptr, read_max_len)
                IfCondition GreaterThan(bytes_read, 0) ThenBlock: {
                    buffer_data_len = Add(buffer_data_len, bytes_read)
                    Debug("buffer.read", level=1) {
                        PrintMessage("[DEBUG] Read bytes from socket: ")
                        PrintNumber(bytes_read)
                        PrintMessage("\n[DEBUG] Total buffer length: ")
                        PrintNumber(buffer_data_len)
                        PrintMessage("\n[DEBUG] Buffer offset: ")
                        PrintNumber(buffer_offset)
                        
                        // Print first few bytes to see what we received
                        PrintMessage("\n[DEBUG] First bytes: ")
                        i = 0
                        WhileLoop And(LessThan(i, 20), LessThan(i, buffer_data_len)) {
                            PrintNumber(GetByte(buffer, i))
                            PrintMessage(" ")
                            i = Add(i, 1)
                        }
                        PrintMessage("\n")
                    }
                } ElseBlock: {
                    client_connected = 0
                }
            } ElseBlock: {
                client_connected = 0
                Debug("client.disconnect", level=1) { PrintMessage("[DEBUG] Client disconnected (read 0 bytes).") }
            }
        }
        
        SocketClose(client_socket)
        Debug("client.close", level=1) {
            PrintMessage("[DEBUG] Client socket closed.")
        }
        Deallocate(buffer, 0)
    }
}

SubRoutine.Main {
    
    PrintMessage("[MAIN] Starting Main subroutine\n")
    
    // Create and assign the hash table
    local_store = XSHash.XCreate(1024)
    RedisData.store_ptr = local_store
    
    PrintMessage("[MAIN] Store initialized: ")
    PrintNumber(RedisData.store_ptr)
    PrintMessage("\n")
    
    // After creating store, verify we can read it back
    temp_verify = RedisData.store_ptr
    PrintMessage("[MAIN] Verification read: ")
    PrintNumber(temp_verify)
    PrintMessage("\n")
    
    // Verify it was created successfully
    IfCondition EqualTo(RedisData.store_ptr, 0) ThenBlock: {
        PrintMessage("[ERROR] Failed to create Redis data store!")
        Exit(1)
    }
    
    // Create server socket
    server_socket = SocketCreate()
    IfCondition LessEqual(server_socket, 0) ThenBlock: {
        Exit(1)
    }
    
    // Set options and bind
    SocketSetOption(server_socket, 1, 2, 1)
    result = SocketBind(server_socket, 0, 6379)
    IfCondition LessThan(result, 0) ThenBlock: {
        SocketClose(server_socket)
        Exit(1)
    }
    
    // Listen
    result = SocketListen(server_socket, 128)
    IfCondition LessThan(result, 0) ThenBlock: {
        SocketClose(server_socket)
        Exit(1)
    }

    // Announce the port we are listening on for clarity
    PrintMessage("Server listening on port 6379")
    Debug("server.listen", level=1) {
        PrintMessage("[DEBUG] Socket setup complete. Entering main accept loop.")
    }

    // Main server loop
    server_running = 1
    WhileLoop server_running {
        client_socket = SocketAccept(server_socket)

        Debug("server.accept", level=1) {
            PrintMessage("[DEBUG] SocketAccept returned. Socket ID:")
            PrintNumber(client_socket)
        }

        IfCondition GreaterThan(client_socket, 0) ThenBlock: {
            // --- FIX: Revert from broken concurrent model to a stable iterative model ---
            // The previous use of RunTask with a global mailbox created a race condition.
            // This direct call handles one client completely before accepting the next.
            Server.HandleClient(client_socket, RedisData.store_ptr)
        }
    }

    SocketClose(server_socket)
}

RunTask(Main)