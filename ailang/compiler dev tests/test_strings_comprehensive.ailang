// test_strings_comprehensive.ailang
// Comprehensive test of all string operations

PrintMessage("String Operations Comprehensive Test")
PrintMessage("====================================")

// === SECTION 1: BASIC STRING OPERATIONS ===
PrintMessage("[1] Basic String Operations")

// StringLength
len1 = StringLength("Hello")
len2 = StringLength("")
len3 = StringLength("A")
DebugAssert(EqualTo(len1, 5), "Length of 'Hello'")
DebugAssert(EqualTo(len2, 0), "Length of empty string")
DebugAssert(EqualTo(len3, 1), "Length of single char")

// StringConcat
concat1 = StringConcat("Hello", "World")
concat2 = StringConcat("", "Test")
concat3 = StringConcat("Test", "")
concat4 = StringConcat("A", "B")
DebugAssert(EqualTo(StringLength(concat1), 10), "Concat 'Hello'+'World'")
DebugAssert(EqualTo(StringLength(concat2), 4), "Concat empty+string")
DebugAssert(EqualTo(StringLength(concat3), 4), "Concat string+empty")
DebugAssert(EqualTo(StringLength(concat4), 2), "Concat single chars")

PrintMessage("  Basic ops: PASSED")

// === SECTION 2: STRING COMPARISON ===
PrintMessage("[2] String Comparison")

// StringEquals
eq1 = StringEquals("test", "test")
eq2 = StringEquals("test", "Test")
eq3 = StringEquals("", "")
eq4 = StringEquals("abc", "abcd")
DebugAssert(EqualTo(eq1, 1), "Equal strings")
DebugAssert(EqualTo(eq2, 0), "Case sensitive")
DebugAssert(EqualTo(eq3, 1), "Empty strings equal")
DebugAssert(EqualTo(eq4, 0), "Different lengths")

// StringCompare (returns 0 if equal, non-zero if different)
cmp1 = StringCompare("abc", "abc")
cmp2 = StringCompare("abc", "def")
DebugAssert(EqualTo(cmp1, 0), "Compare equal strings")
DebugAssert(NotEqual(cmp2, 0), "Compare different strings")

PrintMessage("  Comparison: PASSED")

// === SECTION 3: NUMBER CONVERSIONS ===
PrintMessage("[3] Number Conversions")

// NumberToString
str1 = NumberToString(0)
str2 = NumberToString(123)
str3 = NumberToString(-456)
str4 = NumberToString(2147483647)  // Max int32

check1 = StringEquals(str1, "0")
check2 = StringEquals(str2, "123")
check3 = StringEquals(str3, "-456")
DebugAssert(EqualTo(check1, 1), "NumberToString(0)")
DebugAssert(EqualTo(check2, 1), "NumberToString(123)")
DebugAssert(EqualTo(check3, 1), "NumberToString(-456)")

// StringToNumber
num1 = StringToNumber("0")
num2 = StringToNumber("789")
num3 = StringToNumber("-321")
DebugAssert(EqualTo(num1, 0), "StringToNumber('0')")
DebugAssert(EqualTo(num2, 789), "StringToNumber('789')")
DebugAssert(EqualTo(num3, -321), "StringToNumber('-321')")

PrintMessage("  Conversions: PASSED")

// === SECTION 4: COMPLEX STRING BUILDING ===
PrintMessage("[4] Complex String Building")

// Build formatted string
name = "AILANG"
version = NumberToString(2025)
msg = StringConcat("Welcome to ", name)
msg = StringConcat(msg, " version ")
msg = StringConcat(msg, version)
expected = StringEquals(msg, "Welcome to AILANG version 2025")
DebugAssert(EqualTo(expected, 1), "Complex string building")

// Chain concatenations
chain = StringConcat(StringConcat("A", "B"), StringConcat("C", "D"))
chain_check = StringEquals(chain, "ABCD")
DebugAssert(EqualTo(chain_check, 1), "Chained concatenations")

PrintMessage("  Complex building: PASSED")

// === SECTION 5: EDGE CASES ===
PrintMessage("[5] Edge Cases")

// Very long string
long_str = "START"
i = 0
WhileLoop LessThan(i, 100) {
    long_str = StringConcat(long_str, "X")
    i = Add(i, 1)
}
long_len = StringLength(long_str)
DebugAssert(EqualTo(long_len, 105), "Long string (START + 100 X's)")

// Special characters (if supported)
special = "Hello\nWorld"  // Newline
tab_str = "A\tB"         // Tab
quote_str = "He said \"Hi\""  // Quotes

// Unicode (basic ASCII subset)
ascii = "ABC123!@#"
ascii_len = StringLength(ascii)
DebugAssert(EqualTo(ascii_len, 9), "ASCII string length")

PrintMessage("  Edge cases: PASSED")

// === SECTION 6: PERFORMANCE PATTERNS ===
PrintMessage("[6] Performance Patterns")

// String accumulator pattern
accum = ""
j = 0
WhileLoop LessThan(j, 50) {
    accum = StringConcat(accum, ".")
    j = Add(j, 1)
}
accum_len = StringLength(accum)
DebugAssert(EqualTo(accum_len, 50), "Accumulator pattern")

// String pool version (if available)
pool = StringPool.Init(4096)
pooled = ""
k = 0
WhileLoop LessThan(k, 50) {
    pooled = StringConcatPooled(pooled, ".")
    k = Add(k, 1)
}
pooled_len = StringLength(pooled)
DebugAssert(EqualTo(pooled_len, 50), "Pooled accumulator")

PrintMessage("  Performance patterns: PASSED")

// === SECTION 7: FUNCTIONS WITH STRINGS ===
PrintMessage("[7] Functions with Strings")

Function.String.Reverse {
    Input: str: String
    Output: String
    Body: {
        // Simple implementation - just return input for now
        // Real reverse would need StringSubstring or char access
        ReturnValue(str)
    }
}

Function.String.MakeGreeting {
    Input: name: String
    Output: String
    Body: {
        greeting = StringConcat("Hello, ", name)
        greeting = StringConcat(greeting, "!")
        ReturnValue(greeting)
    }
}

greeting = String.MakeGreeting("World")
greet_check = StringEquals(greeting, "Hello, World!")
DebugAssert(EqualTo(greet_check, 1), "String function")

PrintMessage("  String functions: PASSED")

PrintMessage("====================================")
PrintMessage("All string tests PASSED!")