// test_trig_trace.ailang
// Test with debug tracing

// Import the library
LibraryImport.FixedPointTrig {
    // Library will be loaded
}

PrintMessage("=== TRIG TRACE TEST ===")
PrintMessage("")

// Test the simplest possible function first
PrintMessage("Test 1: Direct multiply")
result1 = Multiply(3, 10000)
PrintMessage("  3 * 10000 = ")
PrintNumber(result1)
PrintMessage("  Expected: 30000")

// Test if we can call ANY function
PrintMessage("")
PrintMessage("Test 2: Built-in Add")
result2 = Add(5000, 2000)
PrintMessage("  5000 + 2000 = ")
PrintNumber(result2)
PrintMessage("  Expected: 7000")

// Now test our simplest library function
PrintMessage("")
PrintMessage("Test 3: FixedPoint.FromInt")

// Add debug trace
DebugTrace.Entry("Calling FromInt", 3)

// Try inline implementation first
scale = FixedPointTrig.scale
PrintMessage("  Scale is: ")
PrintNumber(scale)

manual = Multiply(3, scale)
PrintMessage("  Manual 3 * scale = ")
PrintNumber(manual)

// Now try the function
result3 = FixedPoint.FromInt(3)
PrintMessage("  FromInt(3) = ")
PrintNumber(result3)
PrintMessage("  Expected: 30000")

DebugTrace.Exit("FromInt returned", result3)

// Test even simpler - just return a constant
PrintMessage("")
PrintMessage("Test 4: Direct table access vs function")

// Direct access
direct = SinTable.sin_30
PrintMessage("  Direct sin_30: ")
PrintNumber(direct)

// Via function that should just return the same value
// Let's make a test function inline
Function.Test.GetSin30 {
    Body: {
        PrintMessage("    Inside GetSin30")
        val = SinTable.sin_30
        PrintMessage("    Got value: ")
        PrintNumber(val)
        ReturnValue(val)
    }
}

via_func = Test.GetSin30()
PrintMessage("  Via function: ")
PrintNumber(via_func)

PrintMessage("")
PrintMessage("=== END TRACE TEST ===")