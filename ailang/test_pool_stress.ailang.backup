// test_pool_stress.ailang
// Version 1.0 - Aggressive stress test for pool system
// Tests edge cases, limits, and unusual patterns

PrintMessage("=== POOL STRESS TEST v1.0 ===")
PrintMessage("")

// Test 1: Many pools with many members
FixedPool.Pool1 {
    "a": Initialize=100
    "b": Initialize=101
    "c": Initialize=102
    "d": Initialize=103
    "e": Initialize=104
}

FixedPool.Pool2 {
    "x": Initialize=200
    "y": Initialize=201
    "z": Initialize=202
}

FixedPool.Pool3 {
    "m": Initialize=300
    "n": Initialize=301
}

FixedPool.Pool4 {
    "p": Initialize=400
    "q": Initialize=401
    "r": Initialize=402
    "s": Initialize=403
}

PrintMessage("[Test 1: Multiple pools initialized]")
PrintMessage("Verifying all values...")

// Verify all pools
total = 0
total = Add(total, Pool1.a)
total = Add(total, Pool1.b)
total = Add(total, Pool1.c)
total = Add(total, Pool1.d)
total = Add(total, Pool1.e)
total = Add(total, Pool2.x)
total = Add(total, Pool2.y)
total = Add(total, Pool2.z)
total = Add(total, Pool3.m)
total = Add(total, Pool3.n)
total = Add(total, Pool4.p)
total = Add(total, Pool4.q)
total = Add(total, Pool4.r)
total = Add(total, Pool4.s)

PrintMessage("Sum of all pool values: ")
PrintNumber(total)
PrintMessage("Expected: 3121")
PrintMessage("")

// Test 2: Deep nested function calls with pool access
Function.Test.Level5 {
    Body: {
        val = Add(Pool4.s, 1000)
        ReturnValue(val)
    }
}

Function.Test.Level4 {
    Body: {
        val = Add(Pool3.n, Test.Level5())
        ReturnValue(val)
    }
}

Function.Test.Level3 {
    Body: {
        val = Add(Pool2.z, Test.Level4())
        ReturnValue(val)
    }
}

Function.Test.Level2 {
    Body: {
        val = Add(Pool1.e, Test.Level3())
        ReturnValue(val)
    }
}

Function.Test.Level1 {
    Body: {
        val = Add(Pool1.a, Test.Level2())
        ReturnValue(val)
    }
}

PrintMessage("[Test 2: Deep nested functions]")
nested_result = Test.Level1()
PrintMessage("5-level nested result: ")
PrintNumber(nested_result)
PrintMessage("Expected: 2109")
PrintMessage("")

// Test 3: Rapid pool switching in loop
PrintMessage("[Test 3: Rapid pool access in loop]")
i = 0
loop_sum = 0
WhileLoop (i < 100) {
    // Access different pools based on modulo
    mod4 = Modulo(i, 4)
    
    IfCondition (mod4 == 0) ThenBlock {
        loop_sum = Add(loop_sum, Pool1.a)
    }
    IfCondition (mod4 == 1) ThenBlock {
        loop_sum = Add(loop_sum, Pool2.x)
    }
    IfCondition (mod4 == 2) ThenBlock {
        loop_sum = Add(loop_sum, Pool3.m)
    }
    IfCondition (mod4 == 3) ThenBlock {
        loop_sum = Add(loop_sum, Pool4.p)
    }
    
    i = Add(i, 1)
}

PrintMessage("Loop sum (100 iterations): ")
PrintNumber(loop_sum)
PrintMessage("Expected: 25000")
PrintMessage("")

// Test 4: Pool values in recursive function
Function.Test.Recursive {
    Input: n:
    Body: {
        IfCondition (n <= 0) ThenBlock {
            ReturnValue(Pool1.a)
        }
        
        // Access different pool members
        val = 0
        mod3 = Modulo(n, 3)
        IfCondition (mod3 == 0) ThenBlock {
            val = Pool2.y
        }
        IfCondition (mod3 == 1) ThenBlock {
            val = Pool3.m
        }
        IfCondition (mod3 == 2) ThenBlock {
            val = Pool4.q
        }
        
        next = Subtract(n, 1)
        rec_val = Test.Recursive(next)
        result = Add(val, rec_val)
        ReturnValue(result)
    }
}

PrintMessage("[Test 4: Recursive with pools]")
rec_result = Test.Recursive(10)
PrintMessage("Recursive(10) result: ")
PrintNumber(rec_result)
PrintMessage("")

// Test 5: Large pool with many members
FixedPool.BigPool {
    "v1": Initialize=1001
    "v2": Initialize=1002
    "v3": Initialize=1003
    "v4": Initialize=1004
    "v5": Initialize=1005
    "v6": Initialize=1006
    "v7": Initialize=1007
    "v8": Initialize=1008
    "v9": Initialize=1009
    "v10": Initialize=1010
    "v11": Initialize=1011
    "v12": Initialize=1012
    "v13": Initialize=1013
    "v14": Initialize=1014
    "v15": Initialize=1015
    "v16": Initialize=1016
    "v17": Initialize=1017
    "v18": Initialize=1018
    "v19": Initialize=1019
    "v20": Initialize=1020
}

PrintMessage("[Test 5: Large pool access]")
big_sum = 0
big_sum = Add(big_sum, BigPool.v1)
big_sum = Add(big_sum, BigPool.v5)
big_sum = Add(big_sum, BigPool.v10)
big_sum = Add(big_sum, BigPool.v15)
big_sum = Add(big_sum, BigPool.v20)
PrintMessage("Sum of v1,v5,v10,v15,v20: ")
PrintNumber(big_sum)
PrintMessage("Expected: 5055")
PrintMessage("")

// Test 6: Cross-pool arithmetic storm
Function.Test.ArithmeticStorm {
    Body: {
        // Lots of cross-pool operations
        a = Add(Pool1.a, Pool2.x)
        b = Multiply(Pool3.m, 2)
        c = Subtract(Pool4.p, Pool1.e)
        d = Add(a, b)
        e = Add(c, d)
        
        // More complex expressions
        f = Add(Add(Pool1.b, Pool2.y), Add(Pool3.n, Pool4.q))
        g = Multiply(Add(Pool1.c, Pool2.z), 3)
        h = Add(f, g)
        
        total = Add(e, h)
        ReturnValue(total)
    }
}

PrintMessage("[Test 6: Arithmetic storm]")
storm_result = Test.ArithmeticStorm()
PrintMessage("Complex calculation result: ")
PrintNumber(storm_result)
PrintMessage("")

// Test 7: Pool access with complex control flow
Function.Test.ComplexFlow {
    Input: x:
    Body: {
        result = 0
        
        IfCondition (x > 50) ThenBlock {
            IfCondition (x > 75) ThenBlock {
                result = Add(Pool4.s, Pool3.n)
            } ElseBlock {
                result = Add(Pool2.z, Pool1.e)
            }
        } ElseBlock {
            IfCondition (x > 25) ThenBlock {
                result = Subtract(Pool3.m, Pool1.a)
            } ElseBlock {
                result = Multiply(Pool2.x, 2)
            }
        }
        
        // Nested loops with pool access
        i = 0
        WhileLoop (i < 3) {
            j = 0
            WhileLoop (j < 2) {
                result = Add(result, Pool1.a)
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

PrintMessage("[Test 7: Complex control flow]")
flow1 = Test.ComplexFlow(80)
PrintMessage("ComplexFlow(80): ")
PrintNumber(flow1)
flow2 = Test.ComplexFlow(30)
PrintMessage("ComplexFlow(30): ")
PrintNumber(flow2)
flow3 = Test.ComplexFlow(10)
PrintMessage("ComplexFlow(10): ")
PrintNumber(flow3)
PrintMessage("")

// Test 8: Maximum pool index stress
FixedPool.MaxTest {
    "end1": Initialize=9001
    "end2": Initialize=9002
    "end3": Initialize=9003
}

PrintMessage("[Test 8: High index pools]")
PrintMessage("MaxTest values: ")
PrintNumber(MaxTest.end1)
PrintNumber(MaxTest.end2)
PrintNumber(MaxTest.end3)
PrintMessage("")

// Test 9: Pool values as array indices
PrintMessage("[Test 9: Pools as array indices]")
arr = ArrayCreate(500)
ArraySet(arr, 100, 7777)
ArraySet(arr, 200, 8888)
ArraySet(arr, 300, 9999)

// Use pool values as indices
val1 = ArrayGet(arr, Pool1.a)  // Index 100
val2 = ArrayGet(arr, Pool2.x)  // Index 200
val3 = ArrayGet(arr, Pool3.m)  // Index 300

PrintMessage("arr[Pool1.a]: ")
PrintNumber(val1)
PrintMessage("arr[Pool2.x]: ")
PrintNumber(val2)
PrintMessage("arr[Pool3.m]: ")
PrintNumber(val3)
PrintMessage("")

// Test 10: Stress with all pools in single expression
PrintMessage("[Test 10: All pools in one expression]")
mega = Add(
    Add(Add(Pool1.a, Pool1.b), Add(Pool1.c, Pool1.d)),
    Add(Add(Pool2.x, Pool2.y), Add(Pool3.m, Pool4.p))
)
PrintMessage("Mega expression result: ")
PrintNumber(mega)
PrintMessage("Expected: 1206")

PrintMessage("")
PrintMessage("=== STRESS TEST COMPLETE ===")
PrintMessage("✓ Multiple pools working")
PrintMessage("✓ Deep nesting working")
PrintMessage("✓ Loops with pools working")
PrintMessage("✓ Recursive functions working")
PrintMessage("✓ Large pools working")
PrintMessage("✓ Complex expressions working")
PrintMessage("✓ High pool indices working")
PrintMessage("✓ Pools as array indices working")
PrintMessage("")
PrintMessage("Pool system is robust!")
PrintMessage("=== END STRESS TEST v1.0 ===")