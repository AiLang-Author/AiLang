// redis_lib_debug.ailang - Redis Library Module with Debug
// High-level abstractions with debug instrumentation

Library.Redis {
    
    // Initialize Redis data structures
    Function.Init {
        Input: size: Integer
        Body: {
            Debug("Redis.Init", level=1) {
                PrintMessage("Initializing Redis store with size: ")
                PrintNumber(size)
            }
            
            DebugAssert(GreaterThan(size, 0), "Redis.Init size must be positive")
            DebugAssert(LessThan(size, 1000000), "Redis.Init size too large")
            
            // Allocate hash table for key-value storage
            store = HashCreate(size)
            
            Debug("Redis.Init.Created", level=2) {
                PrintMessage("  Store created at address: ")
                PrintNumber(store)
            }
            
            DebugAssert(NotEqual(store, 0), "Failed to create Redis hash store")
            
            ReturnValue(store)
        }
    }
    
    // Redis SET command implementation
    Function.Set {
        Input: store: Address
        Input: key: Text
        Input: value: Text
        Body: {
            Debug("Redis.Set", level=2) {
                PrintMessage("SET operation:")
                PrintMessage("  Store: ")
                PrintNumber(store)
                PrintMessage("  Key: ")
                PrintMessage(key)
                PrintMessage("  Value: ")
                PrintMessage(value)
            }
            
            DebugAssert(NotEqual(store, 0), "Redis.Set invalid store address")
            DebugAssert(GreaterThan(StringLength(key), 0), "Redis.Set empty key")
            
            // Store key-value pair using hash table primitive
            HashSet(store, key, value)
            
            Debug("Redis.Set.Stored", level=3) {
                PrintMessage("  Value stored successfully")
            }
            
            // Verify storage (debug only)
            Debug("Redis.Set.Verify", level=3) {
                check_value = HashGet(store, key)
                PrintMessage("  Verification - retrieved: ")
                PrintNumber(check_value)
            }
            
            // Build RESP response for OK
            response = RESP.BuildSimpleString("OK")
            
            Debug("Redis.Set.Response", level=3) {
                PrintMessage("  Response built")
            }
            
            ReturnValue(response)
        }
    }
    
    // Redis GET command implementation
    Function.Get {
        Input: store: Address
        Input: key: Text
        Body: {
            Debug("Redis.Get", level=2) {
                PrintMessage("GET operation:")
                PrintMessage("  Store: ")
                PrintNumber(store)
                PrintMessage("  Key: ")
                PrintMessage(key)
            }
            
            DebugAssert(NotEqual(store, 0), "Redis.Get invalid store address")
            DebugAssert(GreaterThan(StringLength(key), 0), "Redis.Get empty key")
            
            // Retrieve value from hash table
            value = HashGet(store, key)
            
            Debug("Redis.Get.Retrieved", level=3) {
                PrintMessage("  Value address: ")
                PrintNumber(value)
            }
            
            // HashGet returns 0 (Null) if key doesn't exist
            IfCondition EqualTo(value, 0) ThenBlock {
                Debug("Redis.Get.NotFound", level=2) {
                    PrintMessage("  Key not found, returning null bulk string")
                }
                // Null bulk string for non-existent key
                response = RESP.BuildNullBulkString()
            } ElseBlock {
                Debug("Redis.Get.Found", level=2) {
                    PrintMessage("  Key found, building bulk string response")
                }
                // Format as bulk string
                response = RESP.BuildBulkString(value)
            }
            
            Debug("Redis.Get.Response", level=3) {
                PrintMessage("  Response prepared")
            }
            
            ReturnValue(response)
        }
    }
    
    // Parse RESP command
    Function.ParseCommand {
        Input: buffer: Address
        Body: {
            Debug("Redis.ParseCommand", level=2) {
                PrintMessage("Parsing RESP command from buffer: ")
                PrintNumber(buffer)
            }
            
            DebugAssert(NotEqual(buffer, 0), "Redis.ParseCommand null buffer")
            
            // Check for array marker '*'
            first_byte = Dereference(buffer)
            
            Debug("Redis.ParseCommand.FirstByte", level=3) {
                PrintMessage("  First byte: ")
                PrintNumber(first_byte)
                PrintMessage(" (expected 42 for '*')")
            }
            
            is_array = EqualTo(first_byte, 42)  // 42 = '*'
            
            IfCondition is_array ThenBlock {
                Debug("Redis.ParseCommand.Array", level=3) {
                    PrintMessage("  Valid RESP array detected")
                }
                
                // Find the first '$' marker
                offset = 0
                i = 0
                found_dollar = 0
                
                WhileLoop And(LessThan(i, 100), EqualTo(found_dollar, 0)) {
                    char = Dereference(Add(buffer, i))
                    
                    Debug("Redis.ParseCommand.Scan", level=4) {
                        PrintMessage("    Scanning byte ")
                        PrintNumber(i)
                        PrintMessage(": ")
                        PrintNumber(char)
                    }
                    
                    IfCondition EqualTo(char, 36) ThenBlock { // 36 = '$'
                        offset = i
                        found_dollar = 1
                        
                        Debug("Redis.ParseCommand.FoundDollar", level=3) {
                            PrintMessage("  Found '$' at offset: ")
                            PrintNumber(offset)
                        }
                    }
                    IfCondition EqualTo(char, 0) ThenBlock {
                        Debug("Redis.ParseCommand.EndOfBuffer", level=2) {
                            PrintMessage("  Reached end of buffer without finding '$'")
                        }
                        found_dollar = 2  // Signal end
                    }
                    i = Add(i, 1)
                }
                
                IfCondition EqualTo(found_dollar, 0) ThenBlock {
                    Debug("Redis.ParseCommand.NoDollar", level=1) {
                        PrintMessage("  ERROR: No bulk string marker found")
                    }
                    ReturnValue(ArrayCreate(0))
                }
                
                // Extract command length
                command_len_str = StringExtractUntil(buffer, Add(offset, 1), "\r\n")
                command_len = StringToNumber(command_len_str)
                
                Debug("Redis.ParseCommand.CommandLen", level=3) {
                    PrintMessage("  Command length: ")
                    PrintNumber(command_len)
                }
                
                command_start = Add(offset, Add(StringLength(command_len_str), 3))
                command = StringExtract(buffer, command_start, command_len)
                
                Debug("Redis.ParseCommand.Command", level=2) {
                    PrintMessage("  Extracted command: ")
                    PrintMessage(command)
                }
                
                // Identify command type
                is_set = StringEquals(command, "SET")
                is_get = StringEquals(command, "GET")
                is_ping = StringEquals(command, "PING")
                
                IfCondition is_set ThenBlock {
                    Debug("Redis.ParseCommand.SET", level=2) {
                        PrintMessage("  Identified as SET command")
                    }
                    
                    // Simplified: Return placeholder
                    parts = ArrayCreate(3)
                    ArraySet(parts, 0, "SET")
                    ArraySet(parts, 1, "temp_key")
                    ArraySet(parts, 2, "temp_value")
                    
                    Debug("Redis.ParseCommand.SET.Parts", level=3) {
                        PrintMessage("    Created parts array with 3 elements")
                    }
                    
                    ReturnValue(parts)
                }
                
                IfCondition is_get ThenBlock {
                    Debug("Redis.ParseCommand.GET", level=2) {
                        PrintMessage("  Identified as GET command")
                    }
                    
                    parts = ArrayCreate(2)
                    ArraySet(parts, 0, "GET")
                    ArraySet(parts, 1, "temp_key")
                    
                    Debug("Redis.ParseCommand.GET.Parts", level=3) {
                        PrintMessage("    Created parts array with 2 elements")
                    }
                    
                    ReturnValue(parts)
                }
                
                IfCondition is_ping ThenBlock {
                    Debug("Redis.ParseCommand.PING", level=2) {
                        PrintMessage("  Identified as PING command")
                    }
                    
                    parts = ArrayCreate(1)
                    ArraySet(parts, 0, "PING")
                    
                    ReturnValue(parts)
                }
                
                Debug("Redis.ParseCommand.Unknown", level=2) {
                    PrintMessage("  Unknown command: ")
                    PrintMessage(command)
                }
            } ElseBlock {
                Debug("Redis.ParseCommand.NotArray", level=1) {
                    PrintMessage("  ERROR: Not a RESP array (first byte != '*')")
                }
            }
            
            // Return an empty array if parsing fails
            Debug("Redis.ParseCommand.Failed", level=1) {
                PrintMessage("  Parsing failed, returning empty array")
            }
            
            ReturnValue(ArrayCreate(0))
        }
    }
    
    // Helper: Parse bulk string from RESP
    Function.ParseBulkString {
        Input: buffer: Address
        Input: offset: Integer
        Body: {
            Debug("Redis.ParseBulkString", level=3) {
                PrintMessage("Parsing bulk string at offset: ")
                PrintNumber(offset)
            }
            
            DebugAssert(NotEqual(buffer, 0), "Redis.ParseBulkString null buffer")
            DebugAssert(GreaterEqual(offset, 0), "Redis.ParseBulkString negative offset")
            
            // Find the next '$' marker from the given offset
            i = offset
            marker_pos = -1
            iterations = 0
            max_iterations = 1000
            
            WhileLoop And(LessThan(iterations, max_iterations), EqualTo(marker_pos, -1)) {
                char = Dereference(Add(buffer, i))
                
                Debug("Redis.ParseBulkString.Scan", level=4) {
                    PrintMessage("    Checking position ")
                    PrintNumber(i)
                    PrintMessage(": ")
                    PrintNumber(char)
                }
                
                IfCondition EqualTo(char, 36) ThenBlock { // 36 = '$'
                    marker_pos = i
                    
                    Debug("Redis.ParseBulkString.Found", level=3) {
                        PrintMessage("  Found '$' at position: ")
                        PrintNumber(marker_pos)
                    }
                }
                
                IfCondition EqualTo(char, 0) ThenBlock {
                    Debug("Redis.ParseBulkString.EndOfBuffer", level=3) {
                        PrintMessage("  Reached end of buffer")
                    }
                    marker_pos = -2  // Signal end
                }
                
                i = Add(i, 1)
                iterations = Add(iterations, 1)
            }
            
            DebugAssert(LessThan(iterations, max_iterations), "Redis.ParseBulkString infinite loop detected")
            
            // If no marker found, return null
            IfCondition LessThan(marker_pos, 0) ThenBlock {
                Debug("Redis.ParseBulkString.NoMarker", level=2) {
                    PrintMessage("  No bulk string marker found")
                }
                ReturnValue(0)
            }
            
            // Parse length
            len_str = StringExtractUntil(buffer, Add(marker_pos, 1), "\r\n")
            len = StringToNumber(len_str)
            
            Debug("Redis.ParseBulkString.Length", level=3) {
                PrintMessage("  Bulk string length: ")
                PrintNumber(len)
            }
            
            DebugAssert(GreaterEqual(len, 0), "Redis.ParseBulkString negative length")
            DebugAssert(LessThan(len, 10000), "Redis.ParseBulkString length too large")
            
            // Extract data
            data_start = Add(marker_pos, Add(StringLength(len_str), 3))
            data = StringExtract(buffer, data_start, len)
            
            Debug("Redis.ParseBulkString.Extracted", level=3) {
                PrintMessage("  Extracted data: ")
                PrintMessage(data)
            }
            
            ReturnValue(data)
        }
    }
    
    // Delete keys
    Function.Delete {
        Input: store: Address
        Input: keys: Array
        Body: {
            Debug("Redis.Delete", level=2) {
                PrintMessage("DELETE operation for ")
                PrintNumber(ArrayLength(keys))
                PrintMessage(" keys")
            }
            
            DebugAssert(NotEqual(store, 0), "Redis.Delete invalid store")
            
            deleted = 0
            i = 0
            len = ArrayLength(keys)
            
            WhileLoop LessThan(i, len) {
                key = ArrayGet(keys, i)
                
                Debug("Redis.Delete.Key", level=3) {
                    PrintMessage("  Checking key: ")
                    PrintMessage(key)
                }
                
                exists = HashExists(store, key)
                IfCondition exists ThenBlock {
                    HashDelete(store, key)
                    deleted = Add(deleted, 1)
                    
                    Debug("Redis.Delete.Deleted", level=3) {
                        PrintMessage("    Deleted successfully")
                    }
                } ElseBlock {
                    Debug("Redis.Delete.NotFound", level=3) {
                        PrintMessage("    Key not found")
                    }
                }
                
                i = Add(i, 1)
            }
            
            Debug("Redis.Delete.Complete", level=2) {
                PrintMessage("  Total deleted: ")
                PrintNumber(deleted)
            }
            
            ReturnValue(deleted)
        }
    }
}