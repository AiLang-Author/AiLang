// =============================================================================
// AILANG Checksum Unit Test
// Tests CRC32 checksum calculation for data integrity verification
// Similar to Unix/Linux cksum utility
// =============================================================================

// Test configuration
DEBUG_LEVEL = 2

// Import XArrays for the mock Redis hash table
LibraryImport.Library.XArrays

// --- WORKAROUND: Use a global context for assertion messages to bypass compiler scope bug ---
FixedPool.AssertContext {
    "message": Initialize=""
}

// =============================================================================
// CRC32 Implementation
// =============================================================================

Function.CRC32.Init {
    Output: Integer
    Body: {
        // CRC32 polynomial: 0xEDB88320 (reversed representation)
        polynomial = 0xEDB88320
        ReturnValue(polynomial)
    }
}

FixedPool.SyscallNumbers {
    "READ": Initialize=0
    "WRITE": Initialize=1
    "OPEN": Initialize=2
    "CLOSE": Initialize=3
    "STAT": Initialize=4
    "TIME": Initialize=201
}

Function.CRC32.Calculate {
    Input: data: String
    Input: length: Integer
    Output: Integer
    Body: {
        // Initialize CRC value (all bits set)
        crc = 0xFFFFFFFF
        polynomial = CRC32.Init()
        
        // Process each byte
        i = 0
        WhileLoop LessThan(i, length) {
            // Get byte from string at position i
            byte = StringCharAt(data, i)
            
            // XOR byte with low byte of CRC
            crc = BitwiseXor(crc, byte)
            
            // Process 8 bits
            bit = 0
            WhileLoop LessThan(bit, 8) {
                // Check if lowest bit is set
                carry = BitwiseAnd(crc, 1)
                
                // Shift right by 1
                crc = RightShift(crc, 1)
                
                // If carry was set, XOR with polynomial
                IfCondition NotEqual(carry, 0) ThenBlock: {
                    crc = BitwiseXor(crc, polynomial)
                }
                
                bit = Add(bit, 1)
            }
            
            i = Add(i, 1)
        }
        
        // Final XOR to get result
        result = BitwiseXor(crc, 0xFFFFFFFF)
        ReturnValue(result)
    }
}

// =============================================================================
// Checksum wrapper functions
// =============================================================================

Function.Checksum.String {
    Input: text: String
    Output: Integer
    Body: {
        length = StringLength(text)
        checksum = CRC32.Calculate(text, length)
        ReturnValue(checksum)
    }
}

Function.Checksum.File {
    Input: filename: String
    Output: Integer
    Body: {
        // --- REVERTED: Reverted from SystemCall due to runtime hang ---
        // The SystemCall(READ,...) primitive causes the program to hang.
        // We are reverting to the high-level ReadTextFile. This test will
        // likely fail, but the program will complete its run.
        
        content = ReadTextFile(filename)
        
        IfCondition EqualTo(content, 0) ThenBlock: {
            PrintMessage("ERROR: Could not read file for checksum")
            ReturnValue(0)
        }
        
        // Calculate checksum
        length = StringLength(content)
        checksum = CRC32.Calculate(content, length)
        Deallocate(content, 0)
        ReturnValue(checksum)
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

Function.Helpers.StringCopy {
    Input: source: String
    Output: String
    Body: {
        len = StringLength(source)
        dest = Allocate(Add(len, 1))
        MemoryCopy(dest, source, len)
        SetByte(dest, len, 0)
        ReturnValue(dest)
    }
}

// =============================================================================
// Test Helper Functions
// =============================================================================

// --- REWRITE: Moved assert functions to their own namespace to avoid compiler scope bug ---
Function.Assert.IsTrue {
    Input: condition: Integer
    Body: {
        // --- WORKAROUND: Use Branch instead of IfCondition to avoid compiler scope bug ---
        Branch condition {
            Case 0: { // This is the 'false' path for the condition
                PrintMessage("ASSERTION FAILED:")
                PrintMessage(AssertContext.message)
            }
        }
    }
}

Function.Assert.AreEqual {
    Input: actual: Integer
    Input: expected: Integer
    Body: {
        // --- WORKAROUND: Use Branch instead of IfCondition to avoid compiler scope bug ---
        is_equal = EqualTo(actual, expected)
        Branch is_equal {
            Case 0: { // This is the 'false' path, i.e., they are not equal
                PrintMessage("TEST FAILED:")
                PrintMessage(AssertContext.message)

                actual_str = NumberToString(actual)
                expected_str = NumberToString(expected)
                
                msg = StringConcat("Expected: ", expected_str)
                PrintMessage(msg)
                msg = StringConcat("Actual: ", actual_str)
                PrintMessage(msg)
            }
            Default: { // This is the 'true' path
                msg = StringConcat("âœ“ PASSED: ", AssertContext.message)
                PrintMessage(msg)
            }
        }
    }
}

// =============================================================================
// Unit Tests
// =============================================================================

Function.Test.EmptyString {
    Body: {
        // Empty string should have specific CRC
        empty = ""
        checksum = Checksum.String(empty)
        
        // CRC32 of empty string is 0
        AssertContext.message = "Empty string checksum"
        Assert.AreEqual(checksum, 0)
    }
}

Function.Test.SingleCharacter {
    Body: {
        // Test single character checksums
        char_a = "a"
        checksum_a = Checksum.String(char_a)
        AssertContext.message = "Single character 'a' checksum"
        Assert.AreEqual(checksum_a, 0xE8B7BE43)
        
        char_0 = "0"
        checksum_0 = Checksum.String(char_0)
        AssertContext.message = "Single character '0' checksum"
        Assert.AreEqual(checksum_0, 0xF4DBDF21)
    }
}

Function.Test.KnownStrings {
    Body: {
        // Test known string checksums
        test1 = "Hello, World!"
        checksum1 = Checksum.String(test1)
        AssertContext.message = "Hello World checksum"
        Assert.AreEqual(checksum1, 0xEC4AC3D0)
        
        test2 = "123456789"
        checksum2 = Checksum.String(test2)
        AssertContext.message = "Numeric string checksum"
        Assert.AreEqual(checksum2, 0xCBF43926)
        
        test3 = "The quick brown fox jumps over the lazy dog"
        checksum3 = Checksum.String(test3)
        AssertContext.message = "Pangram checksum"
        Assert.AreEqual(checksum3, 0x414FA339)
    }
}

Function.Test.ConsistencyCheck {
    Body: {
        // Same input should always produce same checksum
        test_data = "Consistency test data"
        
        checksum1 = Checksum.String(test_data)
        checksum2 = Checksum.String(test_data)
        checksum3 = Checksum.String(test_data)
        
        AssertContext.message = "Consistency check 1-2"
        Assert.AreEqual(checksum1, checksum2)
        AssertContext.message = "Consistency check 2-3"
        Assert.AreEqual(checksum2, checksum3)
    }
}

Function.Test.DifferentData {
    Body: {
        // Different data should produce different checksums
        data1 = "Test data 1"
        data2 = "Test data 2"
        
        checksum1 = Checksum.String(data1)
        checksum2 = Checksum.String(data2)
        
        is_different = NotEqual(checksum1, checksum2)
        AssertContext.message = "Different data should have different checksums"
        Assert.IsTrue(is_different)
    }
}

Function.Test.FileChecksum {
    Body: {
        // Test file-based checksum
        filename = "test_checksum_data.txt"
        test_content = "This is test file content for checksum verification"
        
        // --- WORKAROUND: Use low-level syscalls for file I/O ---
        // The parser has a bug where it doesn't recognize OpenFile as a valid
        // expression. We can bypass this by using the SystemCall primitive directly,
        // which is a more explicit and robust method.
        
        // flags = O_WRONLY | O_CREAT | O_TRUNC = 1 | 64 | 512 = 577
        // mode = 0644 (octal) = 420 (decimal)
        file_handle = SystemCall(SyscallNumbers.OPEN, filename, 577, 420)
        
        IfCondition GreaterThan(file_handle, 0) ThenBlock: {
            content_len = StringLength(test_content)
            bytes_written = SystemCall(SyscallNumbers.WRITE, file_handle, test_content, content_len)
            close_result = SystemCall(SyscallNumbers.CLOSE, file_handle)
        }
        
        // Verify file exists
        exists = FileExists(filename)
        AssertContext.message = "Test file should exist"
        Assert.IsTrue(exists)
        
        // Calculate checksums
        string_checksum = Checksum.String(test_content)
        file_checksum = Checksum.File(filename)
        
        // File and string checksums should match
        AssertContext.message = "File vs string checksum"
        Assert.AreEqual(file_checksum, string_checksum)
    }
}

Function.Test.LargeData {
    Body: {
        // Test with larger data blocks
        large_data = ""
        i = 0
        WhileLoop LessThan(i, 100) {
            large_data = StringConcat(large_data, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
            i = Add(i, 1)
        }
        
        checksum = Checksum.String(large_data)
        
        // Just verify it completes without error
        is_nonzero = NotEqual(checksum, 0)
        AssertContext.message = "Large data checksum should be non-zero"
        Assert.IsTrue(is_nonzero)
    }
}

// =============================================================================
// Mock Functions for Integration Tests
// =============================================================================

Function.Redis.Init {
    Input: size: Integer
    Output: Integer
    Body: {
        // Mock init, create an XSHash to act as the store.
        store_handle = XSHash.XCreate(size)
        ReturnValue(store_handle)
    }
}

Function.Redis.Set {
    Input: store: Integer
    Input: key: String
    Input: value: String
    Body: {
        // Mock set, using the XSHash library.
        // We need to copy the value since the hash table will own it.
        value_copy = Helpers.StringCopy(value)
        XSHash.XInsert(store, key, value_copy)
    }
}

Function.Redis.Get {
    Input: store: Integer
    Input: key: String
    Output: String
    Body: {
        // Mock get, using the XSHash library.
        value_ptr = XSHash.XLookup(store, key)
        
        is_found = NotEqual(value_ptr, XArrays.XNULL)
        IfCondition is_found ThenBlock: {
            // The hash table stores a pointer to the value.
            ReturnValue(value_ptr)
        } ElseBlock: {
            // Return an empty string if not found.
            ReturnValue("")
        }
    }
}
// =============================================================================
// Redis Integration Tests
// =============================================================================

Function.Test.RedisDataIntegrity {
    Body: {
        // Initialize Redis store
        store = Redis.Init(256)
        
        // Test data
        key1 = "user:1001"
        value1 = "John Doe,john@example.com,active"
        
        key2 = "session:abc123"
        value2 = "user_id=1001,expires=1234567890,token=xyz"
        
        // Calculate checksums before storage
        checksum1_before = Checksum.String(value1)
        checksum2_before = Checksum.String(value2)
        
        // Store in Redis
        Redis.Set(store, key1, value1)
        Redis.Set(store, key2, value2)
        
        // Retrieve from Redis
        retrieved1 = Redis.Get(store, key1)
        retrieved2 = Redis.Get(store, key2)
        
        // Calculate checksums after retrieval
        checksum1_after = Checksum.String(retrieved1)
        checksum2_after = Checksum.String(retrieved2)
        
        // Verify data integrity
        AssertContext.message = "Redis data integrity for key1"
        Assert.AreEqual(checksum1_after, checksum1_before)
        AssertContext.message = "Redis data integrity for key2"
        Assert.AreEqual(checksum2_after, checksum2_before)
    }
}

Function.Test.NetworkDataVerification {
    Body: {
        // Simulate network data transmission with checksum verification
        original_message = "PING:timestamp=1234567890:client=test"
        
        // Calculate checksum before "transmission"
        checksum_send = Checksum.String(original_message)
        
        // Simulate transmission (in real scenario, this would be socket operations)
        transmitted = original_message
        
        // Calculate checksum after "reception"
        checksum_recv = Checksum.String(transmitted)
        
        // Verify integrity
        AssertContext.message = "Network data integrity check"
        Assert.AreEqual(checksum_recv, checksum_send)
    }
}

// =============================================================================
// Performance Tests
// =============================================================================

// --- REWRITE: Renamed function and unrolled loop to use static labels ---
// The DebugPerf parser requires string literals for labels, so we cannot
// generate them dynamically inside a loop. This version unrolls the loop.
Function.Benchmark.ChecksumPerformance {
    Body: {
        DebugPerf.Start("checksum_performance")
        
        // --- Test size 10 ---
        data10 = ""
        j = 0
        WhileLoop LessThan(j, 10) {
            data10 = StringConcat(data10, "X")
            j = Add(j, 1)
        }
        DebugPerf.Mark("size_10")
        checksum10 = Checksum.String(data10)
        DebugPerf.Mark("size_10_done")

        // --- Test size 100 ---
        data100 = ""
        j = 0
        WhileLoop LessThan(j, 100) {
            data100 = StringConcat(data100, "X")
            j = Add(j, 1)
        }
        DebugPerf.Mark("size_100")
        checksum100 = Checksum.String(data100)
        DebugPerf.Mark("size_100_done")

        // --- Test size 1000 ---
        data1000 = ""
        j = 0
        WhileLoop LessThan(j, 1000) {
            data1000 = StringConcat(data1000, "X")
            j = Add(j, 1)
        }
        DebugPerf.Mark("size_1000")
        checksum1000 = Checksum.String(data1000)
        DebugPerf.Mark("size_1000_done")

        // --- Test size 10000 ---
        data10000 = ""
        j = 0
        WhileLoop LessThan(j, 10000) {
            data10000 = StringConcat(data10000, "X")
            j = Add(j, 1)
        }
        DebugPerf.Mark("size_10000")
        checksum10000 = Checksum.String(data10000)
        DebugPerf.Mark("size_10000_done")
        
        DebugPerf.Stop("checksum_performance")
        DebugPerf.Report("checksum_performance")
    }
}

// =============================================================================
// Test Suite Runner
// =============================================================================

Function.RunAllTests {
    Body: {
        PrintMessage("===========================================")
        PrintMessage("    AILANG CHECKSUM UNIT TEST SUITE")
        PrintMessage("===========================================")
        PrintMessage("")
        
        PrintMessage("--- Basic Tests ---")
        Test.EmptyString()
        Test.SingleCharacter()
        Test.KnownStrings()
        
        PrintMessage("")
        PrintMessage("--- Integrity Tests ---")
        Test.ConsistencyCheck()
        Test.DifferentData()
        Test.FileChecksum()
        Test.LargeData()
        
        PrintMessage("")
        PrintMessage("--- Integration Tests ---")
        Test.RedisDataIntegrity()
        Test.NetworkDataVerification()
        
        PrintMessage("")
        PrintMessage("--- Performance Tests ---")
        Benchmark.ChecksumPerformance()
        
        PrintMessage("")
        PrintMessage("===========================================")
        PrintMessage("    ALL CHECKSUM TESTS COMPLETED")
        PrintMessage("===========================================")
    }
}

// =============================================================================
// Main Entry Point
// =============================================================================

SubRoutine.Main {
    RunAllTests()
    
    // Demonstrate practical usage
    PrintMessage("")
    PrintMessage("--- Practical Example ---")
    
    // Create a config file with checksum verification
    config_data = "server_port=6379\nmax_connections=1000\ntimeout=30"
    config_checksum = Checksum.String(config_data)
    
    // Save config with checksum
    WriteTextFile("config.txt", config_data)
    checksum_str = NumberToString(config_checksum)
    WriteTextFile("config.cksum", checksum_str)
    
    PrintMessage("Config file saved with checksum:")
    PrintMessage(checksum_str)
    
    // Later, verify integrity
    loaded_config = ReadTextFile("config.txt")
    loaded_checksum_str = ReadTextFile("config.cksum")
    loaded_checksum = StringToNumber(loaded_checksum_str)
    
    current_checksum = Checksum.String(loaded_config)
    
    IfCondition EqualTo(current_checksum, loaded_checksum) ThenBlock: {
        PrintMessage("âœ“ Config integrity verified!")
    } ElseBlock: {
        PrintMessage("âš  WARNING: Config file may be corrupted!")
    }
}

RunTask(Main)