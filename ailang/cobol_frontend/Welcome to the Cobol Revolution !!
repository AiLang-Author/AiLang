# COBOL to Ailang Transpiler, Save your billion dollar business logic and modernize it into a modern language. 
---

A complete COBOL-to-native compiler that transpiles legacy COBOL programs into Ailang source code and compiles them to x86 native executables. Part of the Ailang multi-frontend compilation ecosystem.

## ðŸš€ Quick Start

```bash
# Compile a COBOL program to native binary
python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/occurs.cbl -o occurs --debug

# Run the compiled executable
./occurs_exec
```

## ðŸ“‹ Table of Contents

- [Overview](#overview)
- [How It Works](#how-it-works)
- [Installation](#installation)
- [Usage](#usage)
- [Architecture](#architecture)
- [Supported Features](#supported-features)
- [Examples](#examples)
- [Project Structure](#project-structure)
- [Development](#development)

## Overview

This transpiler is part of a larger project to compile legacy languages to native code via the **Ailang programming language**. Similar to the Python/AIMacro transpiler, this COBOL frontend converts COBOL-74/85 programs into Ailang source code, which is then compiled to x86 native binaries by Ailang's own baremetal compiler.

**Pipeline:** `COBOL Source â†’ Tokens â†’ COBOL AST â†’ Ailang AST â†’ Ailang Source â†’ x86 Native Binary`

### What is Ailang?

Ailang is a standalone programming language with its own x86 backend compiler that generates native machine code. This COBOL transpiler targets Ailang as its output language, allowing legacy COBOL programs to be compiled to modern native executables.

### Key Features

- âœ… Full COBOL-74/85 syntax support for common constructs
- âœ… Both fixed-format and free-format COBOL
- âœ… Multi-program files (multiple `PROGRAM-ID`s in one `.cbl` file)
- âœ… Automatic dependency resolution for CALL statements
- âœ… Type inference from PIC clauses
- âœ… Direct compilation to native executables
- âœ… Debug mode with detailed pipeline inspection
- âœ… Zero external dependencies (Python stdlib only)

## How It Works

The command `python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/occurs.cbl -o occurs --debug` executes a 5-stage compilation pipeline:

### Stage 1: Lexing (Tokenization)
**Input:** Raw COBOL source code  
**Output:** Token stream  
**Module:** `cobol_lexer.py`

The lexer scans the COBOL source and produces tokens. It handles:
- Fixed-format COBOL (columns 1-6 sequence, column 7 indicator, columns 8-72 code)
- Free-format COBOL (modern style)
- Case-insensitive keywords
- Comments (`*` in column 7, or `*>` anywhere)
- String literals, numeric literals, identifiers

**Debug Output Example:**
```
âœ“ Stage 1: Lexing COBOL source...
--- Tokens (first 20) ---
  IDENTIFICATION: IDENTIFICATION
  DIVISION: DIVISION
  PERIOD: .
  PROGRAM_ID: PROGRAM-ID
  PERIOD: .
  ...
```

### Stage 2: Parsing (AST Construction)
**Input:** Token stream  
**Output:** COBOL Abstract Syntax Tree (AST)  
**Module:** `parser/` package

The parser builds a structured AST representing the COBOL program structure:
- `COBOLCompilationUnit` (container for multiple programs)
- `COBOLProgram` (one per PROGRAM-ID)
- `COBOLDataDivision` (variable declarations)
- `COBOLProcedureDivision` (executable code)
- Statement nodes (`COBOLDisplay`, `COBOLMove`, `COBOLIf`, etc.)

**Debug Output Example:**
```
âœ“ Stage 2: Parsing tokens into COBOL AST...
    Found 1 COBOL program(s):
      1. OCCURS-TEST: 3 variables, 1 paragraphs
```

### Stage 3: AST Conversion (COBOL â†’ Ailang)
**Input:** COBOL AST  
**Output:** Ailang AST  
**Module:** `converter/` package

The converter transforms COBOL semantics into equivalent Ailang constructs:
- COBOL variables â†’ Ailang `DeclareVariable` nodes
- COBOL `DISPLAY` â†’ Ailang `PrintMessage` calls
- COBOL `IF/ELSE` â†’ Ailang `IfCondition` nodes
- COBOL `PERFORM UNTIL` â†’ Ailang `WhileLoop` nodes
- COBOL paragraphs â†’ Ailang function calls
- PIC clauses â†’ Ailang type inference (INT, STRING, etc.)

**Debug Output Example:**
```
âœ“ Stage 3: Converting COBOL AST to Ailang AST...
    Generated 1 Ailang function(s)
```

### Stage 4: Serialization (Ailang AST â†’ Source)
**Input:** Ailang AST  
**Output:** `.ailang` source file  
**Module:** `converter/serializer.py`

The serializer converts the Ailang AST into textual Ailang source code:

**Debug Output Example:**
```
âœ“ Stage 4: Serializing Ailang AST to source...
    Generated: occurs.ailang (1234 bytes)
--- Ailang Source (first 50 lines) ---
Function.Main
    DeclareVariable.COUNTER Type.INT DefaultValue.0
    DeclareVariable.ITEM_1 Type.STRING DefaultValue.""
    PrintMessage "Array Test"
    ...
```

### Stage 5: Ailang Compilation (x86 Code Generation)
**Input:** `.ailang` source file  
**Output:** x86 native executable  
**Module:** Calls `main.py` (Ailang's x86 baremetal compiler)

Invokes the Ailang compiler, which parses the Ailang source and generates x86 machine code:

```bash
python3 main.py occurs.ailang -o occurs
```

Ailang's compiler handles:
- Parsing Ailang syntax
- Type checking and validation
- x86 assembly generation
- Native executable creation

**Debug Output Example:**
```
âœ“ Stage 5: Invoking Ailang compiler on 'occurs.ailang'...
âœ“ Compilation successful!
  Executable: occurs_exec

Run with: ./occurs_exec
```

### Debug Mode Benefits

The `--debug` flag provides full visibility into each stage:
- See the tokens generated by the lexer
- Inspect the COBOL AST structure
- View the Ailang AST transformation
- Examine the generated Ailang source code
- Keeps intermediate `.ailang` files for inspection

This is invaluable for:
- Understanding the compilation process
- Debugging COBOL syntax issues
- Verifying correct code generation
- Learning how COBOL maps to Ailang

## Installation

### Prerequisites

- Python 3.8+
- Ailang compiler (`main.py` in project root)
- Ailang's x86 backend and runtime libraries
- No external Python dependencies required!

### Setup

```bash
# Clone or navigate to your Ailang project
cd /path/to/ailang/

# Verify the COBOL frontend exists
ls -la cobol_frontend/

# Expected files:
# - cobol_lexer.py
# - parser/ (package)
# - converter/ (package)
# - cobol_integration.py
# - cobol_test_suite.py
```

## Usage

### Basic Compilation

```bash
# Compile COBOL to native binary
python3 cobol_frontend/cobol_integration.py program.cbl -o program

# Run the executable
./program_exec
```

### Debug Mode (Recommended for First Use)

```bash
# Compile with detailed pipeline output
python3 cobol_frontend/cobol_integration.py program.cbl -o program --debug
```

This shows you:
- âœ“ Tokens generated by the lexer
- âœ“ COBOL AST structure  
- âœ“ Generated Ailang AST
- âœ“ Ailang source code
- âœ“ Compilation stages

### Generate Ailang Only (No Compilation)

```bash
# Just transpile to Ailang source
python3 cobol_frontend/cobol_integration.py program.cbl --ailang-only

# This creates program.ailang which you can inspect or compile later
python3 main.py program.ailang -o program
```

### Split Multi-Program Files

```bash
# Generate one .ailang file per COBOL program (useful for large systems)
python3 cobol_frontend/cobol_integration.py multi-prog.cbl --split-programs

# This creates separate files: PROG1.ailang, PROG2.ailang, etc.
# Each can be compiled independently or as a library
```

### Automatic Dependency Resolution

```bash
# Auto-resolve dependencies (default behavior)
python3 cobol_frontend/cobol_integration.py calc.cbl -o calc
# â†’ Automatically finds and includes cobloan.cbl and cobvalu.cbl!

# Manual mode (specify all files explicitly)
python3 cobol_frontend/cobol_integration.py calc.cbl cobloan.cbl -o calc --no-auto

# Add search paths for dependencies
python3 cobol_frontend/cobol_integration.py calc.cbl -o calc -I../lib -I../common

# Debug dependency resolution
python3 cobol_frontend/cobol_integration.py calc.cbl -o calc --debug
```

The compiler scans COBOL source for CALL statements and automatically finds and includes the called programs. For example:
- `CALL "COBLOAN"` â†’ Searches for cobloan.cbl, COBLOAN.cbl, etc.

**Search order:**
1. Same directory as the main file
2. Directories specified with `-I/--include-path`
3. Current working directory

### Programmatic API

```python
from cobol_frontend import COBOLIntegratedCompiler

# Create compiler instance with auto-dependency resolution
compiler = COBOLIntegratedCompiler(debug=True)

# Compile COBOL file (auto-resolves dependencies)
compiler.compile_file('program.cbl', 'program')

# Manual mode with multiple files
compiler.compile_files(['main.cbl', 'lib1.cbl', 'lib2.cbl'], 'myapp')
```

## Architecture

### Component Overview

```
cobol_frontend/
â”‚
â”œâ”€â”€ cobol_lexer.py           # Stage 1: COBOL Source â†’ Tokens
â”‚   â””â”€â”€ COBOLLexer class
â”‚       - Tokenizes COBOL source code
â”‚       - Handles fixed/free format
â”‚       - Case-insensitive keywords
â”‚
â”œâ”€â”€ parser/                   # Stage 2: Tokens â†’ COBOL AST
â”‚   â”œâ”€â”€ __init__.py          # Package exports
â”‚   â”œâ”€â”€ parser_core.py       # Base parser class and utilities
â”‚   â”œâ”€â”€ division_parsers.py  # IDENTIFICATION, DATA, PROCEDURE divisions
â”‚   â”œâ”€â”€ expression_parsers.py # Variable declarations and expressions
â”‚   â””â”€â”€ statement_parsers.py # COBOL statement parsing (MOVE, IF, etc.)
â”‚
â”œâ”€â”€ converter/               # Stage 3-4: COBOL AST â†’ Ailang
â”‚   â”œâ”€â”€ __init__.py          # Package exports
â”‚   â”œâ”€â”€ converter_core.py    # Main AST conversion logic
â”‚   â”œâ”€â”€ statement_converter.py # Statement-level conversion
â”‚   â””â”€â”€ serializer.py        # Ailang AST â†’ source code
â”‚
â”œâ”€â”€ cobol_integration.py     # Stage 5: Orchestration & compilation
â”‚   â””â”€â”€ COBOLIntegratedCompiler
â”‚       - Manages full pipeline
â”‚       - Auto-dependency resolution
â”‚       - Invokes Ailang compiler
â”‚       - Error handling and cleanup
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ hello.cbl            # Sample: Hello World
    â”œâ”€â”€ calculate.cbl        # Sample: Arithmetic
    â”œâ”€â”€ loop.cbl             # Sample: Loops
    â””â”€â”€ newcob.cbl           # NIST test suite (330k+ LOC)
```

### AST Node Types

**COBOL AST Nodes** (defined in `parser/parser_core.py`):
- `COBOLCompilationUnit` - Container for multiple programs
- `COBOLProgram` - One COBOL program (PROGRAM-ID)
- `COBOLDataDivision` - Variable declarations
- `COBOLVariableDecl` - Individual variable with PIC clause
- `COBOLProcedureDivision` - Executable code
- `COBOLParagraph` - Named code section
- Statement nodes: `COBOLDisplay`, `COBOLMove`, `COBOLIf`, `COBOLPerform`, `COBOLCompute`, etc.

**Ailang AST Nodes** (imported from `ailang_parser/ailang_ast.py`):
- `Function` - Ailang function definition
- `DeclareVariable` - Variable declaration
- `PrintMessage` - Output statement
- `IfCondition` - Conditional logic
- `WhileLoop` - Loop construct
- `CallFunction` - Function call
- `ReturnValue` - Function return

### Type Mapping

COBOL PIC clauses are automatically converted to Ailang types:

| COBOL PIC | Ailang Type | Example |
|-----------|-------------|---------|
| `PIC 9(n)` | `Type.INT` | `PIC 9(4)` â†’ 32-bit integer |
| `PIC X(n)` | `Type.STRING` | `PIC X(30)` â†’ String |
| `PIC S9(n)` | `Type.INT` | `PIC S9(5)` â†’ Signed integer |
| `PIC A(n)` | `Type.STRING` | `PIC A(20)` â†’ Alphabetic string |

### Name Normalization

COBOL identifiers are converted to Ailang-compatible names:

```
COBOL Style         â†’  Ailang Style
-----------------------------------
MY-VARIABLE         â†’  MY_VARIABLE
EMPLOYEE-NAME       â†’  EMPLOYEE_NAME
TOTAL-AMOUNT        â†’  TOTAL_AMOUNT
```

## Supported Features

### âœ… Fully Supported

**Data Division:**
- `WORKING-STORAGE SECTION`
- Variable declarations with `PIC` clauses
- `VALUE` initialization
- Level numbers (01-49)
- `OCCURS` clauses (arrays/tables)
- `REDEFINES` (memory overlays)
- `LINKAGE SECTION` for parameters

**Procedure Division:**
- `DISPLAY` statements (string and variable)
- `MOVE` statements
- `COMPUTE` expressions
- Arithmetic operations: `ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`
- `IF ... ELSE ... END-IF` conditionals
- `PERFORM UNTIL ... END-PERFORM` loops
- `PERFORM TIMES` (counted loops)
- `PERFORM VARYING` (for loops with index)
- `PERFORM paragraph-name` (subroutine calls)
- `EVALUATE ... WHEN` (switch/case statements)
- Comparison operators: `=`, `>`, `<`, `>=`, `<=`, `NOT EQUAL`
- Logical operators: `AND`, `OR`, `NOT`
- `STRING`/`UNSTRING` operations
- `INSPECT` statement
- `CALL` for external programs
- `STOP RUN`, `GOBACK`, `EXIT`

**Format Support:**
- Fixed-format COBOL (columns 1-72)
- Free-format COBOL
- Comments (`*` in column 7, `*>` anywhere)
- Multi-program files (multiple `PROGRAM-ID`s)
- NIST marker comments for test suites

### ðŸš§ Partial Support

- File I/O (`FILE-CONTROL`, `OPEN`, `READ`, `WRITE`, `CLOSE`)
- `COPY` statements (copybook expansion)
- Complex PICTURE formats (some edge cases)
- Decimal arithmetic (COMP-3 partial support)

## Examples

### Example 1: Hello World

**Input** (`hello.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HELLO-WORLD.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 MESSAGE PIC X(30) VALUE "Hello from COBOL!".
       
       PROCEDURE DIVISION.
           DISPLAY MESSAGE.
           STOP RUN.
```

**Compile:**
```bash
python3 cobol_frontend/cobol_integration.py hello.cbl -o hello
./hello_exec
```

**Output:**
```
Hello from COBOL!
```

### Example 2: Arithmetic & Conditionals

**Input** (`calculate.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. CALCULATOR.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 A PIC 9(4) VALUE 100.
       01 B PIC 9(4) VALUE 50.
       01 RESULT PIC 9(5) VALUE 0.
       
       PROCEDURE DIVISION.
           COMPUTE RESULT = A + B.
           DISPLAY "Sum: ".
           DISPLAY RESULT.
           
           IF RESULT > 100
               DISPLAY "Result is large!"
           ELSE
               DISPLAY "Result is small"
           END-IF.
           
           STOP RUN.
```

**Generated Ailang** (excerpt):
```
Function.Main
    DeclareVariable.A Type.INT DefaultValue.100
    DeclareVariable.B Type.INT DefaultValue.50
    DeclareVariable.RESULT Type.INT DefaultValue.0
    
    AssignVariable.RESULT BinaryOp.Add Variable.A Variable.B
    PrintMessage "Sum: "
    PrintMessage Variable.RESULT
    
    IfCondition BinaryOp.GreaterThan Variable.RESULT Literal.100
        PrintMessage "Result is large!"
    Else
        PrintMessage "Result is small"
    EndIf
    
    ReturnValue Literal.0
```

### Example 3: Loops & Subroutines

**Input** (`loop.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LOOP-TEST.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 COUNTER PIC 9(4) VALUE 0.
       
       PROCEDURE DIVISION.
           PERFORM MAIN-LOOP.
           STOP RUN.
       
       MAIN-LOOP.
           PERFORM UNTIL COUNTER > 5
               DISPLAY "Count: "
               DISPLAY COUNTER
               ADD 1 TO COUNTER
           END-PERFORM.
```

## Project Structure

```
ailang/
â”œâ”€â”€ main.py                          # Ailang x86 compiler
â”œâ”€â”€ ailang_parser/                   # Ailang parser & AST definitions
â”‚   â””â”€â”€ ailang_ast.py               # Ailang AST node classes
â”œâ”€â”€ ailang_compiler/                 # Ailang x86 backend
â”‚   â””â”€â”€ ...                         # Code generation, optimization
â”œâ”€â”€ aimacro_frontend/                # Python/AIMacro transpiler
â”‚   â””â”€â”€ ...
â””â”€â”€ cobol_frontend/                  # COBOL transpiler (this project)
    â”œâ”€â”€ __init__.py                 # Package exports
    â”œâ”€â”€ cobol_lexer.py              # Lexer (~1200 lines)
    â”œâ”€â”€ parser/                      # Parser package (~8000+ lines)
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ parser_core.py          # Base classes (~500 lines)
    â”‚   â”œâ”€â”€ division_parsers.py     # Division parsing (~2500 lines)
    â”‚   â”œâ”€â”€ expression_parsers.py   # Expression & variable parsing (~3000 lines)
    â”‚   â””â”€â”€ statement_parsers.py    # Statement parsing (~2000 lines)
    â”œâ”€â”€ converter/                   # Converter package (~2500 lines)
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ converter_core.py       # Main conversion logic (~1500 lines)
    â”‚   â”œâ”€â”€ statement_converter.py  # Statement conversion (~800 lines)
    â”‚   â””â”€â”€ serializer.py           # Ailang serialization (~200 lines)
    â”œâ”€â”€ cobol_integration.py        # Integration (~500 lines)
    â”œâ”€â”€ cobol_test_suite.py         # Unit tests (~350 lines)
    â”œâ”€â”€ README.md                   # This file
    â””â”€â”€ tests/
        â”œâ”€â”€ hello.cbl               # Sample: Hello World
        â”œâ”€â”€ calculate.cbl           # Sample: Arithmetic
        â”œâ”€â”€ loop.cbl                # Sample: Loops
        â””â”€â”€ newcob.cbl              # NIST test suite (330k+ LOC)
```

## Development

### Running Tests

```bash
# Run full test suite
python3 cobol_frontend/cobol_test_suite.py

# Test with NIST 1985 suite (330k+ LOC, 473 programs)
python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/newcob.cbl --ailang-only

# Debug specific test file
python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/NC201A.cbl --debug

# Test dependency resolution
python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/calc.cbl -o calc --debug
```

### Adding New Features

1. **Add COBOL AST node** in `cobol_frontend/parser/parser_core.py`
2. **Update parser** in appropriate division parser file
3. **Add Ailang conversion** in `cobol_frontend/converter/converter_core.py` or `statement_converter.py`
4. **Write test case** in `cobol_test_suite.py`
5. **Update documentation**

### Debugging Tips

```bash
# Step 1: Use --debug to see all stages
python3 cobol_frontend/cobol_integration.py program.cbl -o program --debug

# Step 2: Inspect generated Ailang
cat program.ailang

# Step 3: Test Ailang compilation separately
python3 main.py program.ailang -o program

# Step 4: Check for COBOL syntax errors
# - Ensure periods (.) end statements
# - Check column alignment (fixed-format)
# - Verify keyword spelling

# Step 5: Debug dependency resolution
python3 cobol_frontend/cobol_integration.py program.cbl -o program --debug
# Shows which files are being auto-included and why
```

### Performance Metrics

- **Lexing:** < 1ms for typical programs
- **Parsing:** < 5ms for typical programs  
- **Conversion:** < 1ms for typical programs
- **Ailang Compilation:** Depends on program size
- **Dependency Resolution:** < 10ms per file scan

Total overhead of COBOL frontend: **~10-20ms** for most programs.

**NIST Test Suite Results:**
- 473 COBOL programs (330k+ LOC)
- ~450+ programs parsing successfully (95%+ success rate)
- Average compilation time: ~50-100ms per program

## Comparison: COBOL vs AIMacro Frontend

| Aspect | AIMacro | COBOL |
|--------|---------|-------|
| **Source Language** | Python-like | COBOL-74/85 |
| **Lexer Complexity** | Simple | Moderate (fixed/free format) |
| **Parser Type** | Recursive descent | Recursive descent |
| **Type System** | Inferred | PIC clauses â†’ explicit |
| **Functions** | `def name():` | Paragraphs |
| **Naming Convention** | `snake_case` | `HYPHEN-CASE` â†’ `UPPER_CASE` |
| **Lines of Code** | ~1500 | ~12,000+ |
| **Target Language** | Ailang | Ailang (same) |
| **Output Format** | `.ailang` source | `.ailang` source |
| **Backend Compiler** | `main.py` | `main.py` (same x86 backend) |

Both transpilers share the same Ailang backend and follow identical architectural patterns!

## Known Limitations

1. **Decimal Arithmetic:** Currently truncates to integers (COMP-3 not yet fully supported)
2. **File I/O:** `FILE-CONTROL` section partially implemented
3. **Advanced PIC:** Some complex PICTURE formats not fully supported
4. **COPY Statements:** Copybook expansion implemented but may have edge cases
5. **REDEFINES:** Memory overlays partially supported
6. **Nested Programs:** COBOL-85 nested programs not yet fully supported

## License

Part of the Ailang project. See main project LICENSE.

## Contributing

Contributions welcome! Please:
1. Write tests for new features
2. Follow existing code style
3. Update documentation
4. Test with `--debug` mode

## Credits

Built as a companion to the AIMacro (Python) transpiler, demonstrating Ailang's capability as a compilation target for legacy languages.
