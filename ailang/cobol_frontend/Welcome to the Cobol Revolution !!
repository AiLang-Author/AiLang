# COBOL to Ailang Transpiler, Save your billiion dollar business logic and modernize it into a modern language. 
---

A complete COBOL-to-native compiler that transpiles legacy COBOL programs into Ailang source code and compiles them to x86 native executables. Part of the Ailang multi-frontend compilation ecosystem.

## ðŸš€ Quick Start

```bash
# Compile a COBOL program to native binary
python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/occurs.cbl -o occurs --debug

# Run the compiled executable
./occurs_exec
```

## ðŸ“‹ Table of Contents

- [Overview](#overview)
- [How It Works](#how-it-works)
- [Installation](#installation)
- [Usage](#usage)
- [Architecture](#architecture)
- [Supported Features](#supported-features)
- [Examples](#examples)
- [Project Structure](#project-structure)
- [Development](#development)

## Overview

This transpiler is part of a larger project to compile legacy languages to native code via the **Ailang programming language**. Similar to the Python/AIMacro transpiler, this COBOL frontend converts COBOL-74/85 programs into Ailang source code, which is then compiled to x86 native binaries by Ailang's own baremetal compiler.

**Pipeline:** `COBOL Source â†’ Tokens â†’ COBOL AST â†’ Ailang AST â†’ Ailang Source â†’ x86 Native Binary`

### What is Ailang?

Ailang is a standalone programming language with its own x86 backend compiler that generates native machine code. This COBOL transpiler targets Ailang as its output language, allowing legacy COBOL programs to be compiled to modern native executables.

### Key Features

- âœ… Full COBOL-74/85 syntax support for common constructs
- âœ… Both fixed-format and free-format COBOL
- âœ… Multi-program files (multiple `PROGRAM-ID`s in one `.cbl` file)
- âœ… Type inference from PIC clauses
- âœ… Direct compilation to native executables
- âœ… Debug mode with detailed pipeline inspection
- âœ… Zero external dependencies (Python stdlib only)

## How It Works

The command `python3 cobol_frontend/cobol_integration.py cobol_frontend/tests/occurs.cbl -o occurs --debug` executes a 5-stage compilation pipeline:

### Stage 1: Lexing (Tokenization)
**Input:** Raw COBOL source code  
**Output:** Token stream  
**Module:** `cobol_lexer.py`

The lexer scans the COBOL source and produces tokens. It handles:
- Fixed-format COBOL (columns 1-6 sequence, column 7 indicator, columns 8-72 code)
- Free-format COBOL (modern style)
- Case-insensitive keywords
- Comments (`*` in column 7, or `*>` anywhere)
- String literals, numeric literals, identifiers

**Debug Output Example:**
```
âœ“ Stage 1: Lexing COBOL source...
--- Tokens (first 20) ---
  IDENTIFICATION: IDENTIFICATION
  DIVISION: DIVISION
  PERIOD: .
  PROGRAM_ID: PROGRAM-ID
  PERIOD: .
  ...
```

### Stage 2: Parsing (AST Construction)
**Input:** Token stream  
**Output:** COBOL Abstract Syntax Tree (AST)  
**Module:** `cobol_parser.py`

The parser builds a structured AST representing the COBOL program structure:
- `COBOLCompilationUnit` (container for multiple programs)
- `COBOLProgram` (one per PROGRAM-ID)
- `COBOLDataDivision` (variable declarations)
- `COBOLProcedureDivision` (executable code)
- Statement nodes (`COBOLDisplay`, `COBOLMove`, `COBOLIf`, etc.)

**Debug Output Example:**
```
âœ“ Stage 2: Parsing tokens into COBOL AST...
    Found 1 COBOL program(s):
      1. OCCURS-TEST: 3 variables, 1 paragraphs
```

### Stage 3: AST Conversion (COBOL â†’ Ailang)
**Input:** COBOL AST  
**Output:** Ailang AST  
**Module:** `cobol_ast_converter.py`

The converter transforms COBOL semantics into equivalent Ailang constructs:
- COBOL variables â†’ Ailang `DeclareVariable` nodes
- COBOL `DISPLAY` â†’ Ailang `PrintMessage` calls
- COBOL `IF/ELSE` â†’ Ailang `IfCondition` nodes
- COBOL `PERFORM UNTIL` â†’ Ailang `WhileLoop` nodes
- COBOL paragraphs â†’ Ailang function calls
- PIC clauses â†’ Ailang type inference (INT, STRING, etc.)

**Debug Output Example:**
```
âœ“ Stage 3: Converting COBOL AST to Ailang AST...
    Generated 1 Ailang function(s)
```

### Stage 4: Serialization (Ailang AST â†’ Source)
**Input:** Ailang AST  
**Output:** `.ailang` source file  
**Module:** `cobol_ast_converter.py` (AILangASTSerializer)

The serializer converts the Ailang AST into textual Ailang source code:

**Debug Output Example:**
```
âœ“ Stage 4: Serializing Ailang AST to source...
    Generated: occurs.ailang (1234 bytes)
--- Ailang Source (first 50 lines) ---
Function.Main
    DeclareVariable.COUNTER Type.INT DefaultValue.0
    DeclareVariable.ITEM_1 Type.STRING DefaultValue.""
    PrintMessage "Array Test"
    ...
```

### Stage 5: Ailang Compilation (x86 Code Generation)
**Input:** `.ailang` source file  
**Output:** x86 native executable  
**Module:** Calls `main.py` (Ailang's x86 baremetal compiler)

Invokes the Ailang compiler, which parses the Ailang source and generates x86 machine code:

```bash
python3 main.py occurs.ailang -o occurs
```

Ailang's compiler handles:
- Parsing Ailang syntax
- Type checking and validation
- x86 assembly generation
- Native executable creation

**Debug Output Example:**
```
âœ“ Stage 5: Invoking Ailang compiler on 'occurs.ailang'...
âœ“ Compilation successful!
  Executable: occurs_exec

Run with: ./occurs_exec
```

### Debug Mode Benefits

The `--debug` flag provides full visibility into each stage:
- See the tokens generated by the lexer
- Inspect the COBOL AST structure
- View the Ailang AST transformation
- Examine the generated Ailang source code
- Keeps intermediate `.ailang` files for inspection

This is invaluable for:
- Understanding the compilation process
- Debugging COBOL syntax issues
- Verifying correct code generation
- Learning how COBOL maps to Ailang

## Installation

### Prerequisites

- Python 3.8+
- Ailang compiler (`main.py` in project root)
- Ailang's x86 backend and runtime libraries
- No external Python dependencies required!

### Setup

```bash
# Clone or navigate to your Ailang project
cd /path/to/ailang/

# Verify the COBOL frontend exists
ls -la cobol_frontend/

# Expected files:
# - cobol_lexer.py
# - cobol_parser.py
# - cobol_ast_converter.py
# - cobol_integration.py
# - cobol_test_suite.py
```

## Usage

### Basic Compilation

```bash
# Compile COBOL to native binary
python3 cobol_frontend/cobol_integration.py program.cbl -o program

# Run the executable
./program_exec
```

### Debug Mode (Recommended for First Use)

```bash
# Compile with detailed pipeline output
python3 cobol_frontend/cobol_integration.py program.cbl -o program --debug
```

This shows you:
- âœ“ Tokens generated by the lexer
- âœ“ COBOL AST structure  
- âœ“ Generated Ailang AST
- âœ“ Ailang source code
- âœ“ Compilation stages

### Generate Ailang Only (No Compilation)

```bash
# Just transpile to Ailang source
python3 cobol_frontend/cobol_integration.py program.cbl --ailang-only

# This creates program.ailang which you can inspect or compile later
python3 main.py program.ailang -o program
```

### Programmatic API

```python
from cobol_frontend import COBOLIntegratedCompiler

# Create compiler instance
compiler = COBOLIntegratedCompiler(debug=True)

# Compile COBOL file
compiler.compile_file('program.cbl', 'program')
```

## Architecture

### Component Overview

```
cobol_frontend/
â”‚
â”œâ”€â”€ cobol_lexer.py           # Stage 1: COBOL Source â†’ Tokens
â”‚   â””â”€â”€ COBOLLexer class
â”‚       - Tokenizes COBOL source code
â”‚       - Handles fixed/free format
â”‚       - Case-insensitive keywords
â”‚
â”œâ”€â”€ cobol_parser.py          # Stage 2: Tokens â†’ COBOL AST
â”‚   â””â”€â”€ COBOLMultiProgramParser class
â”‚       - Builds COBOL Abstract Syntax Tree
â”‚       - Handles multiple PROGRAM-IDs per file
â”‚       - Recursive descent parser
â”‚
â”œâ”€â”€ cobol_ast_converter.py   # Stage 3-4: COBOL AST â†’ Ailang
â”‚   â”œâ”€â”€ COBOLToAilangMultiProgramConverter
â”‚   â”‚   - Converts COBOL AST to Ailang AST
â”‚   â”‚   - Type inference from PIC clauses
â”‚   â”‚   - Name normalization
â”‚   â””â”€â”€ AILangASTSerializer
â”‚       - Serializes Ailang AST to source code
â”‚       - Proper indentation and formatting
â”‚
â””â”€â”€ cobol_integration.py     # Stage 5: Orchestration
    â””â”€â”€ COBOLIntegratedCompiler
        - Manages full pipeline
        - Invokes Ailang compiler
        - Error handling and cleanup
```

### AST Node Types

**COBOL AST Nodes** (defined in `cobol_parser.py`):
- `COBOLCompilationUnit` - Container for multiple programs
- `COBOLProgram` - One COBOL program (PROGRAM-ID)
- `COBOLDataDivision` - Variable declarations
- `COBOLVariableDecl` - Individual variable with PIC clause
- `COBOLProcedureDivision` - Executable code
- `COBOLParagraph` - Named code section
- Statement nodes: `COBOLDisplay`, `COBOLMove`, `COBOLIf`, `COBOLPerform`, `COBOLCompute`, etc.

**Ailang AST Nodes** (imported from `ailang_parser/ailang_ast.py`):
- `Function` - Ailang function definition
- `DeclareVariable` - Variable declaration
- `PrintMessage` - Output statement
- `IfCondition` - Conditional logic
- `WhileLoop` - Loop construct
- `CallFunction` - Function call
- `ReturnValue` - Function return

### Type Mapping

COBOL PIC clauses are automatically converted to Ailang types:

| COBOL PIC | Ailang Type | Example |
|-----------|-------------|---------|
| `PIC 9(n)` | `Type.INT` | `PIC 9(4)` â†’ 32-bit integer |
| `PIC X(n)` | `Type.STRING` | `PIC X(30)` â†’ String |
| `PIC S9(n)` | `Type.INT` | `PIC S9(5)` â†’ Signed integer |
| `PIC A(n)` | `Type.STRING` | `PIC A(20)` â†’ Alphabetic string |

### Name Normalization

COBOL identifiers are converted to Ailang-compatible names:

```
COBOL Style         â†’  Ailang Style
-----------------------------------
MY-VARIABLE         â†’  MY_VARIABLE
EMPLOYEE-NAME       â†’  EMPLOYEE_NAME
TOTAL-AMOUNT        â†’  TOTAL_AMOUNT
```

## Supported Features

### âœ… Fully Supported

**Data Division:**
- `WORKING-STORAGE SECTION`
- Variable declarations with `PIC` clauses
- `VALUE` initialization
- Level numbers (01-49)

**Procedure Division:**
- `DISPLAY` statements (string and variable)
- `MOVE` statements
- `COMPUTE` expressions
- Arithmetic operations: `ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`
- `IF ... ELSE ... END-IF` conditionals
- `PERFORM UNTIL ... END-PERFORM` loops
- `PERFORM paragraph-name` (subroutine calls)
- Comparison operators: `=`, `>`, `<`, `>=`, `<=`, `NOT EQUAL`
- Logical operators: `AND`, `OR`, `NOT`
- `STOP RUN`, `GOBACK`

**Format Support:**
- Fixed-format COBOL (columns 1-72)
- Free-format COBOL
- Comments (`*` in column 7, `*>` anywhere)
- Multi-program files (multiple `PROGRAM-ID`s)

### ðŸš§ Coming Soon (Phase 2-3)

- `PERFORM ... TIMES` (counted loops)
- `PERFORM ... VARYING` (for loops with index)
- `EVALUATE ... WHEN` (switch/case statements)
- `STRING`/`UNSTRING` operations
- `OCCURS` clauses (arrays/tables)
- `REDEFINES` (memory overlays)
- File I/O (`FILE-CONTROL`, `OPEN`, `READ`, `WRITE`, `CLOSE`)
- `INSPECT` statement
- `CALL` for external functions

## Examples

### Example 1: Hello World

**Input** (`hello.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HELLO-WORLD.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 MESSAGE PIC X(30) VALUE "Hello from COBOL!".
       
       PROCEDURE DIVISION.
           DISPLAY MESSAGE.
           STOP RUN.
```

**Compile:**
```bash
python3 cobol_frontend/cobol_integration.py hello.cbl -o hello
./hello_exec
```

**Output:**
```
Hello from COBOL!
```

### Example 2: Arithmetic & Conditionals

**Input** (`calculate.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. CALCULATOR.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 A PIC 9(4) VALUE 100.
       01 B PIC 9(4) VALUE 50.
       01 RESULT PIC 9(5) VALUE 0.
       
       PROCEDURE DIVISION.
           COMPUTE RESULT = A + B.
           DISPLAY "Sum: ".
           DISPLAY RESULT.
           
           IF RESULT > 100
               DISPLAY "Result is large!"
           ELSE
               DISPLAY "Result is small"
           END-IF.
           
           STOP RUN.
```

**Generated Ailang** (excerpt):
```
Function.Main
    DeclareVariable.A Type.INT DefaultValue.100
    DeclareVariable.B Type.INT DefaultValue.50
    DeclareVariable.RESULT Type.INT DefaultValue.0
    
    AssignVariable.RESULT BinaryOp.Add Variable.A Variable.B
    PrintMessage "Sum: "
    PrintMessage Variable.RESULT
    
    IfCondition BinaryOp.GreaterThan Variable.RESULT Literal.100
        PrintMessage "Result is large!"
    Else
        PrintMessage "Result is small"
    EndIf
    
    ReturnValue Literal.0
```

### Example 3: Loops & Subroutines

**Input** (`loop.cbl`):
```cobol
       IDENTIFICATION DIVISION.
       PROGRAM-ID. LOOP-TEST.
       
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 COUNTER PIC 9(4) VALUE 0.
       
       PROCEDURE DIVISION.
           PERFORM MAIN-LOOP.
           STOP RUN.
       
       MAIN-LOOP.
           PERFORM UNTIL COUNTER > 5
               DISPLAY "Count: "
               DISPLAY COUNTER
               ADD 1 TO COUNTER
           END-PERFORM.
```

## Project Structure

```
ailang/
â”œâ”€â”€ main.py                          # Ailang x86 compiler
â”œâ”€â”€ ailang_parser/                   # Ailang parser & AST definitions
â”‚   â””â”€â”€ ailang_ast.py               # Ailang AST node classes
â”œâ”€â”€ ailang_compiler/                 # Ailang x86 backend
â”‚   â””â”€â”€ ...                         # Code generation, optimization
â”œâ”€â”€ aimacro_frontend/                # Python/AIMacro transpiler
â”‚   â””â”€â”€ ...
â””â”€â”€ cobol_frontend/                  # COBOL transpiler (this project)
    â”œâ”€â”€ __init__.py                 # Package exports
    â”œâ”€â”€ cobol_lexer.py              # Lexer (350 lines)
    â”œâ”€â”€ cobol_parser.py             # Parser (600 lines)
    â”œâ”€â”€ cobol_ast_converter.py      # Converter (400 lines)
    â”œâ”€â”€ cobol_integration.py        # Integration (200 lines)
    â”œâ”€â”€ cobol_test_suite.py         # Unit tests (350 lines)
    â”œâ”€â”€ README.md                   # This file
    â””â”€â”€ tests/
        â”œâ”€â”€ hello.cbl               # Sample: Hello World
        â”œâ”€â”€ calculate.cbl           # Sample: Arithmetic
        â”œâ”€â”€ loop.cbl                # Sample: Loops
        â””â”€â”€ occurs.cbl              # Sample: Arrays (WIP)
```

## Development

### Running Tests

```bash
# Run full test suite
python3 cobol_frontend/cobol_test_suite.py

# Test individual components
python3 -m cobol_frontend.cobol_lexer    # Lexer tests
python3 -m cobol_frontend.cobol_parser   # Parser tests
```

### Adding New Features

1. **Add COBOL AST node** in `cobol_parser.py`
2. **Update parser** to recognize new syntax
3. **Add Ailang conversion** in `cobol_ast_converter.py`
4. **Write test case** in `cobol_test_suite.py`
5. **Update documentation**

### Debugging Tips

```bash
# Step 1: Use --debug to see all stages
python3 cobol_frontend/cobol_integration.py program.cbl -o program --debug

# Step 2: Inspect generated Ailang
cat program.ailang

# Step 3: Test Ailang compilation separately
python3 main.py program.ailang -o program

# Step 4: Check for COBOL syntax errors
# - Ensure periods (.) end statements
# - Check column alignment (fixed-format)
# - Verify keyword spelling
```

### Performance Metrics

- **Lexing:** < 1ms for typical programs
- **Parsing:** < 5ms for typical programs  
- **Conversion:** < 1ms for typical programs
- **Ailang Compilation:** Depends on program size

Total overhead of COBOL frontend: **~10-20ms** for most programs.

## Comparison: COBOL vs AIMacro Frontend

| Aspect | AIMacro | COBOL |
|--------|---------|-------|
| **Source Language** | Python-like | COBOL-74/85 |
| **Lexer Complexity** | Simple | Moderate (fixed/free format) |
| **Parser Type** | Recursive descent | Recursive descent |
| **Type System** | Inferred | PIC clauses â†’ explicit |
| **Functions** | `def name():` | Paragraphs |
| **Naming Convention** | `snake_case` | `HYPHEN-CASE` â†’ `UPPER_CASE` |
| **Lines of Code** | ~1500 | ~1600 |
| **Target Language** | Ailang | Ailang (same) |
| **Output Format** | `.ailang` source | `.ailang` source |
| **Backend Compiler** | `main.py` | `main.py` (same x86 backend) |

Both transpilers share the same Ailang backend and follow identical architectural patterns!

## Known Limitations

1. **Decimal Arithmetic:** Currently truncates to integers (COMP-3 not yet supported)
2. **File I/O:** `FILE-CONTROL` section not yet implemented
3. **Arrays:** `OCCURS` clause partially supported
4. **Advanced PIC:** Some complex PICTURE formats not fully supported
5. **COPY Statements:** Include files not yet supported
6. **REDEFINES:** Memory overlays not yet implemented

## License

Part of the Ailang project. See main project LICENSE.

## Contributing

Contributions welcome! Please:
1. Write tests for new features
2. Follow existing code style
3. Update documentation
4. Test with `--debug` mode

## Credits

Built as a companion to the AIMacro (Python) transpiler, demonstrating Ailang's capability as a compilation target for legacy languages.
