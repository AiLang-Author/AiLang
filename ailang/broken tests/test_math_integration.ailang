// test_math_integration_fixed.ailang
// Integration test with corrected pool syntax

PrintMessage("Math Integration Test")
PrintMessage("=====================")

// === Test with Pools ===
PrintMessage("[1] Math with Pools")

FixedPool.MathData {
    "min_value": Initialize=0,
    "max_value": Initialize=100,
    "alignment": Initialize=16
}

// Set min_value to -10 after initialization
MathData.min_value = -10

// Use Min/Max with pool values
clamped = Clamp(50, MathData.min_value, MathData.max_value)
PrintMessage("  Clamp(50, -10, 100) = ")
PrintNumber(clamped)
DebugAssert(EqualTo(clamped, 50), "Clamp with pool values")

// === Test with Functions ===
PrintMessage("[2] Math in Functions")

Function.Utils.SafeDivide {
    Input: numerator: Integer
    Input: denominator: Integer
    Output: Integer
    Body: {
        // Use Sign to check for zero
        is_zero = EqualTo(Sign(denominator), 0)
        IfCondition is_zero ThenBlock: {
            ReturnValue(0)  // Return 0 for divide by zero
        }
        result = Divide(numerator, denominator)
        ReturnValue(result)
    }
}

safe1 = Utils.SafeDivide(10, 2)
safe2 = Utils.SafeDivide(10, 0)
PrintMessage("  SafeDivide(10, 2) = ")
PrintNumber(safe1)
PrintMessage("  SafeDivide(10, 0) = ")
PrintNumber(safe2)
DebugAssert(EqualTo(safe1, 5), "Safe divide normal")
DebugAssert(EqualTo(safe2, 0), "Safe divide by zero")

// === Test with Arrays ===
PrintMessage("[3] Math with Arrays")

// Create array and find min/max
arr = ArrayCreate(5)
ArraySet(arr, 0, 42)
ArraySet(arr, 1, 17)
ArraySet(arr, 2, 99)
ArraySet(arr, 3, 3)
ArraySet(arr, 4, 67)

// Find min and max of first two elements
val1 = ArrayGet(arr, 0)
val2 = ArrayGet(arr, 1)
min_val = Min(val1, val2)
max_val = Max(val1, val2)

PrintMessage("  Min(arr[0], arr[1]) = ")
PrintNumber(min_val)
PrintMessage("  Max(arr[0], arr[1]) = ")
PrintNumber(max_val)
DebugAssert(EqualTo(min_val, 17), "Array min")
DebugAssert(EqualTo(max_val, 42), "Array max")

// === Test Direct Negative Numbers ===
PrintMessage("[4] Negative Number Tests")

// Test with your unary minus
neg5 = -5
neg10 = -10
pos5 = 5

min_neg = Min(neg10, pos5)
PrintMessage("  Min(-10, 5) = ")
PrintNumber(min_neg)
DebugAssert(EqualTo(min_neg, neg10), "Min with negative")

max_neg = Max(neg10, pos5)
PrintMessage("  Max(-10, 5) = ")
PrintNumber(max_neg)
DebugAssert(EqualTo(max_neg, 5), "Max with negative")

// === Test Bit Operations ===
PrintMessage("[5] Bit Operations")

// PopCount tests
pop1 = PopCount(7)  // Binary: 111
PrintMessage("  PopCount(7) = ")
PrintNumber(pop1)
DebugAssert(EqualTo(pop1, 3), "Three bits set")

pop2 = PopCount(255)  // Binary: 11111111
PrintMessage("  PopCount(255) = ")
PrintNumber(pop2)
DebugAssert(EqualTo(pop2, 8), "Eight bits set")

// === Test Power of 2 Detection ===
PrintMessage("[6] Power of 2 Detection")

pow1 = IsPowerOfTwo(8)
PrintMessage("  IsPowerOfTwo(8) = ")
PrintNumber(pow1)
DebugAssert(EqualTo(pow1, 1), "8 is power of 2")

pow2 = IsPowerOfTwo(7)
PrintMessage("  IsPowerOfTwo(7) = ")
PrintNumber(pow2)
DebugAssert(EqualTo(pow2, 0), "7 is not power of 2")

// Test NextPowerOfTwo
next1 = NextPowerOfTwo(5)
PrintMessage("  NextPowerOfTwo(5) = ")
PrintNumber(next1)
DebugAssert(EqualTo(next1, 8), "Next power after 5")

// === Test Sign Function ===
PrintMessage("[7] Sign Function")

sign1 = Sign(42)
sign2 = Sign(0)
sign3 = Sign(-42)

PrintMessage("  Sign(42) = ")
PrintNumber(sign1)
DebugAssert(EqualTo(sign1, 1), "Sign positive")

PrintMessage("  Sign(0) = ")
PrintNumber(sign2)
DebugAssert(EqualTo(sign2, 0), "Sign zero")

PrintMessage("  Sign(-42) = ")
PrintNumber(sign3)
DebugAssert(EqualTo(sign3, -1), "Sign negative")

PrintMessage("")
PrintMessage("=====================")
PrintMessage("All integration tests PASSED!")