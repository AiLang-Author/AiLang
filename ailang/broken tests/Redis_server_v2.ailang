// redis_server_v2.ailang
// A clean, single-threaded, feature-complete Redis server.
// This is our template for building the concurrent version.

LibraryImport.Library.RESP
LibraryImport.Library.XArrays

// Global data store for the server
store = XSHash.XCreate(1024)

// Global server socket descriptor
server_socket = 0

// State for stream ID generation
FixedPool.StreamState {
    "last_id_ms": Initialize=0
}

// Type constants for our Redis-like objects
FixedPool.DataTypes {
    "TYPE_STRING": Initialize=0
    "TYPE_LIST": Initialize=1
    "TYPE_STREAM": Initialize=2
    "TYPE_SET": Initialize=3
}

// Define standard system call numbers for clarity and maintainability
FixedPool.SyscallNumbers {
    "TIME": Initialize=201
}

// Helper function to convert string to integer
Function.Helpers.StringToInt {
    Input: str:
    Body: {
        result = 0
        i = 0
        len = StringLength(str)
        negative = 0
        
        IfCondition GreaterThan(len, 0) ThenBlock: {
            first = GetByte(str, 0)
            IfCondition EqualTo(first, 45) ThenBlock: {
                negative = 1
                i = 1
            }
        }
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            IfCondition And(GreaterEqual(byte, 48), LessEqual(byte, 57)) ThenBlock: {
                digit = Subtract(byte, 48)
                result = Multiply(result, 10)
                result = Add(result, digit)
            }
            i = Add(i, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Helper to convert integer to string
Function.Helpers.IntToString {
    Input: num:
    Body: {
        buffer = Allocate(32)
        pos = 0
        value = num
        
        IfCondition LessThan(value, 0) ThenBlock: {
            SetByte(buffer, pos, 45)
            pos = Add(pos, 1)
            value = Subtract(0, value)
        }
        
        IfCondition EqualTo(value, 0) ThenBlock: {
            SetByte(buffer, pos, 48)
            pos = Add(pos, 1)
            SetByte(buffer, pos, 0)
            ReturnValue(buffer)
        }
        
        start_pos = pos
        WhileLoop GreaterThan(value, 0) {
            digit = Modulo(value, 10)
            SetByte(buffer, pos, Add(48, digit))
            pos = Add(pos, 1)
            value = Divide(value, 10)
        }
        
        end_pos = Subtract(pos, 1)
        WhileLoop LessThan(start_pos, end_pos) {
            temp = GetByte(buffer, start_pos)
            SetByte(buffer, start_pos, GetByte(buffer, end_pos))
            SetByte(buffer, end_pos, temp)
            start_pos = Add(start_pos, 1)
            end_pos = Subtract(end_pos, 1)
        }
        
        SetByte(buffer, pos, 0)
        ReturnValue(buffer)
    }
}

// Helper to parse a stream ID string "ms-seq"
Function.Helpers.ParseStreamID {
    Input: id_str: Address
    Output: Address
    Body: {
        dash_pos = StringIndexOf(id_str, "-")
        IfCondition EqualTo(dash_pos, -1) ThenBlock: { ReturnValue(0) }
        
        ms_str = StringSubstring(id_str, 0, dash_pos)
        ms_val = Helpers.StringToInt(ms_str)
        Deallocate(ms_str, 0)
        
        len = StringLength(id_str)
        seq_start = Add(dash_pos, 1)
        seq_len = Subtract(len, seq_start)
        seq_str = StringSubstring(id_str, seq_start, seq_len)
        seq_val = Helpers.StringToInt(seq_str)
        Deallocate(seq_str, 0)
        
        result_arr = XArray.XCreate(2)
        XArray.XPush(result_arr, ms_val)
        XArray.XPush(result_arr, seq_val)
        ReturnValue(result_arr)
    }
}

// Helper to compare two stream ID strings
Function.Helpers.CompareStreamIDs {
    Input: id1_str: Address
    Input: id2_str: Address
    Output: Integer
    Body: {
        id1_parts = Helpers.ParseStreamID(id1_str)
        id2_parts = Helpers.ParseStreamID(id2_str)
        
        IfCondition Or(EqualTo(id1_parts, 0), EqualTo(id2_parts, 0)) ThenBlock: { ReturnValue(-2) }
        
        id1_ms = XArray.XGet(id1_parts, 0)
        id1_seq = XArray.XGet(id1_parts, 1)
        id2_ms = XArray.XGet(id2_parts, 0)
        id2_seq = XArray.XGet(id2_parts, 1)
        
        XArray.XDestroy(id1_parts)
        XArray.XDestroy(id2_parts)
        
        result = 0
        IfCondition GreaterThan(id1_ms, id2_ms) ThenBlock: { result = 1 }
        ElseBlock: {
            IfCondition LessThan(id1_ms, id2_ms) ThenBlock: { result = -1 }
            ElseBlock: {
                IfCondition GreaterThan(id1_seq, id2_seq) ThenBlock: { result = 1 }
                IfCondition LessThan(id1_seq, id2_seq) ThenBlock: { result = -1 }
            }
        }
        ReturnValue(result)
    }
}

// Helper to create a copy of a string
Function.Helpers.StringCopy {
    Input: src: Address
    Output: Address
    Body: {
        IfCondition EqualTo(src, 0) ThenBlock: { ReturnValue(0) }
        
        len = StringLength(src)
        new_str = Allocate(Add(len, 1))
        MemoryCopy(new_str, src, len)
        SetByte(new_str, len, 0)
        ReturnValue(new_str)
    }
}

// Helper to get the system time in milliseconds.
Function.Helpers.GetSystemTime {
    Output: Integer
    Body: {
        time_in_seconds = SystemCall(SyscallNumbers.TIME, 0)
        time_in_ms = Multiply(time_in_seconds, 1000)
        ReturnValue(time_in_ms)
    }
}

// Helper to check for and handle key expiration (passive eviction)
Function.Helpers.CheckAndEvictExpiredKey {
    Input: key: Address
    Input: wrapper: Address
    Output: Integer
    Body: {
        expiration_ms = Dereference(Add(wrapper, 8))
        IfCondition NotEqual(expiration_ms, 0) ThenBlock: {
            now = Helpers.GetSystemTime()
            IfCondition LessThan(expiration_ms, now) ThenBlock: {
                deleted_wrapper = XSHash.XDelete(store, key)
                IfCondition NotEqual(deleted_wrapper, XArrays.XNULL) ThenBlock: {
                    type = Dereference(deleted_wrapper)
                    value_ptr = Dereference(Add(deleted_wrapper, 16))
                    
                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                    IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                    IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                    IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                    
                    Deallocate(deleted_wrapper, 0)
                }
                ReturnValue(1)
            }
        }
        ReturnValue(0)
    }
}

// --- START: Pipelining-aware RESP Parser ---
Function.Helpers.Internal.FindCRLF {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Integer
    Body: {
        i = offset
        limit = Subtract(length, 1)
        WhileLoop LessThan(i, limit) {
            char1 = GetByte(buffer, i)
            IfCondition EqualTo(char1, 13) ThenBlock: {
                char2 = GetByte(buffer, Add(i, 1))
                IfCondition EqualTo(char2, 10) ThenBlock: { ReturnValue(i) }
            }
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

Function.Helpers.Internal.ParseIntFromSlice {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        result = 0
        i = start
        negative = 0
        first_char = GetByte(buffer, i)
        IfCondition EqualTo(first_char, 45) ThenBlock: {
            negative = 1
            i = Add(i, 1)
        }
        WhileLoop LessThan(i, end) {
            byte = GetByte(buffer, i)
            digit = Subtract(byte, 48)
            result = Multiply(result, 10)
            result = Add(result, digit)
            i = Add(i, 1)
        }
        IfCondition negative ThenBlock: { result = Subtract(0, result) }
        ReturnValue(result)
    }
}

Function.Helpers.Internal.ParseValue {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Address
    Body: {
        IfCondition GreaterEqual(offset, length) ThenBlock: {
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, 0)
            XArray.XPush(res_arr, 0)
            ReturnValue(res_arr)
        }
        type_char = GetByte(buffer, offset)
        IfCondition EqualTo(type_char, 36) ThenBlock: {
            line_end_pos = Helpers.Internal.FindCRLF(buffer, length, offset)
            IfCondition EqualTo(line_end_pos, -1) ThenBlock: {
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            str_len = Helpers.Internal.ParseIntFromSlice(buffer, Add(offset, 1), line_end_pos)
            IfCondition EqualTo(str_len, -1) ThenBlock: {
                total_consumed = Add(Subtract(line_end_pos, offset), 2)
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, total_consumed)
                ReturnValue(res_arr)
            }
            data_start = Add(line_end_pos, 2)
            total_needed = Add(data_start, Add(str_len, 2))
            IfCondition GreaterThan(total_needed, length) ThenBlock: {
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            new_str = Allocate(Add(str_len, 1))
            data_ptr = Add(buffer, data_start)
            MemoryCopy(new_str, data_ptr, str_len)
            SetByte(new_str, str_len, 0)
            total_consumed = Subtract(total_needed, offset)
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, new_str)
            XArray.XPush(res_arr, total_consumed)
            ReturnValue(res_arr)
        }
        IfCondition EqualTo(type_char, 42) ThenBlock: {
            line_end_pos = Helpers.Internal.FindCRLF(buffer, length, offset)
            IfCondition EqualTo(line_end_pos, -1) ThenBlock: {
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }
            array_len = Helpers.Internal.ParseIntFromSlice(buffer, Add(offset, 1), line_end_pos)
            IfCondition LessThan(array_len, 0) ThenBlock: {
                // Negative array length is invalid, treat as a parse error.
                res_arr = XArray.XCreate(2)
                XArray.XPush(res_arr, 0)
                XArray.XPush(res_arr, 0)
                ReturnValue(res_arr)
            }

            parsed_elements = XArray.XCreate(array_len)
            current_offset = Add(line_end_pos, 2)
            i = 0
            WhileLoop LessThan(i, array_len) {
                element_res = Helpers.Internal.ParseValue(buffer, length, current_offset)
                element_val = XArray.XGet(element_res, 0)
                consumed = XArray.XGet(element_res, 1)
                IfCondition EqualTo(consumed, 0) ThenBlock: {
                    j = 0
                    parsed_count = XArray.XSize(parsed_elements)
                    WhileLoop LessThan(j, parsed_count) {
                        item = XArray.XGet(parsed_elements, j)
                        Deallocate(item, 0)
                        j = Add(j, 1)
                    }
                    XArray.XDestroy(parsed_elements)
                    XArray.XDestroy(element_res)
                    res_arr = XArray.XCreate(2)
                    XArray.XPush(res_arr, 0)
                    XArray.XPush(res_arr, 0)
                    ReturnValue(res_arr)
                }
                XArray.XPush(parsed_elements, element_val)
                current_offset = Add(current_offset, consumed)
                XArray.XDestroy(element_res)
                i = Add(i, 1)
            }
            total_consumed = Subtract(current_offset, offset)
            res_arr = XArray.XCreate(2)
            XArray.XPush(res_arr, parsed_elements)
            XArray.XPush(res_arr, total_consumed)
            ReturnValue(res_arr)
        }
        res_arr = XArray.XCreate(2)
        XArray.XPush(res_arr, 0)
        XArray.XPush(res_arr, 0)
        ReturnValue(res_arr)
    }
}

Function.Helpers.ParsePipelinedArray {
    Input: buffer: Address
    Input: length: Integer
    Input: offset: Integer
    Output: Address
    Body: {
        parse_result = Helpers.Internal.ParseValue(buffer, length, offset)
        parsed_value = XArray.XGet(parse_result, 0)
        bytes_consumed = XArray.XGet(parse_result, 1)
        IfCondition EqualTo(bytes_consumed, 0) ThenBlock: {
            XArray.XDestroy(parse_result)
            final_res = XArray.XCreate(2)
            XArray.XPush(final_res, 0)
            XArray.XPush(final_res, 0)
            ReturnValue(final_res)
        }
        num_elements = XArray.XSize(parsed_value)
        native_array = ArrayCreate(num_elements)
        i = 0
        WhileLoop LessThan(i, num_elements) {
            element_str = XArray.XGet(parsed_value, i)
            ArraySet(native_array, i, element_str)
            i = Add(i, 1)
        }
        XArray.XDestroy(parsed_value)
        XArray.XDestroy(parse_result)
        final_res = XArray.XCreate(2)
        XArray.XPush(final_res, native_array)
        XArray.XPush(final_res, bytes_consumed)
        ReturnValue(final_res)
    }
}
// --- END: Pipelining-aware RESP Parser ---

Function.Server.HandleClient {
    Input: client_socket: Integer
    Body: {
        Debug("client.connect", level=1) { PrintMessage("[DEBUG] New client connected.") }
        buffer = Allocate(4096)
        buffer_data_len = 0
        buffer_offset = 0
        client_connected = 1
        WhileLoop client_connected {
            WhileLoop And(client_connected, LessThan(buffer_offset, buffer_data_len)) {
                parse_result = Helpers.ParsePipelinedArray(buffer, buffer_data_len, buffer_offset)
                command_array = XArray.XGet(parse_result, 0)
                bytes_consumed = XArray.XGet(parse_result, 1)
                XArray.XDestroy(parse_result)
                IfCondition EqualTo(bytes_consumed, 0) ThenBlock: { BreakLoop }
                buffer_offset = Add(buffer_offset, bytes_consumed)
                IfCondition NotEqual(command_array, 0) ThenBlock: {
                    array_len = ArrayLength(command_array)
                    IfCondition GreaterThan(array_len, 0) ThenBlock: {
                        cmd_str = ArrayGet(command_array, 0)
                        command = StringToUpper(cmd_str)
                        Debug("command.parse", level=1) {
                            PrintMessage("[DEBUG] Parsed command:")
                            PrintMessage(command)
                        }
                        command_handled = 0
                        response = 0
                        
                        // --- START COMMAND DISPATCH ---
                        
                        is_ping = StringCompare(command, "PING")
                        IfCondition EqualTo(is_ping, 0) ThenBlock: {
                            response = RESP.SimpleString("PONG")
                            command_handled = 1
                        }
                        is_echo = StringCompare(command, "ECHO")
                        IfCondition And(EqualTo(is_echo, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            echo_msg = ArrayGet(command_array, 1)
                            response = RESP.BulkString(echo_msg)
                            command_handled = 1
                        }
                        is_set = StringCompare(command, "SET")
                        IfCondition And(EqualTo(is_set, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            value = ArrayGet(command_array, 2)
                            old_value_wrapper = XSHash.XDelete(store, key)
                            is_found = NotEqual(old_value_wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(old_value_wrapper)
                                value_ptr = Dereference(Add(old_value_wrapper, 16))
                                IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                                Deallocate(old_value_wrapper, 0)
                            }
                            new_wrapper = Allocate(24)
                            StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                            StoreValue(Add(new_wrapper, 8), 0)
                            value_copy = Helpers.StringCopy(value)
                            StoreValue(Add(new_wrapper, 16), value_copy)
                            XSHash.XInsert(store, key, new_wrapper)
                            response = RESP.SimpleString("OK")
                            command_handled = 1
                        }
                        is_get = StringCompare(command, "GET")
                        IfCondition And(EqualTo(is_get, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                is_expired = Helpers.CheckAndEvictExpiredKey(key, wrapper)
                                IfCondition is_expired ThenBlock: {
                                    response = RESP.BulkString(0)
                                } ElseBlock: {
                                    type = Dereference(wrapper)
                                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: {
                                        value_ptr = Dereference(Add(wrapper, 16))
                                        response = RESP.BulkString(value_ptr)
                                    } ElseBlock: {
                                        response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                    }
                                }
                            } ElseBlock: {
                                response = RESP.BulkString(0)
                            }
                            command_handled = 1
                        }
                        is_del = StringCompare(command, "DEL")
                        IfCondition And(EqualTo(is_del, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            value_wrapper_ptr = XSHash.XDelete(store, key)
                            is_found = NotEqual(value_wrapper_ptr, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(value_wrapper_ptr)
                                value_ptr = Dereference(Add(value_wrapper_ptr, 16))
                                IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                                Deallocate(value_wrapper_ptr, 0)
                                response = RESP.Integer(1)
                            } ElseBlock: {
                                response = RESP.Integer(0)
                            }
                            command_handled = 1
                        }
                        is_sadd = StringCompare(command, "SADD")
                        IfCondition And(EqualTo(is_sadd, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            set_ptr = 0
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_SET) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    set_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                set_ptr = XSHash.XCreate(16)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_SET)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), set_ptr)
                                XSHash.XInsert(store, key, new_wrapper)
                            }
                            IfCondition NotEqual(set_ptr, 0) ThenBlock: {
                                added_count = 0
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    member = ArrayGet(command_array, i)
                                    exists = XSHash.XExists(set_ptr, member)
                                    IfCondition Not(exists) ThenBlock: {
                                        XSHash.XInsert(set_ptr, member, 1)
                                        added_count = Add(added_count, 1)
                                    }
                                    i = Add(i, 1)
                                }
                                response = RESP.Integer(added_count)
                            }
                            command_handled = 1
                        }
                        is_smembers = StringCompare(command, "SMEMBERS")
                        IfCondition And(EqualTo(is_smembers, 0), EqualTo(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition Not(is_found) ThenBlock: {
                                response = RESP.Array(ArrayCreate(0))
                            } ElseBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_SET) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    set_ptr = Dereference(Add(wrapper, 16))
                                    keys_xarray = XSHash.XKeys(set_ptr)
                                    num_members = XArray.XSize(keys_xarray)
                                    members_array = ArrayCreate(num_members)
                                    i = 0
                                    WhileLoop LessThan(i, num_members) {
                                        member_str = XArray.XGet(keys_xarray, i)
                                        ArraySet(members_array, i, member_str)
                                        i = Add(i, 1)
                                    }
                                    response = RESP.Array(members_array)
                                    ArrayDestroy(members_array)
                                    i = 0
                                    WhileLoop LessThan(i, num_members) {
                                        member_str = XArray.XGet(keys_xarray, i)
                                        Deallocate(member_str, 0)
                                        i = Add(i, 1)
                                    }
                                    XArray.XDestroy(keys_xarray)
                                }
                            }
                            command_handled = 1
                        }
                        is_exists = StringCompare(command, "EXISTS")
                        IfCondition And(EqualTo(is_exists, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            exists = XSHash.XExists(store, key)
                            response = RESP.Integer(exists)
                            command_handled = 1
                        }
                        is_incr = StringCompare(command, "INCR")
                        IfCondition And(EqualTo(is_incr, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    val_str = Dereference(Add(wrapper, 16))
                                    current = Helpers.StringToInt(val_str)
                                    new_val = Add(current, 1)
                                    new_str = Helpers.IntToString(new_val)
                                    Deallocate(val_str, 0)
                                    StoreValue(Add(wrapper, 16), new_str)
                                    response = RESP.Integer(new_val)
                                }
                            } ElseBlock: {
                                new_val = 1
                                new_str = Helpers.IntToString(new_val)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), new_str)
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.Integer(new_val)
                            }
                            command_handled = 1
                        }
                        is_decr = StringCompare(command, "DECR")
                        IfCondition And(EqualTo(is_decr, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_STRING) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    val_str = Dereference(Add(wrapper, 16))
                                    current = Helpers.StringToInt(val_str)
                                    new_val = Subtract(current, 1)
                                    new_str = Helpers.IntToString(new_val)
                                    Deallocate(val_str, 0)
                                    StoreValue(Add(wrapper, 16), new_str)
                                    response = RESP.Integer(new_val)
                                }
                            } ElseBlock: {
                                new_val = -1
                                new_str = Helpers.IntToString(new_val)
                                new_wrapper = Allocate(24)
                                StoreValue(new_wrapper, DataTypes.TYPE_STRING)
                                StoreValue(Add(new_wrapper, 8), 0)
                                StoreValue(Add(new_wrapper, 16), new_str)
                                XSHash.XInsert(store, key, new_wrapper)
                                response = RESP.Integer(new_val)
                            }
                            command_handled = 1
                        }
                        is_lpush = StringCompare(command, "LPUSH")
                        IfCondition And(EqualTo(is_lpush, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            list_ptr = 0
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    list_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                list_ptr = XList.XCreate()
                                wrapper = Allocate(24)
                                StoreValue(wrapper, DataTypes.TYPE_LIST)
                                StoreValue(Add(wrapper, 8), 0)
                                StoreValue(Add(wrapper, 16), list_ptr)
                                XSHash.XInsert(store, key, wrapper)
                            }
                            IfCondition NotEqual(list_ptr, 0) ThenBlock: {
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    value_to_push = ArrayGet(command_array, i)
                                    value_copy = Helpers.StringCopy(value_to_push)
                                    XList.XPrepend(list_ptr, value_copy)
                                    i = Add(i, 1)
                                }
                                new_len = XList.XSize(list_ptr)
                                response = RESP.Integer(new_len)
                            }
                            command_handled = 1
                        }
                        is_rpush = StringCompare(command, "RPUSH")
                        IfCondition And(EqualTo(is_rpush, 0), GreaterEqual(array_len, 3)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            list_ptr = 0
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition is_found ThenBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    list_ptr = Dereference(Add(wrapper, 16))
                                }
                            } ElseBlock: {
                                list_ptr = XList.XCreate()
                                wrapper = Allocate(24)
                                StoreValue(wrapper, DataTypes.TYPE_LIST)
                                StoreValue(Add(wrapper, 8), 0)
                                StoreValue(Add(wrapper, 16), list_ptr)
                                XSHash.XInsert(store, key, wrapper)
                            }
                            IfCondition NotEqual(list_ptr, 0) ThenBlock: {
                                i = 2
                                WhileLoop LessThan(i, array_len) {
                                    value_to_push = ArrayGet(command_array, i)
                                    value_copy = Helpers.StringCopy(value_to_push)
                                    XList.XAppend(list_ptr, value_copy)
                                    i = Add(i, 1)
                                }
                                new_len = XList.XSize(list_ptr)
                                response = RESP.Integer(new_len)
                            }
                            command_handled = 1
                        }
                        is_lrange = StringCompare(command, "LRANGE")
                        IfCondition And(EqualTo(is_lrange, 0), GreaterEqual(array_len, 4)) ThenBlock: {
                            key = ArrayGet(command_array, 1)
                            wrapper = XSHash.XLookup(store, key)
                            is_found = NotEqual(wrapper, XArrays.XNULL)
                            IfCondition Not(is_found) ThenBlock: {
                                empty_arr = ArrayCreate(0)
                                response = RESP.Array(empty_arr)
                                ArrayDestroy(empty_arr)
                            } ElseBlock: {
                                type = Dereference(wrapper)
                                IfCondition NotEqual(type, DataTypes.TYPE_LIST) ThenBlock: {
                                    response = RESP.Error("WRONGTYPE Operation against a key holding the wrong kind of value")
                                } ElseBlock: {
                                    list_ptr = Dereference(Add(wrapper, 16))
                                    start_str = ArrayGet(command_array, 2)
                                    stop_str = ArrayGet(command_array, 3)
                                    start_idx = Helpers.StringToInt(start_str)
                                    stop_idx = Helpers.StringToInt(stop_str)
                                    list_size = XList.XSize(list_ptr)
                                    IfCondition LessThan(start_idx, 0) ThenBlock: { start_idx = Add(list_size, start_idx) }
                                    IfCondition LessThan(stop_idx, 0) ThenBlock: { stop_idx = Add(list_size, stop_idx) }
                                    IfCondition LessThan(start_idx, 0) ThenBlock: { start_idx = 0 }
                                    IfCondition GreaterEqual(stop_idx, list_size) ThenBlock: { stop_idx = Subtract(list_size, 1) }
                                    range_len = 0
                                    IfCondition LessEqual(start_idx, stop_idx) ThenBlock: { range_len = Add(Subtract(stop_idx, start_idx), 1) }
                                    results_array = ArrayCreate(range_len)
                                    IfCondition GreaterThan(range_len, 0) ThenBlock: {
                                        current_node = Dereference(list_ptr)
                                        i = 0
                                        WhileLoop LessThan(i, start_idx) {
                                            current_node = Dereference(Add(current_node, 8))
                                            i = Add(i, 1)
                                        }
                                        i = 0
                                        WhileLoop LessThan(i, range_len) {
                                            element = Dereference(current_node)
                                            ArraySet(results_array, i, element)
                                            current_node = Dereference(Add(current_node, 8))
                                            i = Add(i, 1)
                                        }
                                    }
                                    response = RESP.Array(results_array)
                                    ArrayDestroy(results_array)
                                }
                            }
                            command_handled = 1
                        }
                        is_quit = StringCompare(command, "QUIT")
                        IfCondition EqualTo(is_quit, 0) ThenBlock: {
                            response = RESP.SimpleString("OK")
                            client_connected = 0
                            command_handled = 1
                        }
                        is_config = StringCompare(command, "CONFIG")
                        IfCondition And(EqualTo(is_config, 0), GreaterEqual(array_len, 2)) ThenBlock: {
                            subcommand = ArrayGet(command_array, 1)
                            subcommand_upper = StringToUpper(subcommand)
                            is_get = StringCompare(subcommand_upper, "GET")
                            IfCondition EqualTo(is_get, 0) ThenBlock: {
                                IfCondition GreaterEqual(array_len, 3) ThenBlock: {
                                    param = ArrayGet(command_array, 2)
                                    is_save = StringCompare(param, "save")
                                    is_appendonly = StringCompare(param, "appendonly")
                                    is_wildcard = StringCompare(param, "*")
                                    IfCondition EqualTo(is_save, 0) ThenBlock: {
                                        config_array = ArrayCreate(2)
                                        ArraySet(config_array, 0, "save")
                                        ArraySet(config_array, 1, "")
                                        response = RESP.Array(config_array)
                                        ArrayDestroy(config_array)
                                    } ElseBlock: {
                                        IfCondition EqualTo(is_appendonly, 0) ThenBlock: {
                                            config_array = ArrayCreate(2)
                                            ArraySet(config_array, 0, "appendonly")
                                            ArraySet(config_array, 1, "no")
                                            response = RESP.Array(config_array)
                                            ArrayDestroy(config_array)
                                        } ElseBlock: {
                                            IfCondition EqualTo(is_wildcard, 0) ThenBlock: {
                                                config_array = ArrayCreate(4)
                                                ArraySet(config_array, 0, "save")
                                                ArraySet(config_array, 1, "")
                                                ArraySet(config_array, 2, "appendonly")
                                                ArraySet(config_array, 3, "no")
                                                response = RESP.Array(config_array)
                                                ArrayDestroy(config_array)
                                            } ElseBlock: {
                                                empty_array = ArrayCreate(0)
                                                response = RESP.Array(empty_array)
                                                ArrayDestroy(empty_array)
                                            }
                                        }
                                    }
                                } ElseBlock: {
                                    empty_array = ArrayCreate(0)
                                    response = RESP.Array(empty_array)
                                    ArrayDestroy(empty_array)
                                }
                            }
                            is_set = StringCompare(subcommand_upper, "SET")
                            IfCondition EqualTo(is_set, 0) ThenBlock: {
                                response = RESP.SimpleString("OK")
                            }
                            command_handled = 1
                        }
                        is_flushdb = StringCompare(command, "FLUSHDB")
                        IfCondition EqualTo(is_flushdb, 0) ThenBlock: {
                            bucket_count = Dereference(store)
                            buckets = Dereference(Add(store, 16))
                            i = 0
                            WhileLoop LessThan(i, bucket_count) { 
                                current_node = Dereference(Add(buckets, Multiply(i, 8)))
                                WhileLoop NotEqual(current_node, 0) {
                                    // FIX: Save the next node's pointer before we deallocate anything
                                    // related to the current node. This prevents use-after-free bugs.
                                    next_node = Dereference(Add(current_node, 16))

                                    value_wrapper_ptr = Dereference(Add(current_node, 8))
                                    type = Dereference(value_wrapper_ptr)
                                    value_ptr = Dereference(Add(value_wrapper_ptr, 16))
                                    IfCondition EqualTo(type, DataTypes.TYPE_STRING) ThenBlock: { Deallocate(value_ptr, 0) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_LIST) ThenBlock: { XList.XDestroyDeep(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_SET) ThenBlock: { XSHash.XDestroy(value_ptr) }
                                    IfCondition EqualTo(type, DataTypes.TYPE_STREAM) ThenBlock: { XStream.XDestroy(value_ptr) }
                                    Deallocate(value_wrapper_ptr, 0)
                                    // The XSHash.XDestroy below will free the node and its key.
                                    // We just need to advance our pointer for the loop.
                                    current_node = next_node
                                }
                                i = Add(i, 1)
                            }
                            XSHash.XDestroy(store)
                            store = XSHash.XCreate(1024)
                            response = RESP.SimpleString("OK")
                            command_handled = 1
                        }
                        is_dbsize = StringCompare(command, "DBSIZE")
                        IfCondition EqualTo(is_dbsize, 0) ThenBlock: {
                            key_count = Dereference(Add(store, 8))
                            response = RESP.Integer(key_count)
                            command_handled = 1
                        }
                        
                        // --- END COMMAND DISPATCH ---
                        
                        IfCondition NotEqual(response, -1) ThenBlock: {
                            IfCondition command_handled ThenBlock: {
                                IfCondition NotEqual(response, 0) ThenBlock: {
                                    response_len = StringLength(response)
                                    SocketWrite(client_socket, response, response_len)
                                    Deallocate(response, 0)
                                }
                            } ElseBlock: {
                                error_msg = RESP.Error("unknown command")
                                error_len = StringLength(error_msg)
                                SocketWrite(client_socket, error_msg, error_len)
                                Deallocate(error_msg, 0)
                            }
                        }
                        i = 0
                        WhileLoop LessThan(i, array_len) {
                            element = ArrayGet(command_array, i)
                            IfCondition NotEqual(element, 0) ThenBlock: { Deallocate(element, 0) }
                            i = Add(i, 1)
                        }
                    }
                    ArrayDestroy(command_array)
                } ElseBlock: {
                    client_connected = 0
                }
            }
            IfCondition client_connected ThenBlock: {
                IfCondition EqualTo(buffer_offset, buffer_data_len) ThenBlock: {
                    buffer_offset = 0
                    buffer_data_len = 0
                } ElseBlock: {
                    remaining_data = Subtract(buffer_data_len, buffer_offset)
                    MemoryCopy(buffer, Add(buffer, buffer_offset), remaining_data)
                    buffer_offset = 0
                    buffer_data_len = remaining_data
                }
                read_target_ptr = Add(buffer, buffer_data_len)
                read_max_len = Subtract(4096, buffer_data_len)
                bytes_read = SocketRead(client_socket, read_target_ptr, read_max_len)
                IfCondition GreaterThan(bytes_read, 0) ThenBlock: {
                    buffer_data_len = Add(buffer_data_len, bytes_read)
                } ElseBlock: {
                    client_connected = 0
                }
            } ElseBlock: {
                client_connected = 0
            }
        }
        SocketClose(client_socket)
        Deallocate(buffer, 0)
    }
}

SubRoutine.Main {
    Debug("server.start", level=1) {
        PrintMessage("[DEBUG] Server Main subroutine started.")
        PrintMessage("[DEBUG] Initializing main data store...")
    }
    
    
    // Create and configure the server socket
    server_socket = SocketCreate()
    IfCondition LessEqual(server_socket, 0) ThenBlock: {
        PrintMessage("ERROR: SocketCreate failed.")
        Exit(1)
    }
    
    SocketSetOption(server_socket, 1, 2, 1) // SO_REUSEADDR
    
    result = SocketBind(server_socket, 0, 6379)
    IfCondition LessThan(result, 0) ThenBlock: {
        PrintMessage("ERROR: SocketBind failed.")
        SocketClose(server_socket)
        Exit(1)
    }
    
    
    result = SocketListen(server_socket, 128)
    IfCondition LessThan(result, 0) ThenBlock: {
        PrintMessage("ERROR: SocketListen failed.")
        SocketClose(server_socket)
        Exit(1)
    }
    
    PrintMessage("Server listening on port 6379")
    
    //Main accept loop
    server_running = 1
    WhileLoop server_running {
        client_socket = SocketAccept(server_socket)
        IfCondition GreaterThan(client_socket, 0) ThenBlock: {
            Server.HandleClient(client_socket)
        }
    }
    SocketClose(server_socket)
}

RunTask(Main)
