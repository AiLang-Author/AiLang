// Library.XArrays.ailang
// Advanced array and data structure operations for AILANG
// Uses X-prefix to avoid lexer keyword collisions
 
Debug("library.load", level=1) {
    PrintMessage("Loading XArrays Library v1.0")
    PrintMessage("================================")
}

// ====================
// Configuration & Constants
// ====================
FixedPool.XArrays {
    "XMAX_ARRAY_SIZE": Initialize=65536
    "XMAX_HASH_BUCKETS": Initialize=127
    "XSTACK_SIZE": Initialize=1024
    "XQUEUE_SIZE": Initialize=1024
    "XNULL": Initialize=-1
    "XERROR": Initialize=-999999
}


// Helper to copy a string
Function.Helpers.StringCopy {
    Input: str: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        len = StringLength(str)
        new_str = Allocate(Add(len, 1))
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(new_str, i, GetByte(str, i))
            i = Add(i, 1)
        }
        SetByte(new_str, len, 0)
        ReturnValue(new_str)
    }
}

// ====================
// Dynamic Array Operations
// ====================

// Create a dynamic array with metadata
// Structure: [capacity, size, data_ptr]
Function.XArray.XCreate {
    Input: initial_capacity: Integer
    Output: Address
    Body: {
        // 3 fields, 8 bytes each
        arr_struct = Allocate(24)
        
        StoreValue(arr_struct, initial_capacity)
        StoreValue(Add(arr_struct, 8), 0)
        
        data = ArrayCreate(initial_capacity)
        StoreValue(Add(arr_struct, 16), data)
        
        ReturnValue(arr_struct)
    }
}

// Get current size of dynamic array
Function.XArray.XSize {
    Input: arr: Address
    Output: Integer
    Body: {
        ReturnValue(Dereference(Add(arr, 8)))
    }
}

// Get capacity of dynamic array
Function.XArray.XCapacity {
    Input: arr: Address
    Output: Integer
    Body: {
        ReturnValue(Dereference(arr))
    }
}

// Push element to dynamic array with auto-resize
Function.XArray.XPush {
    Input: arr: Address
    Input: value: Integer
    Output: Integer
    Body: {
        capacity = Dereference(arr)
        size = Dereference(Add(arr, 8))
        data = Dereference(Add(arr, 16))
        
        // Check if resize needed
        IfCondition GreaterEqual(size, capacity) ThenBlock: {
            new_capacity = Multiply(capacity, 2)
            new_data = ArrayCreate(new_capacity)
            
            // Copy old data
            i = 0
            WhileLoop LessThan(i, size) {
                old_val = ArrayGet(data, i)
                ArraySet(new_data, i, old_val)
                i = Add(i, 1)
            }
            
            ArrayDestroy(data)
            
            StoreValue(arr, new_capacity)
            StoreValue(Add(arr, 16), new_data)
            data = new_data
        }
        
        ArraySet(data, size, value)
        StoreValue(Add(arr, 8), Add(size, 1))
        
        ReturnValue(1)
    }
}

// Pop element from dynamic array
Function.XArray.XPop {
    Input: arr: Address
    Output: Integer
    Body: {
        size = Dereference(Add(arr, 8))
        
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(XArrays.XERROR)
        }
        
        data = Dereference(Add(arr, 16))
        new_size = Subtract(size, 1)
        value = ArrayGet(data, new_size)
        
        StoreValue(Add(arr, 8), new_size)
        
        ReturnValue(value)
    }
}

// Get element at index
Function.XArray.XGet {
    Input: arr: Address
    Input: index: Integer
    Output: Integer
    Body: {
        size = Dereference(Add(arr, 8))
        
        IfCondition Or(LessThan(index, 0), GreaterEqual(index, size)) ThenBlock:{
            ReturnValue(XArrays.XERROR)
        }
        
        data = Dereference(Add(arr, 16))
        ReturnValue(ArrayGet(data, index))
    }
}

// Set element at index
Function.XArray.XSet {
    Input: arr: Address
    Input: index: Integer
    Input: value: Integer
    Output: Integer
    Body: {
        size = Dereference(Add(arr, 8))
        
        IfCondition Or(LessThan(index, 0), GreaterEqual(index, size)) ThenBlock: {
            ReturnValue(0)
        }
        
        data = Dereference(Add(arr, 16))
        ArraySet(data, index, value)
        
        ReturnValue(1)
    }
}

// Clear all elements
Function.XArray.XClear {
    Input: arr: Address
    Output: Integer
    Body: {
        StoreValue(Add(arr, 8), 0)
        ReturnValue(1)
    }
}

// ====================
// Stack Operations
// ====================

// Create a stack
Function.XStack.XCreate {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Stack uses dynamic array internally
        ReturnValue(XArray.XCreate(capacity))
    }
}

// Push to stack
Function.XStack.XPush {
    Input: stack: Address
    Input: value: Integer
    Output: Integer
    Body: {
        ReturnValue(XArray.XPush(stack, value))
    }
}

// Pop from stack
Function.XStack.XPop {
    Input: stack: Address
    Output: Integer
    Body: {
        ReturnValue(XArray.XPop(stack))
    }
}

// Peek at top without popping
Function.XStack.XPeek {
    Input: stack: Address
    Output: Integer
    Body: {
        size = XArray.XSize(stack)
        
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(XArrays.XERROR)
        }
        
        ReturnValue(XArray.XGet(stack, Subtract(size, 1)))
    }
}

// Check if stack is empty
Function.XStack.XIsEmpty {
    Input: stack: Address
    Output: Integer
    Body: {
        ReturnValue(EqualTo(XArray.XSize(stack), 0))
    }
}

// ====================
// Queue Operations
// ====================

// Create a circular queue
Function.XQueue.XCreate {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Structure: [capacity, size, head, tail, data_ptr]
        queue = Allocate(40)
        
        StoreValue(queue, capacity)
        StoreValue(Add(queue, 8), 0)
        StoreValue(Add(queue, 16), 0)
        StoreValue(Add(queue, 24), 0)
        
        data = ArrayCreate(capacity)
        StoreValue(Add(queue, 32), data)
        
        ReturnValue(queue)
    }
}

// Enqueue element
Function.XQueue.XEnqueue {
    Input: queue: Address
    Input: value: Integer
    Output: Integer
    Body: {
        capacity = Dereference(queue)
        size = Dereference(Add(queue, 8))
        
        IfCondition GreaterEqual(size, capacity) ThenBlock: {
            ReturnValue(0)
        }
        
        tail = Dereference(Add(queue, 24))
        data = Dereference(Add(queue, 32))
        
        ArraySet(data, tail, value)
        
        new_tail = Modulo(Add(tail, 1), capacity)
        StoreValue(Add(queue, 24), new_tail)
        StoreValue(Add(queue, 8), Add(size, 1))
        
        ReturnValue(1)
    }
}

// Dequeue element
Function.XQueue.XDequeue {
    Input: queue: Address
    Output: Integer
    Body: {
        size = Dereference(Add(queue, 8))
        
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(XArrays.XERROR)
        }
        
        capacity = Dereference(queue)
        head = Dereference(Add(queue, 16))
        data = Dereference(Add(queue, 32))
        
        value = ArrayGet(data, head)
        
        new_head = Modulo(Add(head, 1), capacity)
        StoreValue(Add(queue, 16), new_head)
        StoreValue(Add(queue, 8), Subtract(size, 1))
        
        ReturnValue(value)
    }
}

// ====================
// Hash Table Operations
// ====================

// Simple hash function
Function.XHash.XHashInt {
    Input: key: Integer
    Input: buckets: Integer
    Output: Integer
    Body: {
        // Simple modulo hash
        abs_key = key
        IfCondition LessThan(key, 0) ThenBlock: {
            abs_key = Subtract(0, key)
        }
        
        ReturnValue(Modulo(abs_key, buckets))
    }
}

// Create hash table
Function.XHash.XCreate {
    Input: bucket_count: Integer
    Output: Address
    Body: {
        // Structure: [bucket_count, item_count, buckets_ptr]
        hash_table = Allocate(24)
        
        StoreValue(hash_table, bucket_count)
        StoreValue(Add(hash_table, 8), 0)
        
        // Create array of buckets (each bucket is a linked list)
        buckets = ArrayCreate(bucket_count)
        
        // Initialize all buckets to NULL
        i = 0
        WhileLoop LessThan(i, bucket_count) {
            ArraySet(buckets, i, 0)
            i = Add(i, 1)
        }
        
        StoreValue(Add(hash_table, 16), buckets)
        
        ReturnValue(hash_table)
    }
}

// Insert key-value pair
Function.XHash.XInsert {
    Input: hash_table: Address
    Input: key: Integer
    Input: value: Integer
    Output: Integer
    Body: {
        bucket_count = Dereference(hash_table)
        buckets = Dereference(Add(hash_table, 16))
        
        hash = XHash.XHashInt(key, bucket_count)
        
        // Node structure: [key, value, next]
        new_node = Allocate(24)
        StoreValue(new_node, key)
        StoreValue(Add(new_node, 8), value)
        
        // Insert at head of bucket
        head = ArrayGet(buckets, hash)
        StoreValue(Add(new_node, 16), head)
        ArraySet(buckets, hash, new_node)
        
        // Increment item count
        item_count = Dereference(Add(hash_table, 8))
        StoreValue(Add(hash_table, 8), Add(item_count, 1))
        
        ReturnValue(1)
    }
}

// Lookup value by key
Function.XHash.XLookup {
    Input: hash_table: Address
    Input: key: Integer
    Output: Integer
    Body: {
        bucket_count = Dereference(hash_table)
        buckets = Dereference(Add(hash_table, 16))
        
        hash = XHash.XHashInt(key, bucket_count)
        current = ArrayGet(buckets, hash)
        
        WhileLoop NotEqual(current, 0) {
            node_key = Dereference(current)
            
            IfCondition EqualTo(node_key, key) ThenBlock: {
                ReturnValue(Dereference(Add(current, 8)))
            }
            
            current = Dereference(Add(current, 16))
        }
        
        ReturnValue(XArrays.XERROR)
    }
}

// ====================
// Linked List Operations
// ====================

// Create linked list head
Function.XList.XCreate {
    Output: Address
    Body: {
        // List structure: [head, tail, size]
        list = Allocate(24)
        
        StoreValue(list, 0)
        StoreValue(Add(list, 8), 0)
        StoreValue(Add(list, 16), 0)
        
        ReturnValue(list)
    }
}

// Append to list
Function.XList.XAppend {
    Input: list: Address
    Input: value: Integer
    Output: Integer
    Body: {
        // Node structure: [value, next]
        new_node = Allocate(16)
        StoreValue(new_node, value)
        StoreValue(Add(new_node, 8), 0)
        
        head = Dereference(list)
        tail = Dereference(Add(list, 8))
        
        IfCondition EqualTo(head, 0) ThenBlock: {
            StoreValue(list, new_node)
            StoreValue(Add(list, 8), new_node)
        } ElseBlock: {
            StoreValue(Add(tail, 8), new_node)
            StoreValue(Add(list, 8), new_node)
        }
        
        size = Dereference(Add(list, 16))
        StoreValue(Add(list, 16), Add(size, 1))
        
        ReturnValue(1)
    }
}

// Prepend to list
Function.XList.XPrepend {
    Input: list: Address
    Input: value: Integer
    Output: Integer
    Body: {
        new_node = Allocate(16)
        StoreValue(new_node, value)
        
        head = Dereference(list)
        StoreValue(Add(new_node, 8), head)
        StoreValue(list, new_node)
        
        IfCondition EqualTo(head, 0) ThenBlock: {
            StoreValue(Add(list, 8), new_node)
        }
        
        size = Dereference(Add(list, 16))
        StoreValue(Add(list, 16), Add(size, 1))
        
        ReturnValue(1)
    }
}

// Pop from front of list
Function.XList.XPopFront {
    Input: list: Address
    Output: Integer
    Body: {
        head = Dereference(list)
        
        IfCondition EqualTo(head, 0) ThenBlock: {
            ReturnValue(0) // List is empty
        }
        
        // Get value and next node
        value = Dereference(head)
        next_node = Dereference(Add(head, 8))
        
        // Update list head
        StoreValue(list, next_node)
        
        // If list is now empty, update tail as well
        IfCondition EqualTo(next_node, 0) ThenBlock: {
            StoreValue(Add(list, 8), 0)
        }
        
        // Decrement size
        size = Dereference(Add(list, 16))
        StoreValue(Add(list, 16), Subtract(size, 1))
        
        // Free the old node
        Deallocate(head, 0)
        
        // Return the value (caller now owns this memory)
        ReturnValue(value)
    }
}

// Pop from back of list (less efficient for singly-linked list)
Function.XList.XPopBack {
    Input: list: Address
    Output: Integer
    Body: {
        tail = Dereference(Add(list, 8))
        
        IfCondition EqualTo(tail, 0) ThenBlock: {
            ReturnValue(0) // List is empty
        }
        
        // For singly-linked list, we need to find the node before the tail
        head = Dereference(list)
        
        // Special case: only one node
        IfCondition EqualTo(head, tail) ThenBlock: {
            value = Dereference(tail)
            Deallocate(tail, 0)
            StoreValue(list, 0)        // Clear head
            StoreValue(Add(list, 8), 0) // Clear tail
            StoreValue(Add(list, 16), 0) // Size = 0
            ReturnValue(value)
        }
        
        // Find the node before the tail
        current = head
        WhileLoop NotEqual(Dereference(Add(current, 8)), tail) {
            current = Dereference(Add(current, 8))
        }
        
        // Get value from tail
        value = Dereference(tail)
        
        // Remove tail
        Deallocate(tail, 0)
        StoreValue(Add(current, 8), 0)  // Clear next pointer
        StoreValue(Add(list, 8), current) // Update tail
        
        // Decrement size
        size = Dereference(Add(list, 16))
        StoreValue(Add(list, 16), Subtract(size, 1))
        
        ReturnValue(value)
    }
}

// Get list size
Function.XList.XSize {
    Input: list: Address
    Output: Integer
    Body: {
        ReturnValue(Dereference(Add(list, 16)))
    }
}

// Destroy a linked list and free all nodes
Function.XList.XDestroy {
    Input: list: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(list, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        head = Dereference(list)
        
        // Free all nodes
        WhileLoop NotEqual(head, 0) {
            next = Dereference(Add(head, 8))
            value = Dereference(head)
            
            // If value is a pointer, free it
            // This heuristic assumes small integers are not pointers
            IfCondition GreaterThan(value, 1000) ThenBlock: {
                Deallocate(value, 0)
            }
            
            Deallocate(head, 0)
            
            head = next
        }
        
        // Free the list structure itself
        Deallocate(list, 0)
        
        ReturnValue(1)
    }
}

// Also add XDestroyDeep for lists that own their string values
Function.XList.XDestroyDeep {
    Input: list: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(list, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        head = Dereference(list)
        
        // Free all nodes and their values
        WhileLoop NotEqual(head, 0) {
            next = Dereference(Add(head, 8))
            value = Dereference(head)
            
            // Free the value (assuming it's a string/pointer)
            IfCondition NotEqual(value, 0) ThenBlock: {
                Deallocate(value, 0)
            }
            
            // Free the node
            Deallocate(head, 0)
            
            head = next
        }
        
        // Free the list structure
        Deallocate(list, 0)
        
        ReturnValue(1)
    }
}

// ====================
// Utility Functions
// ====================

// Binary search in sorted array
Function.XUtil.XBinarySearch {
    Input: arr: Address
    Input: target: Integer
    Output: Integer
    Body: {
        size = XArray.XSize(arr)
        left = 0
        right = Subtract(size, 1)
        
        WhileLoop LessEqual(left, right) {
            mid = Divide(Add(left, right), 2)
            mid_val = XArray.XGet(arr, mid)
            
            IfCondition EqualTo(mid_val, target) ThenBlock: {
                ReturnValue(mid)
            }
            
            IfCondition LessThan(mid_val, target) ThenBlock: {
                left = Add(mid, 1)
            } ElseBlock: {
                right = Subtract(mid, 1)
            }
        }
        
        ReturnValue(XArrays.XNULL)
    }
}

// Quick sort for arrays - FIXED: Each parameter on its own line
Function.XUtil.XQuickSort {
    Input: arr: Address
    Input: low: Integer
    Input: high: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(low, high) ThenBlock: {
            pivot_index = XUtil.XPartition(arr, low, high)
            
            XUtil.XQuickSort(arr, low, Subtract(pivot_index, 1))
            XUtil.XQuickSort(arr, Add(pivot_index, 1), high)
        }
        
        ReturnValue(1)
    }
}

// Partition helper for quicksort - FIXED: Each parameter on its own line
Function.XUtil.XPartition {
    Input: arr: Address
    Input: low: Integer
    Input: high: Integer
    Output: Integer
    Body: {
        pivot = XArray.XGet(arr, high)
        i = Subtract(low, 1)
        
        j = low
        WhileLoop LessThan(j, high) {
            current = XArray.XGet(arr, j)
            
            IfCondition LessEqual(current, pivot) ThenBlock: {
                i = Add(i, 1)
                
                // Swap elements
                temp = XArray.XGet(arr, i)
                XArray.XSet(arr, i, current)
                XArray.XSet(arr, j, temp)
            }
            
            j = Add(j, 1)
        }
        
        // Place pivot
        i = Add(i, 1)
        temp = XArray.XGet(arr, i)
        XArray.XSet(arr, i, pivot)
        XArray.XSet(arr, high, temp)
        
        ReturnValue(i)
    }
}

// Find maximum in array
Function.XUtil.XFindMax {
    Input: arr: Address
    Output: Integer
    Body: {
        size = XArray.XSize(arr)
        
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(XArrays.XERROR)
        }
        
        max_val = XArray.XGet(arr, 0)
        i = 1
        
        WhileLoop LessThan(i, size) {
            current = XArray.XGet(arr, i)
            
            IfCondition GreaterThan(current, max_val) ThenBlock: {
                max_val = current
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(max_val)
    }
}

// Find minimum in array
Function.XUtil.XFindMin {
    Input: arr: Address
    Output: Integer
    Body: {
        size = XArray.XSize(arr)
        
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(XArrays.XERROR)
        }
        
        min_val = XArray.XGet(arr, 0)
        i = 1
        
        WhileLoop LessThan(i, size) {
            current = XArray.XGet(arr, i)
            
            IfCondition LessThan(current, min_val) ThenBlock: {
                min_val = current
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(min_val)
    }
}

// Reverse array in place
Function.XUtil.XReverse {
    Input: arr: Address
    Output: Integer
    Body: {
        size = XArray.XSize(arr)
        left = 0
        right = Subtract(size, 1)
        
        WhileLoop LessThan(left, right) {
            // Swap elements
            left_val = XArray.XGet(arr, left)
            right_val = XArray.XGet(arr, right)
            
            XArray.XSet(arr, left, right_val)
            XArray.XSet(arr, right, left_val)
            
            left = Add(left, 1)
            right = Subtract(right, 1)
        }
        
        ReturnValue(1)
    }
}

// Destroy an XArray structure
Function.XArray.XDestroy {
    Input: arr: Address
    Output: Integer
    Body: {
        IfCondition NotEqual(arr, 0) ThenBlock: {
            data = Dereference(Add(arr, 16))
            ArrayDestroy(data)
            Deallocate(arr, 0)
        }
        ReturnValue(1)
    }
}

// NEW CORRECT VERSION:
Function.XSHash.XCreate {
    Input: bucket_count: Integer
    Output: Address
    Body: {
        // Structure: [bucket_count:8, item_count:8, buckets_ptr:8] = 24 bytes
        hash_table = Allocate(24)
        
        // Store bucket count at offset 0
        StoreValue(hash_table, bucket_count)
        
        // Store initial item count (0) at offset 8
        StoreValue(Add(hash_table, 8), 0)
        
        // Create array of buckets (each bucket is a linked list head)
        buckets = ArrayCreate(bucket_count)
        
        // Initialize all buckets to NULL (0)
        i = 0
        WhileLoop LessThan(i, bucket_count) {
            ArraySet(buckets, i, 0)
            i = Add(i, 1)
        }
        
        // Store buckets pointer at offset 16
        StoreValue(Add(hash_table, 16), buckets)
        
        ReturnValue(hash_table)
    }
}

Function.XSHash.XInsert {
    Input: hash_table: Address
    Input: key: Address
    Input: value: Integer
    Output: Integer
    Body: {
        // Use string hash for key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // Get bucket count and calculate bucket index
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        // First, check if the key already exists in this bucket
        current = ArrayGet(buckets, bucket_idx)
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // Key exists - update the value instead of inserting
                old_value = Dereference(Add(current, 8))
                StoreValue(Add(current, 8), value)
                // Return 0 to indicate update (not a new insertion)
                ReturnValue(0)
            }
            current = Dereference(Add(current, 16))
        }
        
        // Key doesn't exist, so create new node: [key_copy, value, next]
        new_node = Allocate(24)
        key_copy = Helpers.StringCopy(key)
        StoreValue(new_node, key_copy)
        StoreValue(Add(new_node, 8), value)
        
        // Insert at head of bucket
        head = ArrayGet(buckets, bucket_idx)
        StoreValue(Add(new_node, 16), head)
        ArraySet(buckets, bucket_idx, new_node)
        
        // Update count
        item_count = Dereference(Add(hash_table, 8))
        StoreValue(Add(hash_table, 8), Add(item_count, 1))
        
        // Return 1 to indicate new insertion
        ReturnValue(1)
    }
}

Function.XSHash.XLookup {
    Input: hash_table: Address
    Input: key: Address
    Output: Integer
    Body: {
        // Hash the key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        current = ArrayGet(buckets, bucket_idx)
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(Dereference(Add(current, 8)))
            }
            current = Dereference(Add(current, 16))
        }
        
        ReturnValue(XArrays.XNULL)
    }
}

Function.XSHash.XExists {
    Input: hash_table: Address
    Input: key: Address
    Output: Integer
    Body: {
        result = XSHash.XLookup(hash_table, key)
        ReturnValue(NotEqual(result, XArrays.XNULL))
    }
}

Function.XSHash.XDelete {
    Input: hash_table: Address
    Input: key: Address
    Output: Integer
    Body: {
        // Hash the key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        current = ArrayGet(buckets, bucket_idx)
        prev = 0
        
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // Found it - unlink from chain
                value = Dereference(Add(current, 8))
                next = Dereference(Add(current, 16))
                
                IfCondition EqualTo(prev, 0) ThenBlock: {
                    ArraySet(buckets, bucket_idx, next)
                } ElseBlock: {
                    StoreValue(Add(prev, 16), next)
                }
                
                // Free the key and node
                Deallocate(stored_key, 0)
                Deallocate(current, 0)
                
                // Update count
                item_count = Dereference(Add(hash_table, 8))
                StoreValue(Add(hash_table, 8), Subtract(item_count, 1))
                
                ReturnValue(value)
            }
            prev = current
            current = Dereference(Add(current, 16))
        }
        
        ReturnValue(XArrays.XNULL)
    }
}

Function.XSHash.XDestroy {
    Input: hash_table: Address
    Output: Integer
    Body: {
        IfCondition NotEqual(hash_table, 0) ThenBlock: {
            buckets = Dereference(Add(hash_table, 16))
            bucket_count = Dereference(hash_table)
            
            // Free all nodes in all buckets
            i = 0
            WhileLoop LessThan(i, bucket_count) {
                current = ArrayGet(buckets, i)
                WhileLoop NotEqual(current, 0) {
                    next = Dereference(Add(current, 16))
                    key = Dereference(current)
                    Deallocate(key, 0)
                    Deallocate(current, 0)
                    current = next
                }
                i = Add(i, 1)
            }
            
            ArrayDestroy(buckets)
            Deallocate(hash_table, 0)
        }
        ReturnValue(1)
    }
}

Function.XSHash.XKeys {
    Input: hash_table: Address
    Output: Address
    Body: {
        keys = XArray.XCreate(16)
        buckets = Dereference(Add(hash_table, 16))
        bucket_count = Dereference(hash_table)
        
        i = 0
        WhileLoop LessThan(i, bucket_count) {
            current = ArrayGet(buckets, i)
            WhileLoop NotEqual(current, 0) {
                key = Dereference(current)
                key_copy = Helpers.StringCopy(key)
                XArray.XPush(keys, key_copy)
                current = Dereference(Add(current, 16))
            }
            i = Add(i, 1)
        }
        
        ReturnValue(keys)
    }
}

// Add these functions to Library.XArrays.ailang to support storing addresses instead of integers
// These are variants of XSHash functions that handle Address values

// Insert key-address pair (instead of key-integer)
Function.XSHash.XInsertAddr {
    Input: hash_table: Address
    Input: key: Address
    Input: value: Address  // Changed from Integer to Address
    Output: Integer
    Body: {
        // Use string hash for key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // Get bucket count and calculate bucket index
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        // First, check if the key already exists in this bucket
        current = ArrayGet(buckets, bucket_idx)
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // Key exists - update the value instead of inserting
                old_value = Dereference(Add(current, 8))
                StoreValue(Add(current, 8), value)  // Store address directly
                // Return 0 to indicate update (not a new insertion)
                ReturnValue(0)
            }
            current = Dereference(Add(current, 16))
        }
        
        // Key doesn't exist, so create new node: [key_copy, value, next]
        new_node = Allocate(24)
        key_copy = Helpers.StringCopy(key)
        StoreValue(new_node, key_copy)
        StoreValue(Add(new_node, 8), value)  // Store address directly
        
        // Insert at head of bucket
        head = ArrayGet(buckets, bucket_idx)
        StoreValue(Add(new_node, 16), head)
        ArraySet(buckets, bucket_idx, new_node)
        
        // Update count
        item_count = Dereference(Add(hash_table, 8))
        StoreValue(Add(hash_table, 8), Add(item_count, 1))
        
        // Return 1 to indicate new insertion
        ReturnValue(1)
    }
}

// Lookup address value by key (instead of integer)
Function.XSHash.XLookupAddr {
    Input: hash_table: Address
    Input: key: Address
    Output: Address  // Changed from Integer to Address
    Body: {
        // Hash the key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        current = ArrayGet(buckets, bucket_idx)
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(Dereference(Add(current, 8)))  // Return address
            }
            current = Dereference(Add(current, 16))
        }
        
        ReturnValue(XArrays.XNULL)
    }
}

// Check if a key exists using address lookup
Function.XSHash.XExistsAddr {
    Input: hash_table: Address
    Input: key: Address
    Output: Integer
    Body: {
        result = XSHash.XLookupAddr(hash_table, key)
        // Return 1 if result is not XNULL, 0 otherwise
        ReturnValue(NotEqual(result, XArrays.XNULL))
    }
}

// Stream destruction
Function.XStream.XDestroy {
    Input: stream: Address
    Output: Integer
    Body: {
        IfCondition NotEqual(stream, 0) ThenBlock: {
            size = XArray.XSize(stream)
            i = 0
            WhileLoop LessThan(i, size) {
                entry = XArray.XGet(stream, i)
                entry_size = XArray.XSize(entry)
                j = 0
                WhileLoop LessThan(j, entry_size) {
                    field_or_value = XArray.XGet(entry, j)
                    Deallocate(field_or_value, 0)
                    j = Add(j, 1)
                }
                XArray.XDestroy(entry)
                i = Add(i, 1)
            }
            XArray.XDestroy(stream)
        }
        ReturnValue(1)
    }
}

// Delete and return address value (instead of integer)
Function.XSHash.XDeleteAddr {
    Input: hash_table: Address
    Input: key: Address
    Output: Address  // Changed from Integer to Address
    Body: {
        // Hash the key
        hash_value = 0
        i = 0
        key_len = StringLength(key)
        WhileLoop LessThan(i, key_len) {
            byte = GetByte(key, i)
            hash_value = Add(Multiply(hash_value, 31), byte)
            i = Add(i, 1)
        }
        
        // CRITICAL FIX: Ensure hash_value is positive before modulo
        IfCondition LessThan(hash_value, 0) ThenBlock: {
            hash_value = Multiply(hash_value, -1)
        }
        bucket_count = Dereference(hash_table)
        bucket_idx = Modulo(hash_value, bucket_count)
        buckets = Dereference(Add(hash_table, 16))
        
        current = ArrayGet(buckets, bucket_idx)
        prev = 0
        
        WhileLoop NotEqual(current, 0) {
            stored_key = Dereference(current)
            cmp = StringCompare(stored_key, key)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // Found it - unlink from chain
                value = Dereference(Add(current, 8))  // This is now an address
                next = Dereference(Add(current, 16))
                
                IfCondition EqualTo(prev, 0) ThenBlock: {
                    ArraySet(buckets, bucket_idx, next)
                } ElseBlock: {
                    StoreValue(Add(prev, 16), next)
                }
                
                // Free the key and node
                Deallocate(stored_key, 0)
                Deallocate(current, 0)
                
                // Update count
                item_count = Dereference(Add(hash_table, 8))
                StoreValue(Add(hash_table, 8), Subtract(item_count, 1))
                
                ReturnValue(value)  // Return the address value
            }
            
            prev = current
            current = Dereference(Add(current, 16))
        }
        
        ReturnValue(XArrays.XNULL)
    }
}


Debug("library.load", level=1) {
    PrintMessage("XArrays Library loaded successfully!")
    PrintMessage("Features: Dynamic arrays, stacks, queues, hash tables, linked lists")
    PrintMessage("All functions use X-prefix to avoid keyword conflicts")
}