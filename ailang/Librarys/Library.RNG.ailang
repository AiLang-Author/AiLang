// Library.RNG.ailang
// Random Number Generator Library for AILANG
// Uses FixedPool for proper state management

// ============================================================
// All RNG state stored in a FixedPool
// ============================================================
// Library.RNG.ailang
// Random Number Generator Library for AILANG
// Uses FixedPool for proper state management

// ============================================================
// All RNG state stored in a FixedPool
// ============================================================
FixedPool.RNGState {
    "lcg_state": Initialize=1
    "xorshift_state": Initialize=2463534242
    "lfsr_state": Initialize=44257    
    "mt_index": Initialize=0
}
// ============================================================
// Linear Congruential Generator (LCG)
// ============================================================

Function.RNG.LCG_Seed {
    Input: seed: Integer
    Body: {
        FixedPool.RNGState.lcg_state = seed
        // Avoid 0 seed
        current = FixedPool.RNGState.lcg_state
        IfCondition EqualTo(current, 0) ThenBlock: {
            FixedPool.RNGState.lcg_state = 1
        }
        ReturnValue(1)
    }
}

Function.RNG.LCG_Next {
    Output: Integer
    Body: {
        // Read current state
        current_state = FixedPool.RNGState.lcg_state
        // Calculate next value: (a * seed + c) mod m
        multiplied = Multiply(current_state, 1664525)
        added = Add(multiplied, 1013904223)
        masked = BitwiseAnd(added, 0x7FFFFFFF)
        // Store new state
        FixedPool.RNGState.lcg_state = masked
        ReturnValue(masked)
    }
}

Function.RNG.LCG_Range {
    Input: min: Integer
    Input: max: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(min, max) ThenBlock: {
            ReturnValue(min)
        }
        range = Subtract(max, min)
        value = RNG.LCG_Next()
        result = Add(min, Modulo(value, range))
        ReturnValue(result)
    }
}

// ============================================================
// XORShift Algorithm
// ============================================================

Function.RNG.XORShift_Seed {
    Input: seed: Integer
    Body: {
        FixedPool.RNGState.xorshift_state = seed
        current = FixedPool.RNGState.xorshift_state
        IfCondition EqualTo(current, 0) ThenBlock: {
            FixedPool.RNGState.xorshift_state = 2463534242
        }
        ReturnValue(1)
    }
}

Function.RNG.XORShift32_Next {
    Output: Integer
    Body: {
        // Read current state
        x = FixedPool.RNGState.xorshift_state
        // XORShift32 algorithm
        shift1 = LeftShift(x, 13)
        x1 = BitwiseXor(x, shift1)
        shift2 = RightShift(x1, 17)
        x2 = BitwiseXor(x1, shift2)
        shift3 = LeftShift(x2, 5)
        x3 = BitwiseXor(x2, shift3)
        // Store new state
        FixedPool.RNGState.xorshift_state = x3
        // Return positive value
        result = BitwiseAnd(x3, 0x7FFFFFFF)
        ReturnValue(result)
    }
}

Function.RNG.XORShift_Range {
    Input: min: Integer
    Input: max: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(min, max) ThenBlock: {
            ReturnValue(min)
        }
        range = Subtract(max, min)
        value = RNG.XORShift32_Next()
        result = Add(min, Modulo(value, range))
        ReturnValue(result)
    }
}

// ============================================================
// Linear Feedback Shift Register (LFSR)
// ============================================================

Function.RNG.LFSR_Seed {
    Input: seed: Integer
    Body: {
        masked_seed = BitwiseAnd(seed, 0xFFFF)
        FixedPool.RNGState.lfsr_state = masked_seed
        current = FixedPool.RNGState.lfsr_state
        IfCondition EqualTo(current, 0) ThenBlock: {
            FixedPool.RNGState.lfsr_state = 0xACE1
        }
        ReturnValue(1)
    }
}

Function.RNG.LFSR_Next {
    Output: Integer
    Body: {
        // Read current state
        current = FixedPool.RNGState.lfsr_state
        // Galois LFSR with taps at 16,14,13,11
        bit = BitwiseAnd(current, 1)
        shifted = RightShift(current, 1)
        
        IfCondition EqualTo(bit, 1) ThenBlock: {
            new_state = BitwiseXor(shifted, 0xB400)
            FixedPool.RNGState.lfsr_state = new_state
        } ElseBlock: {
            FixedPool.RNGState.lfsr_state = shifted
        }
        
        result = FixedPool.RNGState.lfsr_state
        ReturnValue(result)
    }
}

// ============================================================
// Combined Generator
// ============================================================

Function.RNG.Combined_Next {
    Output: Integer
    Body: {
        // Combine LCG and XORShift for better quality
        lcg_val = RNG.LCG_Next()
        xor_val = RNG.XORShift32_Next()
        combined = BitwiseXor(lcg_val, xor_val)
        positive = BitwiseAnd(combined, 0x7FFFFFFF)
        ReturnValue(positive)
    }
}

Function.RNG.Combined_Range {
    Input: min: Integer
    Input: max: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(min, max) ThenBlock: {
            ReturnValue(min)
        }
        range = Subtract(max, min)
        value = RNG.Combined_Next()
        result = Add(min, Modulo(value, range))
        ReturnValue(result)
    }
}

// ============================================================
// Utility Functions
// ============================================================

Function.RNG.AutoSeed {
    Input: entropy1: Integer
    Input: entropy2: Integer
    Input: entropy3: Integer
    Output: Integer
    Body: {
        // Mix entropy sources
        mult = Multiply(entropy2, 65521)
        mix1 = BitwiseXor(entropy1, mult)
        mix2 = Add(mix1, entropy3)
        shift1 = RightShift(mix2, 16)
        mix3 = BitwiseXor(mix2, shift1)
        mult2 = Multiply(mix3, 0x45d9f3b)
        shift2 = RightShift(mult2, 16)
        seed = BitwiseXor(mult2, shift2)
        
        // Seed all generators
        RNG.LCG_Seed(seed)
        seed1 = Add(seed, 1)
        RNG.XORShift_Seed(seed1)
        seed2 = Add(seed, 2)
        RNG.LFSR_Seed(seed2)
        
        ReturnValue(seed)
    }
}

Function.RNG.Bool {
    Output: Integer
    Body: {
        value = RNG.XORShift32_Next()
        bit = BitwiseAnd(value, 1)
        ReturnValue(bit)
    }
}

Function.RNG.Uniform1000 {
    Output: Integer
    Body: {
        value = RNG.Combined_Next()
        result = Modulo(value, 1001)
        ReturnValue(result)
    }
}

Function.RNG.Dice {
    Input: sides: Integer
    Output: Integer
    Body: {
        IfCondition LessEqual(sides, 0) ThenBlock: {
            ReturnValue(1)
        }
        value = RNG.XORShift32_Next()
        mod = Modulo(value, sides)
        result = Add(mod, 1)
        ReturnValue(result)
    }
}

// Test function
SubRoutine.RNG.Test {
    PrintMessage("Testing RNG Library\n")
    
    // Seed with some "entropy"
    RNG.AutoSeed(12345, 67890, 42)
    
    PrintMessage("\nLCG Random (0-99): ")
    PrintNumber(RNG.LCG_Range(0, 100))
    
    PrintMessage("\nXORShift Random (0-99): ")
    PrintNumber(RNG.XORShift_Range(0, 100))
    
    PrintMessage("\nCombined Random (0-99): ")
    PrintNumber(RNG.Combined_Range(0, 100))
    
    PrintMessage("\n\n10 Dice Rolls (d6): ")
    i = 0
    WhileLoop LessThan(i, 10) {
        PrintNumber(RNG.Dice(6))
        PrintMessage(" ")
        i = Add(i, 1)
    }
    
    PrintMessage("\n\n10 Coin Flips: ")
    i = 0
    WhileLoop LessThan(i, 10) {
        PrintNumber(RNG.Bool())
        PrintMessage(" ")
        i = Add(i, 1)
    }
    
    PrintMessage("\n")
}