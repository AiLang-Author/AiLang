    // ============================================================================
    // AILANG Data Structures Library
    // High-Performance, Cache-Aware Data Structures
    // ============================================================================

// Memory pools for different data structure types

LibraryImport.Core.DataStructures {
   
    FixedPool.Pool.DataStructures.HashTables {
        "hash_buckets": ElementType-Address, MaximumLength-1000000,
        "hash_nodes": ElementType-HashNode, MaximumLength-10000000,
        "cache_alignment": Initialize-64, CanChange-False
    }

    DynamicPool.Pool.DataStructures.Trees {
        "tree_nodes": ElementType-TreeNode, MaximumLength-10000000,
        "node_storage": ElementType-Address, CanChange-True,
        "balance_workspace": ElementType-Address, MaximumLength-1000000
    }

    DynamicPool.Pool.DataStructures.Graphs {
        "graph_vertices": ElementType-GraphVertex, MaximumLength-1000000,
        "graph_edges": ElementType-GraphEdge, MaximumLength-10000000,
        "adjacency_lists": ElementType-Address, CanChange-True
    }

    FixedPool.Pool.DataStructures.Heaps {
        "heap_arrays": ElementType-Address, MaximumLength-1000000,
        "priority_elements": ElementType-PriorityElement, MaximumLength-10000000
    }

    TemporalPool.Pool.DataStructures.Cache {
        "lru_nodes": ElementType-LRUNode, MaximumLength-1000000,
        "cache_entries": ElementType-CacheEntry, MaximumLength-1000000,
        "lifetime": Initialize-"session_scope", CanChange-False
    }

    
// Hash Table Implementation  

    HashTableHandle = Record {
        buckets: Array[Address]
        bucket_count: Integer
        size: Integer
        load_factor: FloatingPoint
        hash_function: Function
        key_type: Text
        value_type: Text
        collision_strategy: Text
    }

    HashNode = Record {
        key: Any,
        value: Any,
        hash: UInt64,
        next: OptionalType[HashNode]
    }

    Function.DataStructures.HashMap.Create {
        Input: (
            initial_capacity: Integer = 16,
            load_factor: FloatingPoint = 0.75,
            key_type: Text = "Any",
            value_type: Text = "Any"
        )
        Output: HashTableHandle
        Body: {
            hash_table = (Pool.DataStructures.HashTables.Allocate())
            
            hash_table.bucket_count = initial_capacity
            hash_table.size = 0
            hash_table.load_factor = load_factor
            hash_table.key_type = key_type
            hash_table.value_type = value_type
            hash_table.collision_strategy = "chaining"
            
            hash_table.buckets = (Array.Create(initial_capacity, Address))
            ForEvery i in Range(0, initial_capacity) {
                hash_table.buckets[i] = Null
            }
            
            ChoosePath key_type {
                CaseOption "Text": { hash_table.hash_function = DataStructures.Hash.String }
                CaseOption "Integer": { hash_table.hash_function = DataStructures.Hash.Integer }
                CaseOption "FloatingPoint": { hash_table.hash_function = DataStructures.Hash.Float }
                DefaultOption: { hash_table.hash_function = DataStructures.Hash.Generic }
            }
            
            ReturnValue(hash_table)
        }
    }

    Function.DataStructures.HashMap.Put {
        Input: (table: HashTableHandle, key: Any, value: Any)
        Body: {
            threshold = (Multiply(table.bucket_count, table.load_factor))
            IfCondition GreaterThan(table.size, threshold) ThenBlock {
                Apply(DataStructures.HashMap.Resize, table, Multiply(table.bucket_count, 2))
            }
            
            hash = (Apply(table.hash_function, key))
            bucket_index = (Subtract(hash, Multiply(table.bucket_count, Divide(hash, table.bucket_count))))
            
            current = table.buckets[bucket_index]
            WhileLoop NotEqual(current, Null) {
                IfCondition Apply(DataStructures.KeyEquals, current.key, key) ThenBlock {
                    current.value = value
                    ReturnValue()
                }
                current = current.next
            }
            
            new_node = (Pool.DataStructures.HashTables.Allocate())
            new_node.key = key
            new_node.value = value
            new_node.hash = hash
            new_node.next = table.buckets[bucket_index]
            
            table.buckets[bucket_index] = new_node
            table.size = (Add(table.size, 1))
        }
    }

    Function.DataStructures.HashMap.Get {
        Input: (table: HashTableHandle, key: Any)
        Output: OptionalType[Any]
        Body: {
            hash = (Apply(table.hash_function, key))
            bucket_index = (Subtract(hash, Multiply(table.bucket_count, Divide(hash, table.bucket_count))))
            
            current = table.buckets[bucket_index]
            WhileLoop NotEqual(current, Null) {
                IfCondition Apply(DataStructures.KeyEquals, current.key, key) ThenBlock {
                    ReturnValue(current.value)
                }
                current = current.next
            }
            
            ReturnValue(Null)
        }
    }

    Function.DataStructures.HashMap.Remove {
        Input: (table: HashTableHandle, key: Any)
        Output: Boolean
        Body: {
            hash = (Apply(table.hash_function, key))
            bucket_index = (Subtract(hash, Multiply(table.bucket_count, Divide(hash, table.bucket_count))))
            
            current = table.buckets[bucket_index]
            previous = Null
            
            WhileLoop NotEqual(current, Null) {
                IfCondition Apply(DataStructures.KeyEquals, current.key, key) ThenBlock {
                    IfCondition EqualTo(previous, Null) ThenBlock {
                        table.buckets[bucket_index] = current.next
                    } ElseBlock {
                        previous.next = current.next
                    }
                    
                    table.size = (Subtract(table.size, 1))
                    ReturnValue(True)
                }
                previous = current
                current = current.next
            }
            
            ReturnValue(False)
        }
    }

    Function.DataStructures.HashMap.Resize {
        Input: (table: HashTableHandle, new_capacity: Integer)
        Body: {
            old_buckets = table.buckets
            old_capacity = table.bucket_count
            
            table.buckets = (Array.Create(new_capacity, Address))
            table.bucket_count = new_capacity
            table.size = 0
            
            ForEvery i in Range(0, new_capacity) {
                table.buckets[i] = Null
            }
            
            ForEvery i in Range(0, old_capacity) {
                current = old_buckets[i]
                WhileLoop NotEqual(current, Null) {
                    next = current.next
                    Apply(DataStructures.HashMap.Put, table, current.key, current.value)
                    current = next
                }
            }
        }
    }

    // ============================================================================
    // Binary Search Tree Implementation
    // ============================================================================

    TreeNode = Record {
        key: Any,
        value: Any,
        left: OptionalType[TreeNode],
        right: OptionalType[TreeNode],
        parent: OptionalType[TreeNode],
        height: Integer,
        color: Text
    }

    BinaryTreeHandle = Record {
        root: OptionalType[TreeNode],
        size: Integer,
        key_type: Text,
        value_type: Text,
        compare_function: Function,
        tree_type: Text
    }

    Function.DataStructures.BinaryTree.Create {
        Input: (
            key_type: Text = "Any",
            value_type: Text = "Any",
            tree_type: Text = "avl"
        )
        Output: BinaryTreeHandle
        Body: {
            tree = (Pool.DataStructures.Trees.Allocate())
            
            tree.root = Null
            tree.size = 0
            tree.key_type = key_type
            tree.value_type = value_type
            tree.tree_type = tree_type
            
            ChoosePath key_type {
                CaseOption "Integer": { tree.compare_function = DataStructures.Compare.Integer }
                CaseOption "FloatingPoint": { tree.compare_function = DataStructures.Compare.Float }
                CaseOption "Text": { tree.compare_function = DataStructures.Compare.String }
                DefaultOption: { tree.compare_function = DataStructures.Compare.Generic }
            }
            
            ReturnValue(tree)
        }
    }

    Function.DataStructures.BinaryTree.Insert {
        Input: (tree: BinaryTreeHandle, key: Any, value: Any)
        Body: {
            IfCondition EqualTo(tree.root, Null) ThenBlock {
                new_node = (Pool.DataStructures.Trees.Allocate())
                new_node.key = key
                new_node.value = value
                new_node.left = Null
                new_node.right = Null
                new_node.parent = Null
                new_node.height = 0
                new_node.color = "black"
                
                tree.root = new_node
                tree.size = 1
                ReturnValue()
            }
            
            insertion_point = (Apply(DataStructures.BinaryTree.FindInsertionPoint, tree, key))
            
            new_node = (Pool.DataStructures.Trees.Allocate())
            new_node.key = key
            new_node.value = value
            new_node.left = Null
            new_node.right = Null
            new_node.parent = insertion_point
            new_node.height = 0
            new_node.color = "red"
            
            comparison = (Apply(tree.compare_function, key, insertion_point.key))
            IfCondition LessThan(comparison, 0) ThenBlock {
                insertion_point.left = new_node
            } ElseBlock {
                insertion_point.right = new_node
            }
            
            tree.size = (Add(tree.size, 1))
            
            ChoosePath tree.tree_type {
                CaseOption "avl": { Apply(DataStructures.AVL.RebalanceAfterInsert, tree, new_node) }
                CaseOption "red_black": { Apply(DataStructures.RedBlack.RebalanceAfterInsert, tree, new_node) }
            }
        }
    }

    Function.DataStructures.BinaryTree.Search {
        Input: (tree: BinaryTreeHandle, key: Any)
        Output: OptionalType[Any]
        Body: {
            current = tree.root
            
            WhileLoop NotEqual(current, Null) {
                comparison = (Apply(tree.compare_function, key, current.key))
                
                IfCondition EqualTo(comparison, 0) ThenBlock {
                    ReturnValue(current.value)
                } ElseBlock {
                    IfCondition LessThan(comparison, 0) ThenBlock {
                        current = current.left
                    } ElseBlock {
                        current = current.right
                    }
                }
            }
            
            ReturnValue(Null)
        }
    }

    Function.DataStructures.BinaryTree.Remove {
        Input: (tree: BinaryTreeHandle, key: Any)
        Output: Boolean
        Body: {
            node_to_remove = (Apply(DataStructures.BinaryTree.FindNode, tree, key))
            IfCondition EqualTo(node_to_remove, Null) ThenBlock {
                ReturnValue(False)
            }
            
            IfCondition And(EqualTo(node_to_remove.left, Null), EqualTo(node_to_remove.right, Null)) ThenBlock {
                Apply(DataStructures.BinaryTree.RemoveLeafNode, tree, node_to_remove)
            } ElseBlock {
                IfCondition Or(EqualTo(node_to_remove.left, Null), EqualTo(node_to_remove.right, Null)) ThenBlock {
                    Apply(DataStructures.BinaryTree.RemoveNodeWithOneChild, tree, node_to_remove)
                } ElseBox {
                    successor = (Apply(DataStructures.BinaryTree.FindSuccessor, node_to_remove))
                    node_to_remove.key = successor.key
                    node_to_remove.value = successor.value
                    Apply(DataStructures.BinaryTree.RemoveNodeWithOneChild, tree, successor)
                }
            }
            
            tree.size = (Subtract(tree.size, 1))
            ReturnValue(True)
        }
    }

    // ============================================================================
    // AVL Tree Balancing
    // ============================================================================

    Function.DataStructures.AVL.UpdateHeight {
        Input: (node: TreeNode)
        Body: {
            left_height = (IfCondition EqualTo(node.left, Null) ThenBlock { -1 } ElseBlock { node.left.height })
            right_height = (IfCondition EqualTo(node.right, Null) ThenBlock { -1 } ElseBlock { node.right.height })
            
            node.height = (Add(Max(left_height, right_height), 1))
        }
    }

    Function.DataStructures.AVL.GetBalance {
        Input: (node: TreeNode)
        Output: Integer
        Body: {
            left_height = (IfCondition EqualTo(node.left, Null) ThenBlock { -1 } ElseBlock { node.left.height })
            right_height = (IfCondition EqualTo(node.right, Null) ThenBlock { -1 } ElseBlock { node.right.height })
            
            ReturnValue(Subtract(left_height, right_height))
        }
    }

    Function.DataStructures.AVL.RotateLeft {
        Input: (tree: BinaryTreeHandle, node: TreeNode)
        Output: TreeNode
        Body: {
            new_root = node.right
            node.right = new_root.left
            
            IfCondition NotEqual(new_root.left, Null) ThenBlock {
                new_root.left.parent = node
            }
            
            new_root.parent = node.parent
            IfCondition EqualTo(node.parent, Null) ThenBlock {
                tree.root = new_root
            } ElseBlock {
                IfCondition EqualTo(node.parent.left, node) ThenBlock {
                    node.parent.left = new_root
                } ElseBlock {
                    node.parent.right = new_root
                }
            }
            
            new_root.left = node
            node.parent = new_root
            
            Apply(DataStructures.AVL.UpdateHeight, node)
            Apply(DataStructures.AVL.UpdateHeight, new_root)
            
            ReturnValue(new_root)
        }
    }

    Function.DataStructures.AVL.RotateRight {
        Input: (tree: BinaryTreeHandle, node: TreeNode)
        Output: TreeNode
        Body: {
            new_root = node.left
            node.left = new_root.right
            
            IfCondition NotEqual(new_root.right, Null) ThenBlock {
                new_root.right.parent = node
            }
            
            new_root.parent = node.parent
            IfCondition EqualTo(node.parent, Null) ThenBlock {
                tree.root = new_root
            } ElseBlock {
                IfCondition EqualTo(node.parent.left, node) ThenBlock {
                    node.parent.left = new_root
                } ElseBlock {
                    node.parent.right = new_root
                }
            }
            
            new_root.right = node
            node.parent = new_root
            
            Apply(DataStructures.AVL.UpdateHeight, node)
            Apply(DataStructures.AVL.UpdateHeight, new_root)
            
            ReturnValue(new_root)
        }
    }

    Function.DataStructures.AVL.RebalanceAfterInsert {
        Input: (tree: BinaryTreeHandle, node: TreeNode)
        Body: {
            current = node.parent
            
            WhileLoop NotEqual(current, Null) {
                Apply(DataStructures.AVL.UpdateHeight, current)
                balance = (Apply(DataStructures.AVL.GetBalance, current))
                
                IfCondition GreaterThan(balance, 1) ThenBlock {
                    left_balance = (Apply(DataStructures.AVL.GetBalance, current.left))
                    
                    IfCondition LessThan(left_balance, 0) ThenBlock {
                        Apply(DataStructures.AVL.RotateLeft, tree, current.left)
                    }
                    
                    Apply(DataStructures.AVL.RotateRight, tree, current)
                    BreakLoop
                }
                
                IfCondition LessThan(balance, -1) ThenBlock {
                    right_balance = (Apply(DataStructures.AVL.GetBalance, current.right))
                    
                    IfCondition GreaterThan(right_balance, 0) ThenBlock {
                        Apply(DataStructures.AVL.RotateRight, tree, current.right)
                    }
                    
                    Apply(DataStructures.AVL.RotateLeft, tree, current)
                    BreakLoop
                }
                
                current = current.parent
            }
        }
    }

    // ============================================================================
    // Priority Queue (Binary Heap) Implementation
    // ============================================================================

    PriorityElement = Record {
        value: Any,
        priority: FloatingPoint
    }

    HeapHandle = Record {
        elements: Array[PriorityElement],
        size: Integer,
        capacity: Integer,
        heap_type: Text,
        compare_function: Function
    }

    Function.DataStructures.PriorityQueue.Create {
        Input: (
            initial_capacity: Integer = 16,
            heap_type: Text = "min_heap"
        )
        Output: HeapHandle
        Body: {
            heap = (Pool.DataStructures.Heaps.Allocate())
            
            heap.elements = (Array.Create(initial_capacity, PriorityElement))
            heap.size = 0
            heap.capacity = initial_capacity
            heap.heap_type = heap_type
            
            ChoosePath heap_type {
                CaseOption "min_heap": { heap.compare_function = DataStructures.Compare.MinHeap }
                CaseOption "max_heap": { heap.compare_function = DataStructures.Compare.MaxHeap }
                DefaultOption: { heap.compare_function = DataStructures.Compare.MinHeap }
            }
            
            ReturnValue(heap)
        }
    }

    Function.DataStructures.PriorityQueue.Push {
        Input: (heap: HeapHandle, value: Any, priority: FloatingPoint)
        Body: {
            IfCondition EqualTo(heap.size, heap.capacity) ThenBlock {
                Apply(DataStructures.PriorityQueue.Resize, heap, Multiply(heap.capacity, 2))
            }
            
            element = (PriorityElement.Create())
            element.value = value
            element.priority = priority
            
            heap.elements[heap.size] = element
            heap.size = (Add(heap.size, 1))
            
            Apply(DataStructures.PriorityQueue.BubbleUp, heap, Subtract(heap.size, 1))
        }
    }

    Function.DataStructures.PriorityQueue.Pop {
        Input: (heap: HeapHandle)
        Output: OptionalType[Any]
        Body: {
            IfCondition EqualTo(heap.size, 0) ThenBlock {
                ReturnValue(Null)
            }
            
            top_element = heap.elements[0].value
            
            heap.elements[0] = heap.elements[(Subtract(heap.size, 1))]
            heap.size = (Subtract(heap.size, 1))
            
            IfCondition GreaterThan(heap.size, 0) ThenBlock {
                Apply(DataStructures.PriorityQueue.BubbleDown, heap, 0)
            }
            
            ReturnValue(top_element)
        }
    }

    Function.DataStructures.PriorityQueue.Peek {
        Input: (heap: HeapHandle)
        Output: OptionalType[Any]
        Body: {
            IfCondition EqualTo(heap.size, 0) ThenBlock {
                ReturnValue(Null)
            }
            
            ReturnValue(heap.elements[0].value)
        }
    }

    Function.DataStructures.PriorityQueue.BubbleUp {
        Input: (heap: HeapHandle, index: Integer)
        Body: {
            IfCondition EqualTo(index, 0) ThenBlock {
                ReturnValue()
            }
            
            parent_index = (Divide(Subtract(index, 1), 2))
            
            should_swap = (Apply(
                heap.compare_function,
                heap.elements[index].priority,
                heap.elements[parent_index].priority
            ))
            
            IfCondition should_swap ThenBlock {
                Apply(DataStructures.Swap, heap.elements, index, parent_index)
                Apply(DataStructures.PriorityQueue.BubbleUp, heap, parent_index)
            }
        }
    }

    Function.DataStructures.PriorityQueue.BubbleDown {
        Input: (heap: HeapHandle, index: Integer)
        Body: {
            left_child = (Add(Multiply(index, 2), 1))
            right_child = (Add(Multiply(index, 2), 2))
            target_index = index
            
            IfCondition LessThan(left_child, heap.size) ThenBlock {
                should_swap = (Apply(
                    heap.compare_function,
                    heap.elements[left_child].priority,
                    heap.elements[target_index].priority
                ))
                IfCondition should_swap ThenBlock {
                    target_index = left_child
                }
            }
            
            IfCondition LessThan(right_child, heap.size) ThenBlock {
                should_swap = (Apply(
                    heap.compare_function,
                    heap.elements[right_child].priority,
                    heap.elements[target_index].priority
                ))
                IfCondition should_swap ThenBlock {
                    target_index = right_child
                }
            }
            
            IfCondition NotEqual(target_index, index) ThenBlock {
                Apply(DataStructures.Swap, heap.elements, index, target_index)
                Apply(DataStructures.PriorityQueue.BubbleDown, heap, target_index)
            }
        }
    }

    // ============================================================================
    // LRU Cache Implementation
    // ============================================================================

    LRUNode = Record {
        key: Any,
        value: Any,
        prev: OptionalType[LRUNode],
        next: OptionalType[LRUNode]
    }

    LRUCacheHandle = Record {
        capacity: Integer,
        size: Integer,
        hash_table: HashTableHandle,
        head: LRUNode,
        tail: LRUNode
    }

    Function.DataStructures.LRUCache.Create {
        Input: (capacity: Integer)
        Output: LRUCacheHandle
        Body: {
            cache = (Pool.DataStructures.Cache.Allocate())
            
            cache.capacity = capacity
            cache.size = 0
            cache.hash_table = (Apply(DataStructures.HashMap.Create, capacity))
            
            cache.head = (Pool.DataStructures.Cache.Allocate())
            cache.tail = (Pool.DataStructures.Cache.Allocate())
            
            cache.head.next = cache.tail
            cache.tail.prev = cache.head
            
            ReturnValue(cache)
        }
    }

    Function.DataStructures.LRUCache.Get {
        Input: (cache: LRUCacheHandle, key: Any)
        Output: OptionalType[Any]
        Body: {
            node = (Apply(DataStructures.HashMap.Get, cache.hash_table, key))
            
            IfCondition EqualTo(node, Null) ThenBlock {
                ReturnValue(Null)
            }
            
            Apply(DataStructures.LRUCache.MoveToFront, cache, node)
            
            ReturnValue(node.value)
        }
    }

    Function.DataStructures.LRUCache.Put {
        Input: (cache: LRUCacheHandle, key: Any, value: Any)
        Body: {
            existing_node = (Apply(DataStructures.HashMap.Get, cache.hash_table, key))
            
            IfCondition NotEqual(existing_node, Null) ThenBlock {
                existing_node.value = value
                Apply(DataStructures.LRUCache.MoveToFront, cache, existing_node)
                ReturnValue()
            }
            
            new_node = (Pool.DataStructures.Cache.Allocate())
            new_node.key = key
            new_node.value = value
            
            Apply(DataStructures.HashMap.Put, cache.hash_table, key, new_node)
            Apply(DataStructures.LRUCache.AddToFront, cache, new_node)
            cache.size = (Add(cache.size, 1))
            
            IfCondition GreaterThan(cache.size, cache.capacity) ThenBlock {
                Apply(DataStructures.LRUCache.EvictLeastUsed, cache)
            }
        }
    }

    Function.DataStructures.LRUCache.MoveToFront {
        Input: (cache: LRUCacheHandle, node: LRUNode)
        Body: {
            node.prev.next = node.next
            node.next.prev = node.prev
            
            Apply(DataStructures.LRUCache.AddToFront, cache, node)
        }
    }

    Function.DataStructures.LRUCache.AddToFront {
        Input: (cache: LRUCacheHandle, node: LRUNode)
        Body: {
            node.next = cache.head.next
            node.prev = cache.head
            cache.head.next.prev = node
            cache.head.next = node
        }
    }

    Function.DataStructures.LRUCache.EvictLeastUsed {
        Input: (cache: LRUCacheHandle)
        Body: {
            last_node = cache.tail.prev
            
            Apply(DataStructures.HashMap.Remove, cache.hash_table, last_node.key)
            
            last_node.prev.next = cache.tail
            cache.tail.prev = last_node.prev
            
            cache.size = (Subtract(cache.size, 1))
        }
    }

    // ============================================================================
    // Graph Implementation
    // ============================================================================

    GraphVertex = Record {
        id: Any,
        data: Any,
        adjacency_list: Array[GraphEdge],
        visited: Boolean,
        distance: FloatingPoint,
        parent: OptionalType[GraphVertex]
    }

    GraphEdge = Record {
        from_vertex: GraphVertex,
        to_vertex: GraphVertex,
        weight: FloatingPoint,
        data: Any
    }

    GraphHandle = Record {
        vertices: Map[Any, GraphVertex],
        edges: Array[GraphEdge],
        vertex_count: Integer,
        edge_count: Integer,
        directed: Boolean
    }

    Function.DataStructures.Graph.Create {
        Input: (directed: Boolean = True)
        Output: GraphHandle
        Body: {
            graph = (Pool.DataStructures.Graphs.Allocate())
            
            graph.vertices = (Apply(DataStructures.HashMap.Create))
            graph.edges = (Array.Create())
            graph.vertex_count = 0
            graph.edge_count = 0
            graph.directed = directed
            
            ReturnValue(graph)
        }
    }

    Function.DataStructures.Graph.AddVertex {
        Input: (graph: GraphHandle, id: Any, data: Any = Null)
        Body: {
            IfCondition NotEqual(Apply(DataStructures.HashMap.Get, graph.vertices, id), Null) ThenBlock {
                ReturnValue()
            }
            
            vertex = (Pool.DataStructures.Graphs.Allocate())
            vertex.id = id
            vertex.data = data
            vertex.adjacency_list = (Array.Create())
            vertex.visited = False
            vertex.distance = FloatingPoint.Infinity
            vertex.parent = Null
            
            Apply(DataStructures.HashMap.Put, graph.vertices, id, vertex)
            graph.vertex_count = (Add(graph.vertex_count, 1))
        }
    }

    Function.DataStructures.Graph.AddEdge {
        Input: (
            graph: GraphHandle,
            from_id: Any,
            to_id: Any,
            weight: FloatingPoint = 1.0,
            data: Any = Null
        )
        Body: {
            from_vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, from_id))
            to_vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, to_id))
            
            IfCondition Or(EqualTo(from_vertex, Null), EqualTo(to_vertex, Null)) ThenBlock {
                TryBlock: {} CatchError.VertexNotFound {}
            }
            
            edge = (Pool.DataStructures.Graphs.Allocate())
            edge.from_vertex = from_vertex
            edge.to_vertex = to_vertex
            edge.weight = weight
            edge.data = data
            
            Apply(Array.Push, from_vertex.adjacency_list, edge)
            Apply(Array.Push, graph.edges, edge)
            graph.edge_count = (Add(graph.edge_count, 1))
            
            IfCondition Not(graph.directed) ThenBlock {
                reverse_edge = (Pool.DataStructures.Graphs.Allocate())
                reverse_edge.from_vertex = to_vertex
                reverse_edge.to_vertex = from_vertex
                reverse_edge.weight = weight
                reverse_edge.data = data
                
                Apply(Array.Push, to_vertex.adjacency_list, reverse_edge)
            }
        }
    }

    Function.DataStructures.Graph.BFS {
        Input: (graph: GraphHandle, start_id: Any)
        Output: Array[Any]
        Body: {
            ForEvery vertex_id in Apply(DataStructures.HashMap.Keys, graph.vertices) {
                vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, vertex_id))
                vertex.visited = False
                vertex.distance = FloatingPoint.Infinity
                vertex.parent = Null
            }
            
            start_vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, start_id))
            IfCondition EqualTo(start_vertex, Null) ThenBlock {
                ReturnValue(Array.Create())
            }
            
            result = (Array.Create())
            queue = (Apply(DataStructures.Queue.Create))
            
            start_vertex.visited = True
            start_vertex.distance = 0.0
            Apply(DataStructures.Queue.Push, queue, start_vertex)
            
            WhileLoop Not(Apply(DataStructures.Queue.IsEmpty, queue)) {
                current_vertex = (Apply(DataStructures.Queue.Pop, queue))
                Apply(Array.Push, result, current_vertex.id)
                
                ForEvery edge in current_vertex.adjacency_list {
                    neighbor = edge.to_vertex
                    
                    IfCondition Not(neighbor.visited) ThenBlock {
                        neighbor.visited = True
                        neighbor.distance = (Add(current_vertex.distance, 1.0))
                        neighbor.parent = current_vertex
                        Apply(DataStructures.Queue.Push, queue, neighbor)
                    }
                }
            }
            
            ReturnValue(result)
        }
    }

    Function.DataStructures.Graph.DFS {
        Input: (graph: GraphHandle, start_id: Any)
        Output: Array[Any]
        Body: {
            ForEvery vertex_id in Apply(DataStructures.HashMap.Keys, graph.vertices) {
                vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, vertex_id))
                vertex.visited = False
            }
            
            start_vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, start_id))
            IfCondition EqualTo(start_vertex, Null) ThenBlock {
                ReturnValue(Array.Create())
            }
            
            result = (Array.Create())
            Apply(DataStructures.Graph.DFSRecursive, start_vertex, result)
            
            ReturnValue(result)
        }
    }

    Function.DataStructures.Graph.DFSRecursive {
        Input: (vertex: GraphVertex, result: Array[Any])
        Body: {
            vertex.visited = True
            Apply(Array.Push, result, vertex.id)
            
            ForEvery edge in vertex.adjacency_list {
                neighbor = edge.to_vertex
                IfCondition Not(neighbor.visited) ThenBlock {
                    Apply(DataStructures.Graph.DFSRecursive, neighbor, result)
                }
            }
        }
    }

    Function.DataStructures.Graph.Dijkstra {
        Input: (graph: GraphHandle, start_id: Any)
        Output: Map[Any, FloatingPoint]
        Body: {
            ForEvery vertex_id in Apply(DataStructures.HashMap.Keys, graph.vertices) {
                vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, vertex_id))
                vertex.distance = FloatingPoint.Infinity
                vertex.visited = False
                vertex.parent = Null
            }
            
            start_vertex = (Apply(DataStructures.HashMap.Get, graph.vertices, start_id))
            IfCondition EqualTo(start_vertex, Null) ThenBlock {
                ReturnValue(DataStructures.HashMap.Create())
            }
            
            start_vertex.distance = 0.0
            
            pq = (Apply(DataStructures.PriorityQueue.Create, heap_type-"min_heap"))
            Apply(DataStructures.PriorityQueue.Push, pq, start_vertex, 0.0)
            
            distances = (Apply(DataStructures.HashMap.Create))
            
            WhileLoop Not(Apply(DataStructures.PriorityQueue.IsEmpty, pq)) {
                current_vertex = (Apply(DataStructures.PriorityQueue.Pop, pq))
                
                IfCondition current_vertex.visited ThenBlock {
                    ContinueLoop
                }
                
                current_vertex.visited = True
                Apply(DataStructures.HashMap.Put, distances, current_vertex.id, current_vertex.distance)
                
                ForEvery edge in current_vertex.adjacency_list {
                    neighbor = edge.to_vertex
                    
                    IfCondition Not(neighbor.visited) ThenBlock {
                        new_distance = (Add(current_vertex.distance, edge.weight))
                        
                        IfCondition LessThan(new_distance, neighbor.distance) ThenBlock {
                            neighbor.distance = new_distance
                            neighbor.parent = current_vertex
                            Apply(DataStructures.PriorityQueue.Push, pq, neighbor, new_distance)
                        }
                    }
                }
            }
            
            ReturnValue(distances)
        }
    }

    // ============================================================================
    // Utility Functions
    // ============================================================================

    Function.DataStructures.Hash.String {
        Input: (str: Text)
        Output: UInt64
        Body: {
            hash = UInt64(5381)
            
            ForEvery char in StringToCharArray(str) {
                hash = (Add(Multiply(hash, 33), CharToCode(char)))
            }
            
            ReturnValue(hash)
        }
    }

    Function.DataStructures.Hash.Integer {
        Input: (num: Integer)
        Output: UInt64
        Body: {
            hash = UInt64(num)
            hash = (BitwiseXor(hash, RightShift(hash, 16)))
            hash = (Multiply(hash, 0x85ebca6b))
            hash = (BitwiseXor(hash, RightShift(hash, 13)))
            hash = (Multiply(hash, 0xc2b2ae35))
            hash = (BitwiseXor(hash, RightShift(hash, 16)))
            
            ReturnValue(hash)
        }
    }

    Function.DataStructures.Hash.Float {
        Input: (num: FloatingPoint)
        Output: UInt64
        Body: {
            int_bits = (FloatToBits(num))
            ReturnValue(Apply(DataStructures.Hash.Integer, int_bits))
        }
    }

    Function.DataStructures.Hash.Generic {
        Input: (obj: Any)
        Output: UInt64
        Body: {
            addr = (GetObjectAddress(obj))
            ReturnValue(Apply(DataStructures.Hash.Integer, addr))
        }
    }

    Function.DataStructures.KeyEquals {
        Input: (key1: Any, key2: Any)
        Output: Boolean
        Body: {
            IfCondition NotEqual(GetType(key1), GetType(key2)) ThenBlock {
                ReturnValue(False)
            }
            
            type_name = (GetTypeName(key1))
            
            ChoosePath type_name {
                CaseOption "Text": { ReturnValue(StringEquals(key1, key2)) }
                CaseOption "Integer": { ReturnValue(EqualTo(key1, key2)) }
                CaseOption "FloatingPoint": { ReturnValue(EqualTo(key1, key2)) }
                DefaultOption: { ReturnValue(EqualTo(GetObjectAddress(key1), GetObjectAddress(key2))) }
            }
        }
    }

    Function.DataStructures.Compare.Integer {
        Input: (a: Integer, b: Integer)
        Output: Integer
        Body: {
            IfCondition LessThan(a, b) ThenBlock {
                ReturnValue(-1)
            } ElseBlock {
                IfCondition GreaterThan(a, b) ThenBlock {
                    ReturnValue(1)
                } ElseBlock {
                    ReturnValue(0)
                }
            }
        }
    }

    Function.DataStructures.Compare.Float {
        Input: (a: FloatingPoint, b: FloatingPoint)
        Output: Integer
        Body: {
            epsilon = 1e-9
            diff = (Subtract(a, b))
            
            IfCondition LessThan(AbsoluteValue(diff), epsilon) ThenBlock {
                ReturnValue(0)
            } ElseBlock {
                IfCondition LessThan(a, b) ThenBlock {
                    ReturnValue(-1)
                } ElseBlock {
                    ReturnValue(1)
                }
            }
        }
    }

    Function.DataStructures.Compare.String {
        Input: (a: Text, b: Text)
        Output: Integer
        Body: {
            ReturnValue(StringCompare(a, b))
        }
    }

    Function.DataStructures.Compare.MinHeap {
        Input: (a: FloatingPoint, b: FloatingPoint)
        Output: Boolean
        Body: {
            ReturnValue(LessThan(a, b))
        }
    }

    Function.DataStructures.Compare.MaxHeap {
        Input: (a: FloatingPoint, b: FloatingPoint)
        Output: Boolean
        Body: {
            ReturnValue(GreaterThan(a, b))
        }
    }

    Function.DataStructures.Swap {
        Input: (array: Array[Any], i: Integer, j: Integer)
        Body: {
            temp = array[i]
            array[i] = array[j]
            array[j] = temp
        }
    }

    // ============================================================================
    // Queue Implementation (for BFS)
    // ============================================================================

    QueueHandle = Record {
        items: Array[Any],
        front: Integer,
        rear: Integer,
        size: Integer,
        capacity: Integer
    }

    Function.DataStructures.Queue.Create {
        Input: (initial_capacity: Integer = 16)
        Output: QueueHandle
        Body: {
            queue = (QueueHandle.Create())
            queue.items = (Array.Create(initial_capacity, Any))
            queue.front = 0
            queue.rear = 0
            queue.size = 0
            queue.capacity = initial_capacity
            
            ReturnValue(queue)
        }
    }

    Function.DataStructures.Queue.Push {
        Input: (queue: QueueHandle, item: Any)
        Body: {
            IfCondition EqualTo(queue.size, queue.capacity) ThenBlock {
                Apply(DataStructures.Queue.Resize, queue, Multiply(queue.capacity, 2))
            }
            
            queue.items[queue.rear] = item
            queue.rear = (Subtract(Add(queue.rear, 1), Multiply(queue.capacity, Divide(Add(queue.rear, 1), queue.capacity))))
            queue.size = (Add(queue.size, 1))
        }
    }

    Function.DataStructures.Queue.Pop {
        Input: (queue: QueueHandle)
        Output: OptionalType[Any]
        Body: {
            IfCondition EqualTo(queue.size, 0) ThenBlock {
                ReturnValue(Null)
            }
            
            item = queue.items[queue.front]
            queue.front = (Subtract(Add(queue.front, 1), Multiply(queue.capacity, Divide(Add(queue.front, 1), queue.capacity))))
            queue.size = (Subtract(queue.size, 1))
            
            ReturnValue(item)
        }
    }

    Function.DataStructures.Queue.IsEmpty {
        Input: (queue: QueueHandle)
        Output: Boolean
        Body: {
            ReturnValue(EqualTo(queue.size, 0))
        }
    }

    Function.DataStructures.Queue.Resize {
        Input: (queue: QueueHandle, new_capacity: Integer)
        Body: {
            new_items = (Array.Create(new_capacity, Any))
            
            ForEvery i in Range(0, queue.size) {
                index = (Subtract(Add(queue.front, i), Multiply(queue.capacity, Divide(Add(queue.front, i), queue.capacity))))
                new_items[i] = queue.items[index]
            }
            
            queue.items = new_items
            queue.front = 0
            queue.rear = queue.size
            queue.capacity = new_capacity
        }
    }

    // ============================================================================
    // Performance Monitoring
    // ============================================================================

    Function.DataStructures.Performance.GetHashTableStats {
        Input: (table: HashTableHandle)
        Output: HashTableStats
        Body: {
            stats = (HashTableStats.Create())
            stats.size = table.size
            stats.bucket_count = table.bucket_count
            stats.load_factor = (Divide(table.size, table.bucket_count))
            
            empty_buckets = 0
            max_chain_length = 0
            total_chain_length = 0
            
            ForEvery i in Range(0, table.bucket_count) {
                IfCondition EqualTo(table.buckets[i], Null) ThenBlock {
                    empty_buckets = (Add(empty_buckets, 1))
                } ElseBlock {
                    chain_length = 0
                    current = table.buckets[i]
                    
                    WhileLoop NotEqual(current, Null) {
                        chain_length = (Add(chain_length, 1))
                        current = current.next
                    }
                    
                    max_chain_length = (Max(max_chain_length, chain_length))
                    total_chain_length = (Add(total_chain_length, chain_length))
                }
            }
            
            stats.empty_buckets = empty_buckets
            stats.max_chain_length = max_chain_length
            stats.average_chain_length = (Divide(total_chain_length, Subtract(table.bucket_count, empty_buckets)))
            
            ReturnValue(stats)
        }
    }
}

