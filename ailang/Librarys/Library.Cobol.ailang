// Library.Cobol.ailang - FIXED VERSION with source_decimals support
// Now properly handles different decimal precisions in format functions

LibraryImport.FixedPointTrig
LibraryImport.XArrays

// =============================================================================
// COBOL LIBRARY STATE POOL - Integer workspace only!
// =============================================================================
FixedPool.COBOLState {
    "input_buffer": Initialize=0, CanChange=True
    "fmt_is_negative": Initialize=0, CanChange=True
    "fmt_abs_value": Initialize=0, CanChange=True
    "fmt_integer_part": Initialize=0, CanChange=True
    "fmt_fractional_part": Initialize=0, CanChange=True
    "fmt_source_scale": Initialize=1, CanChange=True
    "fmt_scale_down": Initialize=1, CanChange=True
    "fmt_scale_up": Initialize=1, CanChange=True
    "fmt_decimals_to_remove": Initialize=0, CanChange=True
    "fmt_decimals_to_add": Initialize=0, CanChange=True
    "fmt_half_scale": Initialize=0, CanChange=True
    "fmt_rounded_frac": Initialize=0, CanChange=True
    "fmt_frac_len": Initialize=0, CanChange=True
    "loop_i": Initialize=0, CanChange=True
    "loop_j": Initialize=0, CanChange=True
    "loop_len": Initialize=0, CanChange=True
    "sc_count": Initialize=0, CanChange=True
    "sc_text_len": Initialize=0, CanChange=True
    "sc_pattern_len": Initialize=0, CanChange=True
    "sc_pos": Initialize=0, CanChange=True
    "sc_should_continue": Initialize=1, CanChange=True
    "sc_found_pos": Initialize=0, CanChange=True
    "sra_iteration": Initialize=0, CanChange=True
    "sra_max_iterations": Initialize=100, CanChange=True
    "sra_pos": Initialize=0, CanChange=True
    "fzs_found_nonzero": Initialize=0, CanChange=True
    "faf_found_nonzero": Initialize=0, CanChange=True
    "fwi_abs_value": Initialize=0, CanChange=True
    "fwi_is_negative": Initialize=0, CanChange=True
    "fwi_indicator_len": Initialize=0, CanChange=True
    "fs_is_leading": Initialize=0, CanChange=True
    "acn_decimal_pos": Initialize=-1, CanChange=True
    "acn_found_decimal": Initialize=0, CanChange=True
    "acn_int_len": Initialize=0, CanChange=True
    "acn_counter": Initialize=0, CanChange=True
    "acn_remainder": Initialize=0, CanChange=True
}

// =============================================================================
// USER INPUT FUNCTIONS
// =============================================================================

Function.GetUserInput {
    Output: Address
    Body: {
        Debug("GetUserInput.entry", level=2) {
            PrintMessage(">>> ENTER: GetUserInput")
        }
        Debug("GetUserInput.call", level=3) {
            PrintMessage("  Calling: ReadInput")
        }
        COBOLState.input_buffer = ReadInput()
        Debug("GetUserInput.exit", level=2) {
            PrintMessage("<<< EXIT: GetUserInput")
        }
        ReturnValue(COBOLState.input_buffer)
    }
}

// =============================================================================
// COBOL STRING HELPER FUNCTIONS
// =============================================================================

Function.StringCount {
    Input: text
    Input: pattern
    Output: Integer
    Body: {
        Debug("StringCount.entry", level=2) {
            PrintMessage(">>> ENTER: StringCount")
            PrintMessage(StringConcat("  text: '", StringConcat(text, "'")))
            PrintMessage(StringConcat("  pattern: '", StringConcat(pattern, "'")))
        }
        COBOLState.sc_count = 0
        Debug("StringCount.call", level=3) {
            PrintMessage("  Calling: StringLength")
        }
        COBOLState.sc_text_len = StringLength(text)
        Debug("StringCount.call", level=3) {
            PrintMessage("  Calling: StringLength")
        }
        COBOLState.sc_pattern_len = StringLength(pattern)
        COBOLState.sc_pos = 0
        COBOLState.sc_should_continue = 1
        
        Debug("StringCount.loop", level=3) {
            PrintMessage("  Starting loop iteration")
        }
        WhileLoop And(LessThan(COBOLState.sc_pos, COBOLState.sc_text_len), EqualTo(COBOLState.sc_should_continue, 1)) {
            Debug("StringCount.call", level=3) {
                PrintMessage("  Calling: StringIndexOf")
            }
            COBOLState.sc_found_pos = StringIndexOf(text, pattern, COBOLState.sc_pos)
            
            IfCondition EqualTo(COBOLState.sc_found_pos, -1) ThenBlock: {
                COBOLState.sc_should_continue = 0
            } ElseBlock: {
                COBOLState.sc_count = Add(COBOLState.sc_count, 1)
                COBOLState.sc_pos = Add(COBOLState.sc_found_pos, COBOLState.sc_pattern_len)
            }
        }
        
        Debug("StringCount.exit", level=2) {
            PrintMessage(StringConcat("<<< EXIT: StringCount with count: ", NumberToString(COBOLState.sc_count)))
        }
        ReturnValue(COBOLState.sc_count)
    }
}

Function.StringReplaceAll {
    Input: haystack
    Input: needle
    Input: replacement
    Output: Address
    Body: {
        Debug("StringReplaceAll.entry", level=2) {
            PrintMessage(">>> ENTER: StringReplaceAll")
            PrintMessage(StringConcat("  haystack: '", StringConcat(haystack, "'")))
            PrintMessage(StringConcat("  needle: '", StringConcat(needle, "'")))
            PrintMessage(StringConcat("  replacement: '", StringConcat(replacement, "'")))
        }
        result = haystack
        COBOLState.sra_iteration = 0
        
        Debug("StringReplaceAll.loop", level=3) {
            PrintMessage("  Starting loop iteration")
        }
        WhileLoop LessThan(COBOLState.sra_iteration, COBOLState.sra_max_iterations) {
            Debug("StringReplaceAll.call", level=3) {
                PrintMessage("  Calling: StringIndexOf")
            }
            COBOLState.sra_pos = StringIndexOf(result, needle, 0)
            
            IfCondition LessThan(COBOLState.sra_pos, 0) ThenBlock: {
                ReturnValue(result)
            }
            Debug("StringReplaceAll.call", level=3) {
                PrintMessage("  Calling: StringReplace")
            }
            result = StringReplace(result, needle, replacement)
            COBOLState.sra_iteration = Add(COBOLState.sra_iteration, 1)
        }
        
        Debug("StringReplaceAll.exit", level=2) {
            PrintMessage(StringConcat("<<< EXIT: StringReplaceAll with result: '", StringConcat(result, "'")))
        }
        ReturnValue(result)
    }
}

// =============================================================================
// COBOL-SPECIFIC STRING SPLIT (supports ALL flag)
// =============================================================================

Function.CStringSplit {
    Input: haystack      // String to split
    Input: delimiter     // Delimiter to split on
    Input: use_all       // 1 = treat consecutive delimiters as one, 0 = each delimiter creates entry
    Output: Address      // Returns array of strings
    Body: {
        Debug("CStringSplit.entry", level=2) {
            PrintMessage(">>> ENTER: CStringSplit")
            PrintMessage(StringConcat("  haystack: '", StringConcat(haystack, "'")))
            PrintMessage(StringConcat("  delimiter: '", StringConcat(delimiter, "'")))
            PrintMessage(StringConcat("  use_all: ", NumberToString(use_all)))
        }
        Debug("CStringSplit", level=3) {
            PrintMessage("--- DEBUG: CStringSplit ---")
            PrintMessage(StringConcat("  haystack: ", haystack))
            PrintMessage(StringConcat("  delimiter: ", delimiter))
            PrintMessage(StringConcat("  use_all: ", NumberToString(use_all)))
        }
        
        // If use_all=1, replace consecutive delimiters with single delimiter
        processed_haystack = haystack
        IfCondition EqualTo(use_all, 1) ThenBlock: {
            // Replace consecutive delimiters: "a  b" with delimiter=" " becomes "a b"
            Debug("CStringSplit.call", level=3) {
                PrintMessage("  Calling: StringConcat")
            }
            double_delim = StringConcat(delimiter, delimiter)
            COBOLState.sra_iteration = 0
            
            Debug("CStringSplit.loop", level=3) {
                PrintMessage("  Starting loop to collapse delimiters")
            }
            WhileLoop LessThan(COBOLState.sra_iteration, 100) {
                Debug("CStringSplit.call", level=3) {
                    PrintMessage("  Calling: StringIndexOf")
                }
                COBOLState.sra_pos = StringIndexOf(processed_haystack, double_delim, 0)
                
                IfCondition LessThan(COBOLState.sra_pos, 0) ThenBlock: {
                    COBOLState.sra_iteration = 100  // Break loop
                } ElseBlock: {
                    Debug("CStringSplit.call", level=3) {
                        PrintMessage("  Calling: StringReplace")
                    }
                    processed_haystack = StringReplace(processed_haystack, double_delim, delimiter)
                    COBOLState.sra_iteration = Add(COBOLState.sra_iteration, 1)
                }
            }
        }
        
        // Now do the regular split
        Debug("CStringSplit.call", level=3) {
            PrintMessage("  Calling: StringSplit")
            PrintMessage(StringConcat("    processed_haystack: '", StringConcat(processed_haystack, "'")))
            PrintMessage(StringConcat("    delimiter: '", StringConcat(delimiter, "'")))
        }
        result = StringSplit(processed_haystack, delimiter)
        
        Debug("CStringSplit", level=3) {
            PrintMessage(StringConcat("  Result array length: ", NumberToString(ArrayLength(result))))
        }
        
        Debug("CStringSplit.exit", level=2) {
            PrintMessage(StringConcat("<<< EXIT: CStringSplit with array length: ", NumberToString(ArrayLength(result))))
        }
        ReturnValue(result)
    }
}

// =============================================================================
// DECIMAL FORMATTING FOR DISPLAY - FIXED VERSION
// =============================================================================

Function.FormatDecimal {
    Input: value
    Input: source_decimals    // NEW: How many decimals in the source (0, 2, 4, etc.)
    Input: target_decimals    // How many decimals to display
    Output: Address
    Body: {
        Debug("FormatDecimal.entry", level=2) {
            PrintMessage(">>> ENTER: FormatDecimal")
            PrintMessage(StringConcat("  value: ", NumberToString(value)))
            PrintMessage(StringConcat("  source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  target_decimals: ", NumberToString(target_decimals)))
        }
        Debug("FormatDecimal.trace", level=3) {
            PrintMessage("--- TRACE: FormatDecimal ---")
            PrintMessage(StringConcat("  Input value: ", NumberToString(value)))
            PrintMessage(StringConcat("  Input source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  Input target_decimals: ", NumberToString(target_decimals)))
        }
        
        COBOLState.fmt_is_negative = LessThan(value, 0)
        COBOLState.fmt_abs_value = value
        
        IfCondition COBOLState.fmt_is_negative ThenBlock: {
            COBOLState.fmt_abs_value = Subtract(0, value)
        }
        
        // Calculate the source scale (10^source_decimals)
        COBOLState.fmt_source_scale = 1
        COBOLState.loop_i = 0
        WhileLoop LessThan(COBOLState.loop_i, source_decimals) {
            COBOLState.fmt_source_scale = Multiply(COBOLState.fmt_source_scale, 10)
            COBOLState.loop_i = Add(COBOLState.loop_i, 1)
        }
        
        // Use source_scale instead of hardcoded 10000
        COBOLState.fmt_integer_part = Divide(COBOLState.fmt_abs_value, COBOLState.fmt_source_scale)
        COBOLState.fmt_fractional_part = Modulo(COBOLState.fmt_abs_value, COBOLState.fmt_source_scale)
        
        Debug("FormatDecimal.trace", level=4) {
            PrintMessage(StringConcat("    - source_scale: ", NumberToString(COBOLState.fmt_source_scale)))
            PrintMessage(StringConcat("    - integer_part: ", NumberToString(COBOLState.fmt_integer_part)))
            PrintMessage(StringConcat("    - fractional_part: ", NumberToString(COBOLState.fmt_fractional_part)))
        }
        
        // Calculate how much to scale from source to target
        COBOLState.fmt_decimals_to_remove = Subtract(source_decimals, target_decimals)
        COBOLState.fmt_scale_down = 1
        COBOLState.fmt_scale_up = 1
        
        // Only scale down if source has more decimals than target
        IfCondition GreaterThan(COBOLState.fmt_decimals_to_remove, 0) ThenBlock: {
            COBOLState.loop_i = 0
            WhileLoop LessThan(COBOLState.loop_i, COBOLState.fmt_decimals_to_remove) {
                COBOLState.fmt_scale_down = Multiply(COBOLState.fmt_scale_down, 10)
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
            
            COBOLState.fmt_half_scale = Divide(COBOLState.fmt_scale_down, 2)
            COBOLState.fmt_rounded_frac = Divide(Add(COBOLState.fmt_fractional_part, COBOLState.fmt_half_scale), COBOLState.fmt_scale_down)
        } ElseBlock: {
            // Source has same or fewer decimals than target - need to scale UP
            COBOLState.fmt_decimals_to_add = Subtract(target_decimals, source_decimals)
            COBOLState.loop_j = 0
            WhileLoop LessThan(COBOLState.loop_j, COBOLState.fmt_decimals_to_add) {
                COBOLState.fmt_scale_up = Multiply(COBOLState.fmt_scale_up, 10)
                COBOLState.loop_j = Add(COBOLState.loop_j, 1)
            }
            COBOLState.fmt_rounded_frac = Multiply(COBOLState.fmt_fractional_part, COBOLState.fmt_scale_up)
        }
        
        Debug("FormatDecimal.trace", level=4) {
            PrintMessage(StringConcat("    - scale_down: ", NumberToString(COBOLState.fmt_scale_down)))
            PrintMessage(StringConcat("    - scale_up: ", NumberToString(COBOLState.fmt_scale_up)))
            PrintMessage(StringConcat("    - rounded_frac: ", NumberToString(COBOLState.fmt_rounded_frac)))
        }
        
        result = ""
        
        IfCondition COBOLState.fmt_is_negative ThenBlock: {
            result = "-"
        }
        
        result = StringConcat(result, NumberToString(COBOLState.fmt_integer_part))
        
        IfCondition GreaterThan(target_decimals, 0) ThenBlock: {
            result = StringConcat(result, ".")
            
            frac_str = NumberToString(COBOLState.fmt_rounded_frac)
            COBOLState.fmt_frac_len = StringLength(frac_str)
            
            // Pad with leading zeros to match target_decimals
            WhileLoop LessThan(COBOLState.fmt_frac_len, target_decimals) {
                frac_str = StringConcat("0", frac_str)
                COBOLState.fmt_frac_len = StringLength(frac_str)  // FIX: Recalculate length!
            }
            
            result = StringConcat(result, frac_str)
        }
        
        Debug("FormatDecimal.exit", level=2) {
            PrintMessage(StringConcat("<<< EXIT: FormatDecimal with result: '", StringConcat(result, "'")))
        }
        Debug("FormatDecimal.trace", level=4) {
            PrintMessage(StringConcat("    - Final string: ", result))
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// COBOL DISPLAY-EDITED FORMATTING FUNCTIONS - FIXED VERSIONS
// =============================================================================

Function.FormatCurrency {
    Input: value
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Input: symbol
    Input: has_commas
    Input: float_symbol
    Output: Address
    Body: {
        Debug("FormatCurrency.entry", level=2) {
            PrintMessage(">>> ENTER: FormatCurrency")
        }
        Debug("FormatCurrency.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(value, source_decimals, decimals)
        
        IfCondition EqualTo(has_commas, 1) ThenBlock:{
            Debug("FormatCurrency.call", level=3) {
                PrintMessage("  Calling: AddCommasToNumber")
            }
            formatted = AddCommasToNumber(formatted)
        }
        
        Debug("FormatCurrency.call", level=3) {
            PrintMessage("  Calling: StringConcat")
        }
        result = StringConcat(symbol, formatted)
        
        COBOLState.loop_len = StringLength(result)
        WhileLoop LessThan(COBOLState.loop_len, width) {
            result = StringConcat(" ", result)
            COBOLState.loop_len = Add(COBOLState.loop_len, 1)
        }
        
        Debug("FormatCurrency.exit", level=2) {
            PrintMessage("<<< EXIT: FormatCurrency")
        }
        ReturnValue(result)
    }
}

Function.FormatWithCommas {
    Input: value
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Output: Address
    Body: {
        Debug("FormatWithCommas.entry", level=2) {
            PrintMessage(">>> ENTER: FormatWithCommas")
        }
        Debug("FormatWithCommas.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(value, source_decimals, decimals)
        Debug("FormatWithCommas.call", level=3) {
            PrintMessage("  Calling: AddCommasToNumber")
        }
        result = AddCommasToNumber(formatted)
        
        COBOLState.loop_len = StringLength(result)
        WhileLoop LessThan(COBOLState.loop_len, width) {
            result = StringConcat(" ", result)
            COBOLState.loop_len = Add(COBOLState.loop_len, 1)
        }
        
        Debug("FormatWithCommas.exit", level=2) {
            PrintMessage("<<< EXIT: FormatWithCommas")
        }
        ReturnValue(result)
    }
}

Function.FormatZeroSuppress {
    Input: value
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Output: Address
    Body: {
        Debug("FormatZeroSuppress.entry", level=2) {
            PrintMessage(">>> ENTER: FormatZeroSuppress")
        }
        Debug("FormatZeroSuppress", level=3) {
            PrintMessage("--- DEBUG: FormatZeroSuppress ---")
            PrintMessage(StringConcat("  Input value: ", NumberToString(value)))
            PrintMessage(StringConcat("  Input source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  Input width: ", NumberToString(width)))
            PrintMessage(StringConcat("  Input decimals: ", NumberToString(decimals)))
        }
        
        Debug("FormatZeroSuppress.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(value, source_decimals, decimals)
        
        COBOLState.loop_len = StringLength(formatted)
        
        result = formatted
        WhileLoop LessThan(COBOLState.loop_len, width) {
            result = StringConcat(" ", result)
            COBOLState.loop_len = Add(COBOLState.loop_len, 1)
        }
        
        Debug("FormatZeroSuppress.exit", level=2) {
            PrintMessage("<<< EXIT: FormatZeroSuppress")
        }
        ReturnValue(result)
    }
}

Function.FormatAsteriskFill {
    Input: value
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Output: Address
    Body: {
        Debug("FormatAsteriskFill.entry", level=2) {
            PrintMessage(">>> ENTER: FormatAsteriskFill")
        }
        Debug("FormatAsteriskFill", level=3) {
            PrintMessage("--- DEBUG: FormatAsteriskFill ---")
            PrintMessage(StringConcat("  Input value: ", NumberToString(value)))
            PrintMessage(StringConcat("  Input source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  Input width: ", NumberToString(width)))
            PrintMessage(StringConcat("  Input decimals: ", NumberToString(decimals)))
        }
        
        Debug("FormatAsteriskFill.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(value, source_decimals, decimals)
        
        COBOLState.loop_len = StringLength(formatted)
        COBOLState.loop_i = 0
        COBOLState.faf_found_nonzero = 0
        
        WhileLoop And(LessThan(COBOLState.loop_i, COBOLState.loop_len), EqualTo(COBOLState.faf_found_nonzero, 0)) {
            Debug("FormatAsteriskFill.call", level=3) {
                PrintMessage("  Calling: StringSubstring")
            }
            char = StringSubstring(formatted, COBOLState.loop_i, Add(COBOLState.loop_i, 1))
            
            IfCondition EqualTo(EqualTo(char, "0"), 0) ThenBlock:{
                COBOLState.faf_found_nonzero = 1
            } ElseBlock: {
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
        }
        
        result = ""
        COBOLState.loop_j = 0
        
        WhileLoop LessThan(COBOLState.loop_j, COBOLState.loop_len) {
            IfCondition LessThan(COBOLState.loop_j, COBOLState.loop_i) ThenBlock:{
                result = StringConcat(result, "*")
            } ElseBlock: {
                Debug("FormatAsteriskFill.call", level=3) {
                    PrintMessage("  Calling: StringSubstring")
                }
                char = StringSubstring(formatted, COBOLState.loop_j, Add(COBOLState.loop_j, 1))
                result = StringConcat(result, char)
            }
            COBOLState.loop_j = Add(COBOLState.loop_j, 1)
        }
        
        padding_needed = Subtract(width, COBOLState.loop_len)
        COBOLState.loop_i = 0
        WhileLoop LessThan(COBOLState.loop_i, padding_needed) {
            result = StringConcat("*", result)
            COBOLState.loop_i = Add(COBOLState.loop_i, 1)
        }
        
        Debug("FormatAsteriskFill.exit", level=2) {
            PrintMessage("<<< EXIT: FormatAsteriskFill")
        }
        ReturnValue(result)
    }
}

Function.FormatWithIndicator {
    Input: value
    Input: indicator
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Output: Address
    Body: {
        Debug("FormatWithIndicator.entry", level=2) {
            PrintMessage(">>> ENTER: FormatWithIndicator")
        }
        Debug("FormatWithIndicator", level=3) {
            PrintMessage("--- DEBUG: FormatWithIndicator ---")
            PrintMessage(StringConcat("  Input value: ", NumberToString(value)))
            PrintMessage(StringConcat("  Input indicator: ", indicator))
            PrintMessage(StringConcat("  Input source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  Input width: ", NumberToString(width)))
            PrintMessage(StringConcat("  Input decimals: ", NumberToString(decimals)))
        }
        
        COBOLState.fwi_abs_value = value
        COBOLState.fwi_is_negative = LessThan(value, 0)
        
        IfCondition COBOLState.fwi_is_negative ThenBlock:{
            COBOLState.fwi_abs_value = Subtract(0, value)
        }
        
        Debug("FormatWithIndicator.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(COBOLState.fwi_abs_value, source_decimals, decimals)
        
        IfCondition COBOLState.fwi_is_negative ThenBlock:{
            result = StringConcat(formatted, indicator)
        } ElseBlock: {
            COBOLState.fwi_indicator_len = StringLength(indicator)
            spaces = ""
            COBOLState.loop_i = 0
            
            WhileLoop LessThan(COBOLState.loop_i, COBOLState.fwi_indicator_len) {
                spaces = StringConcat(spaces, " ")
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
            
            result = StringConcat(formatted, spaces)
        }
        
        COBOLState.loop_len = StringLength(result)
        WhileLoop LessThan(COBOLState.loop_len, width) {
            result = StringConcat(" ", result)
            COBOLState.loop_len = Add(COBOLState.loop_len, 1)
        }
        
        Debug("FormatWithIndicator.exit", level=2) {
            PrintMessage("<<< EXIT: FormatWithIndicator")
        }
        ReturnValue(result)
    }
}

Function.FormatSigned {
    Input: value
    Input: source_decimals    // NEW: How many decimals in source
    Input: width
    Input: decimals
    Input: position
    Output: Address
    Body: {
        Debug("FormatSigned.entry", level=2) {
            PrintMessage(">>> ENTER: FormatSigned")
        }
        Debug("FormatSigned", level=3) {
            PrintMessage("--- DEBUG: FormatSigned ---")
            PrintMessage(StringConcat("  Input value: ", NumberToString(value)))
            PrintMessage(StringConcat("  Input source_decimals: ", NumberToString(source_decimals)))
            PrintMessage(StringConcat("  Input width: ", NumberToString(width)))
            PrintMessage(StringConcat("  Input decimals: ", NumberToString(decimals)))
            PrintMessage(StringConcat("  Input position: ", position))
        }
        
        Debug("FormatSigned.call", level=3) {
            PrintMessage("  Calling: FormatDecimal")
        }
        formatted = FormatDecimal(value, source_decimals, decimals)
        
        sign = " "
        
        IfCondition LessThan(value, 0) ThenBlock: {
            sign = "-"
        } ElseBlock: {
            IfCondition GreaterThan(value, 0) ThenBlock: {
                sign = "+"
            }
        }
        
        Debug("FormatSigned.call", level=3) {
            PrintMessage("  Calling: StringEquals")
        }
        COBOLState.fs_is_leading = StringEquals(position, "leading")
        
        IfCondition COBOLState.fs_is_leading ThenBlock: {
            result = StringConcat(sign, formatted)
        } ElseBlock: {
            result = StringConcat(formatted, sign)
        }
        
        COBOLState.loop_len = StringLength(result)
        WhileLoop LessThan(COBOLState.loop_len, width) {
            result = StringConcat(" ", result)
            COBOLState.loop_len = Add(COBOLState.loop_len, 1)
        }
        
        Debug("FormatSigned.exit", level=2) {
            PrintMessage("<<< EXIT: FormatSigned")
        }
        ReturnValue(result)
    }
}

Function.AddCommasToNumber {
    Input: number_str
    Output: Address
    Body: {
        Debug("AddCommasToNumber.entry", level=2) {
            PrintMessage(">>> ENTER: AddCommasToNumber")
        }
        Debug("AddCommasToNumber", level=3) {
            PrintMessage("--- DEBUG: AddCommasToNumber ---")
            PrintMessage(StringConcat("  Input number_str: ", number_str))
        }
        
        COBOLState.loop_len = StringLength(number_str)
        COBOLState.acn_decimal_pos = -1
        COBOLState.loop_i = 0
        COBOLState.acn_found_decimal = 0
        
        WhileLoop And(LessThan(COBOLState.loop_i, COBOLState.loop_len), EqualTo(COBOLState.acn_found_decimal, 0)) {
            Debug("AddCommasToNumber.call", level=3) {
                PrintMessage("  Calling: StringSubstring")
            }
            char = StringSubstring(number_str, COBOLState.loop_i, Add(COBOLState.loop_i, 1))
            
            IfCondition EqualTo(char, ".") ThenBlock:{
                COBOLState.acn_decimal_pos = COBOLState.loop_i
                COBOLState.acn_found_decimal = 1
            } ElseBlock: {
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
        }
        
        integer_part = ""
        decimal_part = ""
        
        IfCondition EqualTo(COBOLState.acn_decimal_pos, -1) ThenBlock:{
            integer_part = number_str
        } ElseBlock: {
            COBOLState.loop_i = 0
            
            WhileLoop LessThan(COBOLState.loop_i, COBOLState.acn_decimal_pos) {
                Debug("AddCommasToNumber.call", level=3) {
                    PrintMessage("  Calling: StringSubstring")
                }
                char = StringSubstring(number_str, COBOLState.loop_i, Add(COBOLState.loop_i, 1))
                integer_part = StringConcat(integer_part, char)
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
            
            COBOLState.loop_i = COBOLState.acn_decimal_pos
            
            WhileLoop LessThan(COBOLState.loop_i, COBOLState.loop_len) {
                Debug("AddCommasToNumber.call", level=3) {
                    PrintMessage("  Calling: StringSubstring")
                }
                char = StringSubstring(number_str, COBOLState.loop_i, Add(COBOLState.loop_i, 1))
                decimal_part = StringConcat(decimal_part, char)
                COBOLState.loop_i = Add(COBOLState.loop_i, 1)
            }
        }
        
        COBOLState.acn_int_len = StringLength(integer_part)
        result = ""
        COBOLState.acn_counter = 0
        COBOLState.loop_i = Subtract(COBOLState.acn_int_len, 1)
        
        WhileLoop GreaterEqual(COBOLState.loop_i, 0) {
            Debug("AddCommasToNumber.call", level=3) {
                PrintMessage("  Calling: StringSubstring")
            }
            char = StringSubstring(integer_part, COBOLState.loop_i, Add(COBOLState.loop_i, 1))
            result = StringConcat(char, result)
            COBOLState.acn_counter = Add(COBOLState.acn_counter, 1)
            
            COBOLState.acn_remainder = Modulo(COBOLState.acn_counter, 3)
            
            IfCondition And(EqualTo(COBOLState.acn_remainder, 0), GreaterThan(COBOLState.loop_i, 0)) ThenBlock:{
                Debug("AddCommasToNumber.call", level=3) {
                    PrintMessage("  Calling: StringSubstring")
                }
                prev_char = StringSubstring(integer_part, Subtract(COBOLState.loop_i, 1), COBOLState.loop_i)
                
                IfCondition EqualTo(EqualTo(prev_char, "-"), 0) ThenBlock:{
                    result = StringConcat(",", result)
                }
            }
            
            COBOLState.loop_i = Subtract(COBOLState.loop_i, 1)
        }
        
        result = StringConcat(result, decimal_part)
        
        Debug("AddCommasToNumber.exit", level=2) {
            PrintMessage("<<< EXIT: AddCommasToNumber")
        }
        ReturnValue(result)
    }
}

// =============================================================================
// COBOL File IO stub functions
// =============================================================================    
Function.FileOpen {
    Input: filename
    Input: mode
    Output: Integer
    Body: {
        ReturnValue(1)  // Always succeed
    }
}

Function.FileRead {
    Input: handle
    Output: Address
    Body: {
        ReturnValue("")  // Return empty string
    }
}

Function.FileWrite {
    Input: handle
    Input: data
    Output: Integer
    Body: {
        ReturnValue(1)  // Always succeed
    }
}

Function.FileClose {
    Input: handle
    Output: Integer
    Body: {
        ReturnValue(1)  // Always succeed
    }
}