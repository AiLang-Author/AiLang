// Library.HashMap.ailang
// Enhanced hash table with modern syntax and cache optimization
// Extends existing HashMap functionality

LibraryImport.XArrays

// --- START: Added Helper Functions ---
// These functions are added to make the library self-contained.

// Helper function to convert string to integer
Function.HashMap.StringToInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        len = StringLength(str)
        negative = 0
        
        IfCondition GreaterThan(len, 0) ThenBlock: {
            first = GetByte(str, 0)
            IfCondition EqualTo(first, 45) ThenBlock: {  // '-'
                negative = 1
                i = 1
            }
        }
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            IfCondition And(GreaterEqual(byte, 48), LessEqual(byte, 57)) ThenBlock: {
                digit = Subtract(byte, 48)
                result = Multiply(result, 10)
                result = Add(result, digit)
            }
            i = Add(i, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Helper to convert integer to string
Function.HashMap.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        pos = 0
        value = num
        
        IfCondition LessThan(value, 0) ThenBlock: {
            SetByte(buffer, pos, 45)  // '-'
            pos = Add(pos, 1)
            value = Subtract(0, value)
        }
        
        IfCondition EqualTo(value, 0) ThenBlock: {
            SetByte(buffer, pos, 48)  // '0'
            pos = Add(pos, 1)
            SetByte(buffer, pos, 0)   // null terminate
            ReturnValue(buffer)
        }
        
        start_pos = pos
        WhileLoop GreaterThan(value, 0) {
            digit = Modulo(value, 10)
            SetByte(buffer, pos, Add(48, digit))
            pos = Add(pos, 1)
            value = Divide(value, 10)
        }
        
        end_pos = Subtract(pos, 1)
        WhileLoop LessThan(start_pos, end_pos) {
            temp = GetByte(buffer, start_pos)
            SetByte(buffer, start_pos, GetByte(buffer, end_pos))
            SetByte(buffer, end_pos, temp)
            start_pos = Add(start_pos, 1)
            end_pos = Subtract(end_pos, 1)
        }
        
        SetByte(buffer, pos, 0)
        ReturnValue(buffer)
    }
}

// --- END: Added Helper Functions ---

Function.HashMap.StringCopy {
    Input: source: Address
    Output: Address
    Body: {
        IfCondition EqualTo(source, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        len = StringLength(source)
        copy = Allocate(Add(len, 1))
        
        i = 0
        WhileLoop LessThan(i, len) {
            byte = GetByte(source, i)
            SetByte(copy, i, byte)
            i = Add(i, 1)
        }
        SetByte(copy, len, 0)  // Null terminator
        
        ReturnValue(copy)
    }
}

// ============================================================================
// Original Nested Hash Table (for hash-of-hashes)
// ============================================================================

// Create a new HashMap (hash of hashes)
Function.HashMap.Create {
    Output: Address
    Body: {
        // Main hash table that stores other hash tables as values
        hashmap = XSHash.XCreate(256)
        ReturnValue(hashmap)
    }
}

// Set a field in a hash
// Returns: 1 if new field was created, 0 if existing field was updated
Function.HashMap.HSet {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Input: value: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        // Create inner hash if it doesn't exist
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            inner_hash = XSHash.XCreate(16)
            XSHash.XInsert(hashmap, key, inner_hash)
        }
        
        // Make a copy of the value
        value_copy = HashMap.StringCopy(value)
        
        // Check if field exists before inserting
        existing_value = XSHash.XLookup(inner_hash, field)
        
        // If field exists, we need to free the old value first
        IfCondition NotEqual(existing_value, XArrays.XNULL) ThenBlock: {
            Deallocate(existing_value, 0)
        }
        
        // XSHash.XInsert now returns 1 for new, 0 for update
        is_new_field = XSHash.XInsert(inner_hash, field, value_copy)
        
        ReturnValue(is_new_field)
    }
}

// Get a field from a hash
// Returns: Address of value or 0 if not found
Function.HashMap.HGet {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Address
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the field value from inner hash
        value = XSHash.XLookup(inner_hash, field)
        
        IfCondition EqualTo(value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(value)
    }
}

// Get all fields and values from a hash
// Returns: XArray with alternating field/value pairs
Function.HashMap.HGetAll {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = XSHash.XLookup(inner_hash, field)
            
            // Add field and value to result
            XArray.XPush(result, field)
            XArray.XPush(result, value)
            
            i = Add(i, 1)
        }
        
        // Note: fields array contains copies from XKeys, caller must clean up
        XArray.XDestroy(fields)
        
        ReturnValue(result)
    }
}

// Delete a field from a hash
// Returns: 1 if field was deleted, 0 if not found
Function.HashMap.HDel {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Delete the field from inner hash
        old_value = XSHash.XDelete(inner_hash, field)
        
        IfCondition EqualTo(old_value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Free the old value
        Deallocate(old_value, 0)
        
        // Check if inner hash is now empty
        keys = XSHash.XKeys(inner_hash)
        num_keys = XArray.XSize(keys)
        
        // Clean up keys array (contains copies)
        i = 0
        WhileLoop LessThan(i, num_keys) {
            key_copy = XArray.XGet(keys, i)
            Deallocate(key_copy, 0)
            i = Add(i, 1)
        }
        XArray.XDestroy(keys)
        
        // If inner hash is empty, remove it from main hashmap
        IfCondition EqualTo(num_keys, 0) ThenBlock: {
            XSHash.XDelete(hashmap, key)
            XSHash.XDestroy(inner_hash)
        }
        
        ReturnValue(1)
    }
}

// Check if a field exists in a hash
// Returns: 1 if exists, 0 if not
Function.HashMap.HExists {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if field exists in inner hash
        value = XSHash.XLookup(inner_hash, field)
        
        IfCondition EqualTo(value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

// Get all field names from a hash
// Returns: XArray of field names
Function.HashMap.HKeys {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        
        // Fields already contains copies, just return it
        ReturnValue(fields)
    }
}

// Get all values from a hash
// Returns: XArray of values
Function.HashMap.HVals {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = XSHash.XLookup(inner_hash, field)
            
            // Add copy of value to result
            value_copy = HashMap.StringCopy(value)
            XArray.XPush(result, value_copy)
            
            // Clean up field copy
            Deallocate(field, 0)
            
            i = Add(i, 1)
        }
        
        XArray.XDestroy(fields)
        ReturnValue(result)
    }
}

// Get the number of fields in a hash
// Returns: Number of fields
Function.HashMap.HLen {
    Input: hashmap: Address
    Input: key: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Count the fields
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        // Clean up fields array
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            Deallocate(field, 0)
            i = Add(i, 1)
        }
        XArray.XDestroy(fields)
        
        ReturnValue(num_fields)
    }
}

// Set multiple fields at once
// fields_values is an XArray with alternating field/value pairs
// Returns: Number of new fields created
Function.HashMap.HMSet {
    Input: hashmap: Address
    Input: key: Address
    Input: fields_values: Address
    Output: Integer
    Body: {
        new_fields = 0
        array_size = XArray.XSize(fields_values)
        
        // Process pairs
        i = 0
        WhileLoop LessThan(i, array_size) {
            field = XArray.XGet(fields_values, i)
            value = XArray.XGet(fields_values, Add(i, 1))
            
            is_new = HashMap.HSet(hashmap, key, field, value)
            new_fields = Add(new_fields, is_new)
            
            i = Add(i, 2)
        }
        
        ReturnValue(new_fields)
    }
}

// Get multiple fields at once
// fields is an XArray of field names
// Returns: XArray of values (0 for non-existent fields)
Function.HashMap.HMGet {
    Input: hashmap: Address
    Input: key: Address
    Input: fields: Address
    Output: Address
    Body: {
        num_fields = XArray.XSize(fields)
        result = XArray.XCreate(num_fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = HashMap.HGet(hashmap, key, field)
            
            // Add value or 0 for non-existent
            XArray.XPush(result, value)
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Increment a numeric field by a given amount
// Returns: New value after increment
Function.HashMap.HIncrBy {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Input: increment: Integer
    Output: Integer
    Body: {
        // Get current value
        current_str = HashMap.HGet(hashmap, key, field)
        current_val = 0
        
        IfCondition NotEqual(current_str, 0) ThenBlock: {
            current_val = HashMap.StringToInt(current_str)
        }
        
        // Increment
        new_val = Add(current_val, increment)
        
        // Store new value
        new_str = HashMap.IntToString(new_val)
        HashMap.HSet(hashmap, key, field, new_str)
        Deallocate(new_str, 0)
        
        ReturnValue(new_val)
    }
}

// Destroy a HashMap and all its contents
Function.HashMap.Destroy {
    Input: hashmap: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(hashmap, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get all main keys
        main_keys = XSHash.XKeys(hashmap)
        num_keys = XArray.XSize(main_keys)
        
        i = 0
        WhileLoop LessThan(i, num_keys) {
            key = XArray.XGet(main_keys, i)
            inner_hash = XSHash.XLookup(hashmap, key)
            
            IfCondition NotEqual(inner_hash, XArrays.XNULL) ThenBlock: {
                // Get all fields in this inner hash
                fields = XSHash.XKeys(inner_hash)
                num_fields = XArray.XSize(fields)
                
                j = 0
                WhileLoop LessThan(j, num_fields) {
                    field = XArray.XGet(fields, j)
                    value = XSHash.XLookup(inner_hash, field)
                    
                    // Free the value
                    IfCondition NotEqual(value, XArrays.XNULL) ThenBlock: {
                        Deallocate(value, 0)
                    }
                    
                    // Free the field copy
                    Deallocate(field, 0)
                    
                    j = Add(j, 1)
                }
                
                XArray.XDestroy(fields)
                XSHash.XDestroy(inner_hash)
            }
            
            // Free the key copy
            Deallocate(key, 0)
            
            i = Add(i, 1)
        }
        
        XArray.XDestroy(main_keys)
        XSHash.XDestroy(hashmap)
        
        ReturnValue(1)
    }
}

// ============================================================================
// Enhanced Hash Table with Open Addressing
// ============================================================================

// Create hash table with linear probing
Function.HashMap.CreateOpen {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Structure: [capacity, size, keys, values, deleted_flags]
        table = Allocate(40)
        StoreValue(table, capacity)
        StoreValue(Add(table, 8), 0)
        
        // Allocate arrays for keys, values, and deleted flags
        keys = ArrayCreate(capacity)
        values = ArrayCreate(capacity)
        deleted = ArrayCreate(capacity)
        
        // Initialize all slots as empty
        i = 0
        WhileLoop LessThan(i, capacity) {
            ArraySet(keys, i, 0)
            ArraySet(values, i, 0)
            ArraySet(deleted, i, 0)
            i = Add(i, 1)
        }
        
        StoreValue(Add(table, 16), keys)
        StoreValue(Add(table, 24), values)
        StoreValue(Add(table, 32), deleted)
        
        ReturnValue(table)
    }
}

// Robin Hood hashing for better cache performance
Function.HashMap.InsertRobinHood {
    Input: table: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        capacity = Dereference(table)
        size = Dereference(Add(table, 8))
        
        // Check load factor
        IfCondition GreaterThan(size, Multiply(capacity, 0.75)) ThenBlock: {
            HashMap.ResizeOpen(table)
            capacity = Dereference(table)
        }
        
        hash = HashMap.HashString(key)
        ideal_pos = Modulo(hash, capacity)
        
        keys_array = Dereference(Add(table, 16))
        values_array = Dereference(Add(table, 24))
        deleted_array = Dereference(Add(table, 32))
        
        current_key = HashMap.StringCopy(key)
        current_value = HashMap.StringCopy(value)
        current_distance = 0
        pos = ideal_pos
        
        WhileLoop True {
            existing_key = ArrayGet(keys_array, pos)
            is_deleted = ArrayGet(deleted_array, pos)
            
            // Empty or deleted slot - insert here
            IfCondition Or(EqualTo(existing_key, 0), EqualTo(is_deleted, 1)) ThenBlock: {
                ArraySet(keys_array, pos, current_key)
                ArraySet(values_array, pos, current_value)
                ArraySet(deleted_array, pos, 0)
                
                new_size = Add(size, 1)
                StoreValue(Add(table, 8), new_size)
                ReturnValue(1)
            }
            
            // Check if same key - update
            IfCondition EqualTo(StringCompare(existing_key, current_key), 0) ThenBlock: {
                Deallocate(ArrayGet(values_array, pos), 0)
                ArraySet(values_array, pos, current_value)
                Deallocate(current_key, 0)
                ReturnValue(0)
            }
            
            // Calculate existing item's distance from ideal position
            existing_hash = HashMap.HashString(existing_key)
            existing_ideal = Modulo(existing_hash, capacity)
            existing_distance = Modulo(Add(pos, capacity, Subtract(0, existing_ideal)), capacity)
            
            // Robin Hood: swap if current has traveled further
            IfCondition GreaterThan(current_distance, existing_distance) ThenBlock: {
                // Swap with existing
                temp_key = existing_key
                temp_value = ArrayGet(values_array, pos)
                
                ArraySet(keys_array, pos, current_key)
                ArraySet(values_array, pos, current_value)
                
                current_key = temp_key
                current_value = temp_value
                current_distance = existing_distance
            }
            
            // Move to next position
            pos = Modulo(Add(pos, 1), capacity)
            current_distance = Add(current_distance, 1)
            
            // Safety check
            IfCondition GreaterThan(current_distance, capacity) ThenBlock: {
                BreakLoop
            }
        }
        
        ReturnValue(0)
    }
}

// Cache-friendly batch operations
Function.HashMap.BatchInsert {
    Input: table: Address
    Input: keys: Address
    Input: values: Address
    Output: Integer
    Body: {
        num_items = XArray.XSize(keys)
        inserted = 0
        
        i = 0
        WhileLoop LessThan(i, num_items) {
            key = XArray.XGet(keys, i)
            value = XArray.XGet(values, i)
            
            result = HashMap.InsertRobinHood(table, key, value)
            inserted = Add(inserted, result)
            
            i = Add(i, 1)
        }
        
        ReturnValue(inserted)
    }
}

// ============================================================================
// Concurrent Hash Table with Striped Locking
// ============================================================================

Function.HashMap.CreateConcurrent {
    Input: num_stripes: Integer
    Output: Address
    Body: {
        // Structure: [num_stripes, tables_array, locks_array]
        concurrent_map = Allocate(24)
        StoreValue(concurrent_map, num_stripes)
        
        // Create array of hash tables
        tables = ArrayCreate(num_stripes)
        locks = ArrayCreate(num_stripes)
        
        i = 0
        WhileLoop LessThan(i, num_stripes) {
            table = HashMap.Create()
            lock = Allocate(8)  // Simple mutex
            
            ArraySet(tables, i, table)
            ArraySet(locks, i, lock)
            
            i = Add(i, 1)
        }
        
        StoreValue(Add(concurrent_map, 8), tables)
        StoreValue(Add(concurrent_map, 16), locks)
        
        ReturnValue(concurrent_map)
    }
}

Function.HashMap.ConcurrentPut {
    Input: concurrent_map: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        num_stripes = Dereference(concurrent_map)
        tables = Dereference(Add(concurrent_map, 8))
        locks = Dereference(Add(concurrent_map, 16))
        
        // Determine stripe based on key hash
        hash = HashMap.HashString(key)
        stripe_idx = Modulo(hash, num_stripes)
        
        // Acquire lock for this stripe
        lock = ArrayGet(locks, stripe_idx)
        HashMap.AcquireLock(lock)
        
        // Insert into the appropriate table
        table = ArrayGet(tables, stripe_idx)
        result = HashMap.HSet(table, key, "field", value)
        
        // Release lock
        HashMap.ReleaseLock(lock)
        
        ReturnValue(result)
    }
}

// ============================================================================
// LRU Cache Integration
// ============================================================================

Function.HashMap.CreateLRU {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Structure: [capacity, size, map, head, tail]
        lru = Allocate(40)
        StoreValue(lru, capacity)
        StoreValue(Add(lru, 8), 0)
        
        // Create backing hash map
        map = HashMap.Create()
        StoreValue(Add(lru, 16), map)
        
        // Create sentinel nodes for doubly-linked list
        head = Allocate(24)  // [key, value, prev, next]
        tail = Allocate(24)
        
        StoreValue(Add(head, 16), tail)  // head.next = tail
        StoreValue(Add(tail, 8), head)   // tail.prev = head
        
        StoreValue(Add(lru, 24), head)
        StoreValue(Add(lru, 32), tail)
        
        ReturnValue(lru)
    }
}

Function.HashMap.LRUGet {
    Input: lru: Address
    Input: key: Address
    Output: Address
    Body: {
        map = Dereference(Add(lru, 16))
        node_ptr = HashMap.HGet(map, "nodes", key)
        
        IfCondition EqualTo(node_ptr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move to front
        HashMap.LRUMoveToFront(lru, node_ptr)
        
        // Return value
        value = Dereference(Add(node_ptr, 8))
        ReturnValue(value)
    }
}

Function.HashMap.LRUPut {
    Input: lru: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        capacity = Dereference(lru)
        size = Dereference(Add(lru, 8))
        map = Dereference(Add(lru, 16))
        
        // Check if key exists
        existing = HashMap.HGet(map, "nodes", key)
        
        IfCondition NotEqual(existing, 0) ThenBlock: {
            // Update existing node
            old_value = Dereference(Add(existing, 8))
            Deallocate(old_value, 0)
            
            new_value = HashMap.StringCopy(value)
            StoreValue(Add(existing, 8), new_value)
            
            HashMap.LRUMoveToFront(lru, existing)
            ReturnValue(0)
        }
        
        // Create new node
        node = Allocate(32)  // [key, value, prev, next]
        key_copy = HashMap.StringCopy(key)
        value_copy = HashMap.StringCopy(value)
        
        StoreValue(node, key_copy)
        StoreValue(Add(node, 8), value_copy)
        
        // Add to front
        head = Dereference(Add(lru, 24))
        old_first = Dereference(Add(head, 24))
        
        StoreValue(Add(node, 16), head)      // node.prev = head
        StoreValue(Add(node, 24), old_first) // node.next = old_first
        StoreValue(Add(old_first, 16), node) // old_first.prev = node
        StoreValue(Add(head, 24), node)      // head.next = node
        
        // Store in map
        HashMap.HSet(map, "nodes", key, node)
        
        // Update size
        new_size = Add(size, 1)
        StoreValue(Add(lru, 8), new_size)
        
        // Evict if over capacity
        IfCondition GreaterThan(new_size, capacity) ThenBlock: {
            HashMap.LRUEvictLast(lru)
        }
        
        ReturnValue(1)
    }
}

Function.HashMap.LRUMoveToFront {
    Input: lru: Address
    Input: node: Address
    Body: {
        // Remove from current position
        prev = Dereference(Add(node, 16))
        next = Dereference(Add(node, 24))
        StoreValue(Add(prev, 24), next)
        StoreValue(Add(next, 16), prev)
        
        // Add to front
        head = Dereference(Add(lru, 24))
        old_first = Dereference(Add(head, 24))
        
        StoreValue(Add(node, 16), head)
        StoreValue(Add(node, 24), old_first)
        StoreValue(Add(old_first, 16), node)
        StoreValue(Add(head, 24), node)
    }
}

Function.HashMap.LRUEvictLast {
    Input: lru: Address
    Body: {
        tail = Dereference(Add(lru, 32))
        last = Dereference(Add(tail, 16))  // tail.prev
        
        // Skip if it's the head sentinel
        head = Dereference(Add(lru, 24))
        IfCondition EqualTo(last, head) ThenBlock: {
            ReturnValue()
        }
        
        // Remove from list
        prev = Dereference(Add(last, 16))
        StoreValue(Add(prev, 24), tail)
        StoreValue(Add(tail, 16), prev)
        
        // Remove from map
        map = Dereference(Add(lru, 16))
        key = Dereference(last)
        HashMap.HDel(map, "nodes", key)
        
        // Free memory
        value = Dereference(Add(last, 8))
        Deallocate(key, 0)
        Deallocate(value, 0)
        Deallocate(last, 0)
        
        // Update size
        size = Dereference(Add(lru, 8))
        StoreValue(Add(lru, 8), Subtract(size, 1))
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

Function.HashMap.HashString {
    Input: str: Address
    Output: Integer
    Body: {
        hash = 5381
        i = 0
        len = StringLength(str)
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            hash = Add(Multiply(hash, 33), byte)
            i = Add(i, 1)
        }
        
        ReturnValue(hash)
    }
}

Function.HashMap.AcquireLock {
    Input: lock: Address
    Body: {
        // Simple spinlock
        WhileLoop True {
            expected = 0
            IfCondition EqualTo(Dereference(lock), expected) ThenBlock: {
                StoreValue(lock, 1)
                BreakLoop
            }
            // Could add small delay here
        }
    }
}

Function.HashMap.ReleaseLock {
    Input: lock: Address
    Body: {
        StoreValue(lock, 0)
    }
}