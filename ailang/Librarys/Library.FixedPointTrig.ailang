// Library.FixedPointTrig.ailang
// Fixed-point trigonometry library for AILANG
// Uses integer arithmetic with scale factor of 10000 (4 decimal places)
// Angles in degrees for simplicity

PrintMessage("Loading Fixed-Point Trigonometry Library v1.0")
PrintMessage("==============================================")

// Fixed-point configuration
// Scale: 10000 = 1.0000 in fixed-point
// pi = 3.1416, half_pi = 1.5708, two_pi = 6.2832
// e = 2.7183, deg_to_rad = 0.0175, rad_to_deg = 57.2958
FixedPool.FixedPointTrig {
    "scale": Initialize=10000
    "pi": Initialize=31416
    "half_pi": Initialize=15708
    "two_pi": Initialize=62832
    "e": Initialize=27183
    "deg_to_rad": Initialize=175
    "rad_to_deg": Initialize=572958
}

// Sin lookup table (0-90 degrees)
// sin(0)=0, sin(1)=0.0175, sin(2)=0.0349, etc.
FixedPool.SinTable {
    "sin_0": Initialize=0
    "sin_1": Initialize=175
    "sin_2": Initialize=349
    "sin_3": Initialize=523
    "sin_4": Initialize=698
    "sin_5": Initialize=872
    "sin_6": Initialize=1045
    "sin_7": Initialize=1219
    "sin_8": Initialize=1392
    "sin_9": Initialize=1564
    "sin_10": Initialize=1736
    "sin_15": Initialize=2588
    "sin_20": Initialize=3420
    "sin_25": Initialize=4226
    "sin_30": Initialize=5000
    "sin_35": Initialize=5736
    "sin_40": Initialize=6428
    "sin_45": Initialize=7071
    "sin_50": Initialize=7660
    "sin_55": Initialize=8192
    "sin_60": Initialize=8660
    "sin_65": Initialize=9063
    "sin_70": Initialize=9397
    "sin_75": Initialize=9659
    "sin_80": Initialize=9848
    "sin_85": Initialize=9962
    "sin_90": Initialize=10000
}

// === ANGLE NORMALIZATION (moved to top to ensure it's declared first) ===

Function.Trig.NormalizeDegrees {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Normalize angle to 0-359 range
        angle = degrees
        
        // Handle negative angles
        WhileLoop LessThan(angle, 0) {
            angle = Add(angle, 360)
        }
        
        // Handle angles >= 360
        WhileLoop GreaterEqual(angle, 360) {
            angle = Subtract(angle, 360)
        }
        
        ReturnValue(angle)
    }
}

// === CONVERSION FUNCTIONS ===

Function.FixedPoint.FromInt {
    Input: value: Integer
    Output: Integer
    Body: {
        // Convert integer to fixed-point
        ReturnValue(Multiply(value, FixedPointTrig.scale))
    }
}

Function.FixedPoint.ToInt {
    Input: fixed: Integer
    Output: Integer
    Body: {
        // Convert fixed-point to integer (with rounding)
        half_scale = Divide(FixedPointTrig.scale, 2)
        rounded = Add(fixed, half_scale)
        ReturnValue(Divide(rounded, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Multiply {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        // Multiply two fixed-point numbers
        product = Multiply(a, b)
        ReturnValue(Divide(product, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Divide {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        // Divide two fixed-point numbers
        // Gracefully handle division by zero in all builds.
        is_zero = EqualTo(b, 0)
        IfCondition is_zero ThenBlock: {
            PrintMessage("ERROR: Fixed-point divide by zero")
            ReturnValue(0) // Return 0 on error
        }

        // Scale numerator before division
        scaled_a = Multiply(a, FixedPointTrig.scale)
        ReturnValue(Divide(scaled_a, b))
    }
}

// === TRIGONOMETRIC FUNCTIONS ===

// Helper function for sin lookup - MUST BE DEFINED FIRST
Function.Trig.SinLookup {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Simple lookup for key angles (extend as needed)
        IfCondition EqualTo(degrees, 0) ThenBlock: { ReturnValue(SinTable.sin_0) }
        IfCondition EqualTo(degrees, 1) ThenBlock: { ReturnValue(SinTable.sin_1) }
        IfCondition EqualTo(degrees, 2) ThenBlock: { ReturnValue(SinTable.sin_2) }
        IfCondition EqualTo(degrees, 3) ThenBlock: { ReturnValue(SinTable.sin_3) }
        IfCondition EqualTo(degrees, 4) ThenBlock: { ReturnValue(SinTable.sin_4) }
        IfCondition EqualTo(degrees, 5) ThenBlock: { ReturnValue(SinTable.sin_5) }
        IfCondition EqualTo(degrees, 10) ThenBlock: { ReturnValue(SinTable.sin_10) }
        IfCondition EqualTo(degrees, 15) ThenBlock: { ReturnValue(SinTable.sin_15) }
        IfCondition EqualTo(degrees, 20) ThenBlock: { ReturnValue(SinTable.sin_20) }
        IfCondition EqualTo(degrees, 25) ThenBlock: { ReturnValue(SinTable.sin_25) }
        IfCondition EqualTo(degrees, 30) ThenBlock: { ReturnValue(SinTable.sin_30) }
        IfCondition EqualTo(degrees, 35) ThenBlock: { ReturnValue(SinTable.sin_35) }
        IfCondition EqualTo(degrees, 40) ThenBlock: { ReturnValue(SinTable.sin_40) }
        IfCondition EqualTo(degrees, 45) ThenBlock: { ReturnValue(SinTable.sin_45) }
        IfCondition EqualTo(degrees, 50) ThenBlock: { ReturnValue(SinTable.sin_50) }
        IfCondition EqualTo(degrees, 55) ThenBlock: { ReturnValue(SinTable.sin_55) }
        IfCondition EqualTo(degrees, 60) ThenBlock: { ReturnValue(SinTable.sin_60) }
        IfCondition EqualTo(degrees, 65) ThenBlock: { ReturnValue(SinTable.sin_65) }
        IfCondition EqualTo(degrees, 70) ThenBlock: { ReturnValue(SinTable.sin_70) }
        IfCondition EqualTo(degrees, 75) ThenBlock: { ReturnValue(SinTable.sin_75) }
        IfCondition EqualTo(degrees, 80) ThenBlock: { ReturnValue(SinTable.sin_80) }
        IfCondition EqualTo(degrees, 85) ThenBlock: { ReturnValue(SinTable.sin_85) }
        IfCondition EqualTo(degrees, 90) ThenBlock: { ReturnValue(SinTable.sin_90) }
        
        // For angles not in table, use linear interpolation
        // This is simplified - just return nearest
        IfCondition LessThan(degrees, 8) ThenBlock: {
            ReturnValue(Multiply(degrees, 175))  // Approximate
        }
        
        // Default fallback
        ReturnValue(0)
    }
}

// Main sin function - can now call SinLookup
Function.Trig.Sin {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Returns sin(degrees) in fixed-point format
        angle = Trig.NormalizeDegrees(degrees)

        Debug("Trig.Sin", level=2) {
            PrintMessage("  Input degrees: ")
            PrintNumber(degrees)
            PrintMessage("  Normalized angle: ")
            PrintNumber(angle)
        }

        // Determine quadrant and adjust
        quadrant = 1
        
        IfCondition GreaterThan(angle, 270) ThenBlock: {
            quadrant = 4
            angle = Subtract(360, angle)
            Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 4 detected") }
            // sin(360-x) = -sin(x)
        } ElseBlock: {
            IfCondition GreaterThan(angle, 180) ThenBlock: {
                quadrant = 3
                angle = Subtract(angle, 180)
                Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 3 detected") }
                // sin(180+x) = -sin(x)
            } ElseBlock: {
                IfCondition GreaterThan(angle, 90) ThenBlock: {
                    quadrant = 2
                    angle = Subtract(180, angle)
                    Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 2 detected") }
                    // sin(180-x) = sin(x)
                } ElseBlock: {
                    Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 1 detected") }
                }
            }
        }
        
        // Look up value for 0-90 range
        result = Trig.SinLookup(angle)
        
        // Apply sign based on quadrant
        IfCondition EqualTo(quadrant, 3) ThenBlock: {
            result = Subtract(0, result)
        }
        IfCondition EqualTo(quadrant, 4) ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Cos {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // cos(x) = sin(x + 90)
        shifted = Add(degrees, 90)
        ReturnValue(Trig.Sin(shifted))
    }
}

Function.Trig.Tan {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // tan(x) = sin(x) / cos(x)
        sin_val = Trig.Sin(degrees)
        cos_val = Trig.Cos(degrees)
        
        // Check for divide by zero (cos = 0 at 90, 270)
        is_zero = EqualTo(cos_val, 0)
        IfCondition is_zero ThenBlock: {
            // Return large value for "infinity"
            is_positive = GreaterThan(sin_val, 0)
            IfCondition is_positive ThenBlock: {
                ReturnValue(999999)
            }
            ReturnValue(-999999)
        }
        
        ReturnValue(FixedPoint.Divide(sin_val, cos_val))
    }
}

// === INVERSE TRIG FUNCTIONS (using approximations) ===

Function.Trig.Atan {
    Input: fixed_value: Integer
    Output: Integer
    Body: {
        // Simple atan approximation using table lookup
        // For now, just handle common angles
        
        abs_val = fixed_value
        is_negative = LessThan(fixed_value, 0)
        IfCondition is_negative ThenBlock: {
            abs_val = Subtract(0, fixed_value)
        }
        
        // Check common values (in fixed-point)
        IfCondition LessEqual(abs_val, 175) ThenBlock: {
            result = 1
        } ElseBlock: {
            IfCondition LessEqual(abs_val, 364) ThenBlock: {
                result = 2
            } ElseBlock: {
                IfCondition LessEqual(abs_val, 5773) ThenBlock: {
                    result = 30
                } ElseBlock: {
                    IfCondition LessEqual(abs_val, 10000) ThenBlock: {
                        result = 45
                    } ElseBlock: {
                        IfCondition LessEqual(abs_val, 17321) ThenBlock: {
                            result = 60
                        } ElseBlock: {
                            result = 89
                        }
                    }
                }
            }
        }
        
        IfCondition is_negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Atan2 {
    Input: (y: Integer, x: Integer)
    Output: Integer
    Body: {
        // atan2(y, x) - handles all quadrants
        
        // Handle special cases
        is_x_zero = EqualTo(x, 0)
        is_y_zero = EqualTo(y, 0)
        
        IfCondition is_x_zero ThenBlock: {
            IfCondition is_y_zero ThenBlock: {
                ReturnValue(0)
            }
            IfCondition GreaterThan(y, 0) ThenBlock: {
                ReturnValue(90)
            }
            ReturnValue(270)
        }
        
        IfCondition is_y_zero ThenBlock: {
            IfCondition GreaterThan(x, 0) ThenBlock: {
                ReturnValue(0)
            }
            ReturnValue(180)
        }
        
        // Calculate atan(y/x) and adjust for quadrant
        ratio = FixedPoint.Divide(y, x)
        angle = Trig.Atan(ratio)
        
        IfCondition LessThan(x, 0) ThenBlock: {
            IfCondition GreaterEqual(y, 0) ThenBlock: {
                angle = Add(angle, 180)
            } ElseBlock: {
                angle = Subtract(angle, 180)
            }
        }
        
        ReturnValue(Trig.NormalizeDegrees(angle))
    }
}

// === EXPONENTIAL AND LOGARITHM (using series approximations) ===

Function.Math.Exp {
    Input: x: Integer
    Output: Integer
    Body: {
        // exp(x) using Taylor series: 1 + x + x²/2! + x³/3! + ...
        // Limited to small x for accuracy
        
        // Start with 1.0 in fixed-point
        result = FixedPointTrig.scale
        term = FixedPointTrig.scale
        
        // Calculate first 8 terms
        i = 1
        WhileLoop LessEqual(i, 8) {
            term = FixedPoint.Multiply(term, x)
            term = Divide(term, i)
            result = Add(result, term)
            
            // Early exit if term becomes too small
            IfCondition LessThan(term, 10) ThenBlock: {
                BreakLoop
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

Function.Math.Log {
    Input: x: Integer
    Output: Integer
    Body: {
        // Natural log using series approximation
        // ln(x) = ln(1+y) where y = (x-1)
        // Series: y - y²/2 + y³/3 - y⁴/4 + ...
        
        DebugAssert(GreaterThan(x, 0), "Log of non-positive number")

        // For x close to 1, use series
        y = Subtract(x, FixedPointTrig.scale)
        
        // If x is far from 1, scale it first
        scale_count = 0
        temp_x = x
        WhileLoop GreaterThan(temp_x, Multiply(2, FixedPointTrig.scale)) {
            temp_x = Divide(temp_x, 2)
            scale_count = Add(scale_count, 1)
        }
        
        // Now compute log of scaled value
        y = Subtract(temp_x, FixedPointTrig.scale)
        result = 0
        term = y
        sign = 1
        
        i = 1
        WhileLoop LessEqual(i, 10) {
            divisor = Multiply(i, FixedPointTrig.scale)
            term_contribution = FixedPoint.Divide(term, divisor)
            
            IfCondition EqualTo(sign, 1) ThenBlock: {
                result = Add(result, term_contribution)
            } ElseBlock: {
                result = Subtract(result, term_contribution)
            }
            
            term = FixedPoint.Multiply(term, y)
            sign = Subtract(0, sign)
            i = Add(i, 1)
        }
        
        // Add back the scaling: log(2) = 0.693147 * scale_count
        log2 = 6931
        result = Add(result, Multiply(scale_count, log2))
        
        ReturnValue(result)
    }
}

// === HYPERBOLIC FUNCTIONS ===

Function.Trig.Sinh {
    Input: x: Integer
    Output: Integer
    Body: {
        // sinh(x) = (e^x - e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        diff = Subtract(exp_x, exp_neg_x)
        ReturnValue(Divide(diff, 2))
    }
}

Function.Trig.Cosh {
    Input: x: Integer
    Output: Integer
    Body: {
        // cosh(x) = (e^x + e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        sum = Add(exp_x, exp_neg_x)
        ReturnValue(Divide(sum, 2))
    }
}

Function.Trig.Tanh {
    Input: x: Integer
    Output: Integer
    Body: {
        // tanh(x) = sinh(x) / cosh(x)
        sinh_val = Trig.Sinh(x)
        cosh_val = Trig.Cosh(x)
        
        ReturnValue(FixedPoint.Divide(sinh_val, cosh_val))
    }
}

// === INTEGER SQUARE ROOT (for distance calculations) ===

Function.Math.ISqrt {
    Input: n: Integer
    Output: Integer
    Body: {
        // Integer square root using Newton's method
        DebugAssert(GreaterEqual(n, 0), "ISqrt of negative number")
        IfCondition EqualTo(n, 0) ThenBlock: {
            ReturnValue(0)
        }

        x = n
        y = Divide(Add(x, 1), 2)
        
        WhileLoop LessThan(y, x) {
            x = y
            y = Divide(Add(y, Divide(n, y)), 2)
        }
        
        ReturnValue(x)
    }
}

// === UTILITY FUNCTIONS ===

Function.Math.Distance2D {
    Input: (x1: Integer, y1: Integer, x2: Integer, y2: Integer)
    Output: Integer
    Body: {
        dx = Subtract(x2, x1)
        dy = Subtract(y2, y1)
        
        // Fixed-point squares
        dx_sq = FixedPoint.Multiply(dx, dx)
        dy_sq = FixedPoint.Multiply(dy, dy)
        
        sum = Add(dx_sq, dy_sq)
        
        // Convert to integer for ISqrt, then back to fixed-point
        sum_int = FixedPoint.ToInt(sum)
        sqrt_int = Math.ISqrt(sum_int)
        
        ReturnValue(FixedPoint.FromInt(sqrt_int))
    }
}

// Library loaded
PrintMessage("Library loaded successfully!")
PrintMessage("Fixed-point scale: 10000 (4 decimal places)")