// Library.Signals.ailang
// Signal handling library for AILANG
// Provides clean interface for managing Unix signals
// NOTE: Actual syscall implementation requires compiler support

// Signal number constants for Linux x86_64
FixedPool.SignalConstants {
    "SIGHUP": Initialize=1
    "SIGINT": Initialize=2
    "SIGQUIT": Initialize=3
    "SIGILL": Initialize=4
    "SIGTRAP": Initialize=5
    "SIGABRT": Initialize=6
    "SIGBUS": Initialize=7
    "SIGFPE": Initialize=8
    "SIGKILL": Initialize=9
    "SIGUSR1": Initialize=10
    "SIGSEGV": Initialize=11
    "SIGUSR2": Initialize=12
    "SIGPIPE": Initialize=13
    "SIGALRM": Initialize=14
    "SIGTERM": Initialize=15
    "SIGCHLD": Initialize=17
    "SIGCONT": Initialize=18
    "SIGSTOP": Initialize=19
    "SIGTSTP": Initialize=20
    "SIGTTIN": Initialize=21
    "SIGTTOU": Initialize=22
}

// Signal action constants
FixedPool.SignalActions {
    "SIG_DFL": Initialize=0
    "SIG_IGN": Initialize=1
}

// Storage for signal handlers
FixedPool.SignalHandlers {
    "handler_array": Initialize=0
    "initialized": Initialize=0
}

// Initialize signal handling system
Function.Signals.Init {
    Output: Integer
    Body: {
        // Check if already initialized
        IfCondition EqualTo(SignalHandlers.initialized, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Allocate array for 32 signal handlers
        handlers = ArrayCreate(32)
        SignalHandlers.handler_array = handlers
        
        // Initialize all to default
        i = 0
        WhileLoop LessThan(i, 32) {
            ArraySet(handlers, i, 0)
            i = Add(i, 1)
        }
        
        SignalHandlers.initialized = 1
        ReturnValue(1)
    }
}

// Placeholder for ignoring a signal
// Real implementation needs syscall support
Function.Signals.Ignore {
    Input: signal_num: Integer
    Output: Integer
    Body: {
        // Validate signal number
        IfCondition Or(LessThan(signal_num, 1), GreaterThan(signal_num, 31)) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Mark as ignored in our tracking array
        handlers = SignalHandlers.handler_array
        IfCondition NotEqual(handlers, 0) ThenBlock: {
            ArraySet(handlers, signal_num, SignalActions.SIG_IGN)
        }
        
        // Would need syscall here for real implementation
        // For now, just return success
        ReturnValue(0)
    }
}

// Placeholder for setting signal to default
Function.Signals.Default {
    Input: signal_num: Integer
    Output: Integer
    Body: {
        // Validate signal number
        IfCondition Or(LessThan(signal_num, 1), GreaterThan(signal_num, 31)) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Mark as default in our tracking array
        handlers = SignalHandlers.handler_array
        IfCondition NotEqual(handlers, 0) ThenBlock: {
            ArraySet(handlers, signal_num, SignalActions.SIG_DFL)
        }
        
        ReturnValue(0)
    }
}

// Common signal setup for servers
Function.Signals.ServerDefaults {
    Output: Integer
    Body: {
        // Make sure we're initialized
        Signals.Init()
        
        // Ignore SIGPIPE (broken pipe when client disconnects)
        Signals.Ignore(SignalConstants.SIGPIPE)
        
        // Ignore SIGCHLD (child process exits)
        Signals.Ignore(SignalConstants.SIGCHLD)
        
        ReturnValue(1)
    }
}

// Get signal name from number
Function.Signals.GetName {
    Input: signal_num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(signal_num, 1) ThenBlock: { ReturnValue("SIGHUP") }
        IfCondition EqualTo(signal_num, 2) ThenBlock: { ReturnValue("SIGINT") }
        IfCondition EqualTo(signal_num, 3) ThenBlock: { ReturnValue("SIGQUIT") }
        IfCondition EqualTo(signal_num, 4) ThenBlock: { ReturnValue("SIGILL") }
        IfCondition EqualTo(signal_num, 5) ThenBlock: { ReturnValue("SIGTRAP") }
        IfCondition EqualTo(signal_num, 6) ThenBlock: { ReturnValue("SIGABRT") }
        IfCondition EqualTo(signal_num, 7) ThenBlock: { ReturnValue("SIGBUS") }
        IfCondition EqualTo(signal_num, 8) ThenBlock: { ReturnValue("SIGFPE") }
        IfCondition EqualTo(signal_num, 9) ThenBlock: { ReturnValue("SIGKILL") }
        IfCondition EqualTo(signal_num, 10) ThenBlock: { ReturnValue("SIGUSR1") }
        IfCondition EqualTo(signal_num, 11) ThenBlock: { ReturnValue("SIGSEGV") }
        IfCondition EqualTo(signal_num, 12) ThenBlock: { ReturnValue("SIGUSR2") }
        IfCondition EqualTo(signal_num, 13) ThenBlock: { ReturnValue("SIGPIPE") }
        IfCondition EqualTo(signal_num, 14) ThenBlock: { ReturnValue("SIGALRM") }
        IfCondition EqualTo(signal_num, 15) ThenBlock: { ReturnValue("SIGTERM") }
        IfCondition EqualTo(signal_num, 17) ThenBlock: { ReturnValue("SIGCHLD") }
        IfCondition EqualTo(signal_num, 18) ThenBlock: { ReturnValue("SIGCONT") }
        IfCondition EqualTo(signal_num, 19) ThenBlock: { ReturnValue("SIGSTOP") }
        IfCondition EqualTo(signal_num, 20) ThenBlock: { ReturnValue("SIGTSTP") }
        ReturnValue("UNKNOWN")
    }
}

// Check if signal is currently ignored
Function.Signals.IsIgnored {
    Input: signal_num: Integer
    Output: Integer
    Body: {
        // Validate
        IfCondition Or(LessThan(signal_num, 1), GreaterThan(signal_num, 31)) ThenBlock: {
            ReturnValue(0)
        }
        
        handlers = SignalHandlers.handler_array
        IfCondition EqualTo(handlers, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        handler = ArrayGet(handlers, signal_num)
        IfCondition EqualTo(handler, SignalActions.SIG_IGN) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// Placeholder for checking termination
Function.Signals.CheckTermination {
    Output: Integer
    Body: {
        // Would need real signal handler to set a flag
        // For now, always return 0 (not terminated)
        ReturnValue(0)
    }
}