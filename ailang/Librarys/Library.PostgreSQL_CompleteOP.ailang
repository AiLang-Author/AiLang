// Library.PostgreSQL_Complete.ailang
// PRODUCTION-READY PostgreSQL Wire Protocol v3.0 Implementation
// Complete implementation with all message types, error handling, and type support

LibraryImport.Socket
LibraryImport.HashMap
LibraryImport.XArrays
LibraryImport.StringUtils

FixedPool.PG {
    "PROTOCOL_VERSION": Initialize=196608
    "MSG_AUTH": Initialize=82
    "MSG_BACKEND_KEY": Initialize=75
    "MSG_BIND_COMPLETE": Initialize=50
    "MSG_CLOSE_COMPLETE": Initialize=51
    "MSG_COMMAND_COMPLETE": Initialize=67
    "MSG_DATA_ROW": Initialize=68
    "MSG_EMPTY_QUERY": Initialize=73
    "MSG_ERROR": Initialize=69
    "MSG_NOTICE": Initialize=78
    "MSG_PARAM_STATUS": Initialize=83
    "MSG_PARSE_COMPLETE": Initialize=49
    "MSG_READY": Initialize=90
    "MSG_ROW_DESC": Initialize=84
    "AUTH_OK": Initialize=0
    "AUTH_CLEARTEXT": Initialize=3
    "AUTH_MD5": Initialize=5
    "TX_IDLE": Initialize=73
    "TX_ACTIVE": Initialize=84
    "TX_FAILED": Initialize=69
}

// ============================================================================
// BINARY UTILITIES
// ============================================================================

Function.PG_WriteInt32BE {
    Input: buf: Address
    Input: off: Integer
    Input: val: Integer
    Body: {
        StoreValue(Add(buf, off), BitwiseAnd(RightShift(val, 24), 255))
        StoreValue(Add(buf, Add(off, 1)), BitwiseAnd(RightShift(val, 16), 255))
        StoreValue(Add(buf, Add(off, 2)), BitwiseAnd(RightShift(val, 8), 255))
        StoreValue(Add(buf, Add(off, 3)), BitwiseAnd(val, 255))
    }
}

Function.PG_ReadInt32BE {
    Input: buf: Address
    Input: off: Integer
    Output: Integer
    Body: {
        // Read 4 individual bytes using GetByte
        b3 = GetByte(buf, off)           // Most significant byte
        b2 = GetByte(buf, Add(off, 1))
        b1 = GetByte(buf, Add(off, 2))
        b0 = GetByte(buf, Add(off, 3))   // Least significant byte
        
        // Combine into 32-bit value: (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
        v = LeftShift(b3, 24)
        v = BitwiseOr(v, LeftShift(b2, 16))
        v = BitwiseOr(v, LeftShift(b1, 8))
        v = BitwiseOr(v, b0)
        
        ReturnValue(v)
    }
}

Function.PG_WriteInt16BE {
    Input: buf: Address
    Input: off: Integer
    Input: val: Integer
    Body: {
        StoreValue(Add(buf, off), BitwiseAnd(RightShift(val, 8), 255))
        StoreValue(Add(buf, Add(off, 1)), BitwiseAnd(val, 255))
    }
}

Function.PG_ReadInt16BE {
    Input: buf: Address
    Input: off: Integer
    Output: Integer
    Body: {
        b1 = GetByte(buf, off)           // High byte
        b0 = GetByte(buf, Add(off, 1))   // Low byte
        v = LeftShift(b1, 8)
        v = BitwiseOr(v, b0)
        ReturnValue(v)
    }
}

Function.PG_WriteString {
    Input: buf: Address
    Input: off: Integer
    Input: str: Address
    Output: Integer
    Body: {
        len = StrLen(str)
        i = 0
        WhileLoop LessThan(i, len) {
            byte = Dereference(Add(str, i))
            StoreValue(Add(buf, Add(off, i)), byte)
            i = Add(i, 1)
        }
        StoreValue(Add(buf, Add(off, len)), 0)
        ReturnValue(Add(off, Add(len, 1)))
    }
}

Function.PG_ReadString {
    Input: buf: Address
    Input: off: Integer
    Input: max: Integer
    Output: Address
    Body: {
        // Find string length (up to null terminator or max)
        len = 0
        WhileLoop LessThan(len, max) {
            b = Dereference(Add(buf, Add(off, len)))
            IfCondition EqualTo(b, 0) ThenBlock: { BreakLoop }
            len = Add(len, 1)
        }
        
        // Allocate new string
        str = Allocate(Add(len, 1))
        
        // Copy bytes
        i = 0
        WhileLoop LessThan(i, len) {
            b = Dereference(Add(buf, Add(off, i)))
            StoreValue(Add(str, i), b)
            i = Add(i, 1)
        }
        
        // Null terminate
        StoreValue(Add(str, len), 0)
        
        ReturnValue(str)
    }
}


// ============================================================================
// RESULT CLEANUP
// ============================================================================

Function.PG_DestroyResult {
    Input: result: Address
    Body: {
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Free each HashMap row
        // Free each HashMap row AND its contained strings
        row_count = XArray.XSize(result)
        i = 0
        WhileLoop LessThan(i, row_count) {
            row = XArray.XGet(result, i)
            IfCondition NotEqual(row, 0) ThenBlock: {
                // HDestroy should free the keys and values.
                // If HSetSimple was used, it owns the value pointers.
                HashMap.HDestroy(row)
            }
            i = Add(i, 1)
        }
        
        // Then free the array itself
        XArray.XDestroy(result)
    }
}

Function.PG_DestroyFields {
    Input: fields: Address
    Body: {
        IfCondition EqualTo(fields, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        field_count = XArray.XSize(fields)
        i = 0
        WhileLoop LessThan(i, field_count) {
            // The 'fields' XArray contains strings (the field names)
            field_name = XArray.XGet(fields, i)
            IfCondition NotEqual(field_name, 0) ThenBlock: {
                // Deallocate the string for the field name
                Deallocate(field_name, 0)
            }
            i = Add(i, 1)
        }
        
        XArray.XDestroy(fields)
    }
}


Function.PG_RecvExact {
    Input: sock: Integer
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        total_received = 0
        
        WhileLoop LessThan(total_received, length) {
            remaining = Subtract(length, total_received)
            chunk = SocketRead(sock, Add(buffer, total_received), remaining)
            
            IfCondition LessEqual(chunk, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            total_received = Add(total_received, chunk)
        }
        
        ReturnValue(total_received)
    }
}

// Now replace PG_Connect with this version:

Function.PG_Connect {
    Input: host: Address
    Input: port: Integer
    Input: db: Address
    Input: user: Address
    Input: pass: Address
    Output: Address
    Body: {
        Debug("connection_start", level=1) {
            PrintMessage("PG: Connecting to ")
            PrintString(host)
            PrintMessage(":")
            PrintNumber(port)
            PrintMessage("\n")
        }
        
        sock = SocketCreate(2, 1)
        IfCondition LessThan(sock, 0) ThenBlock: {
            PrintMessage("ERROR: Socket creation failed\n")
            ReturnValue(0)
        }
        
        // Use the Socket library to create the address structure and connect
        addr = Socket.CreateAddr(host, port)
        res = Socket.Connect(sock, addr)
        Deallocate(addr, 16) // Clean up the address structure
        
        IfCondition LessThan(res, 0) ThenBlock: {
            PrintMessage("ERROR: Connection failed\n")
            SocketClose(sock)
            ReturnValue(0)
        }
        
        Debug("connection_status", level=1) {
            PrintMessage("PG: TCP connected\n")
        }
        
        startup_ok = PG_SendStartup(sock, user, db)
        IfCondition EqualTo(startup_ok, 0) ThenBlock: {
            SocketClose(sock)
            ReturnValue(0)
        }
        
        auth_ok = PG_Authenticate(sock, user, pass)
        IfCondition EqualTo(auth_ok, 0) ThenBlock: {
            SocketClose(sock)
            ReturnValue(0)
        }
        
        pid = 0
        secret = 0
        tx = 0
        
        WhileLoop EqualTo(1, 1) {
            tbuf = Allocate(1)
            br = SocketRead(sock, tbuf, 1)
            
            IfCondition LessEqual(br, 0) ThenBlock: {
                Deallocate(tbuf, 1)
                SocketClose(sock)
                ReturnValue(0)
            }
            
            mt = Dereference(tbuf)
            Deallocate(tbuf, 1)
            
            Debug("message_type", level=1) {
                PrintMessage("Message type = ")
                PrintNumber(mt)
                PrintMessage("\n")
            }
            
            lbuf = Allocate(4)
            lbytes = PG_RecvExact(sock, lbuf, 4)
            IfCondition LessEqual(lbytes, 0) ThenBlock: {
                Deallocate(lbuf, 4)
                SocketClose(sock)
                ReturnValue(0)
            }
            
            Debug("message_length_raw", level=2) {
                PrintMessage("Length bytes: [")
                PrintNumber(GetByte(lbuf, 0))
                PrintMessage(", ")
                PrintNumber(GetByte(lbuf, 1))
                PrintMessage(", ")
                PrintNumber(GetByte(lbuf, 2))
                PrintMessage(", ")
                PrintNumber(GetByte(lbuf, 3))
                PrintMessage("]\n")
            }
            
            ml = PG_ReadInt32BE(lbuf, 0)
            Deallocate(lbuf, 4)
            
            Debug("parsed_message_length", level=1) {
                PrintMessage("Parsed length = ")
                PrintNumber(ml)
                PrintMessage("\n")
            }
            
            pl = Subtract(ml, 4)
            pay = Allocate(pl)
            pbytes = PG_RecvExact(sock, pay, pl)
            IfCondition LessEqual(pbytes, 0) ThenBlock: {
                Deallocate(pay, pl)
                SocketClose(sock)
                ReturnValue(0)
            }
            
            // Backend key data (mt=75)
            IfCondition EqualTo(mt, 75) ThenBlock: {
                pid = PG_ReadInt32BE(pay, 0)
                secret = PG_ReadInt32BE(pay, 4)
                Debug("backend_info", level=1) {
                    PrintMessage("PG: Backend PID=")
                    PrintNumber(pid)
                    PrintMessage("\n")
                }
            }
            
            // Parameter status (mt=83)
            IfCondition EqualTo(mt, 83) ThenBlock: {
                // Find length of parameter name
                pn_len = 0
                WhileLoop LessThan(pn_len, pl) {
                    b = Dereference(Add(pay, pn_len))
                    IfCondition EqualTo(b, 0) ThenBlock: { BreakLoop }
                    pn_len = Add(pn_len, 1)
                }
                
                // Only proceed if we found a valid null-terminated string
                IfCondition LessThan(pn_len, pl) ThenBlock: {
                    pn = PG_ReadString(pay, 0, pl)
                    pv_offset = Add(pn_len, 1)
                    
                    // Check if there's enough space for a value string
                    IfCondition LessThan(pv_offset, pl) ThenBlock: {
                        pv = PG_ReadString(pay, pv_offset, Subtract(pl, pv_offset))
                        Debug("param_status", level=1) {
                            PrintMessage("PG: ")
                            PrintString(pn)
                            PrintMessage("=")
                            PrintString(pv)
                            PrintMessage("\n")
                        }
                        Deallocate(pv, 0)
                    }
                    
                    Deallocate(pn, 0)
                }
            }
            
            // Ready for query (mt=90)
            IfCondition EqualTo(mt, 90) ThenBlock: {
                tx = Dereference(pay)
                Deallocate(pay, pl)
                Debug("connection_status", level=1) {
                    PrintMessage("PG: Ready\n")
                }
                BreakLoop
            }
            
            // Error (mt=69)
            IfCondition EqualTo(mt, 69) ThenBlock: {
                PrintMessage("ERROR: ")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
                SocketClose(sock)
                ReturnValue(0)
            }
            
            Deallocate(pay, pl)
        }
        
        conn = Allocate(40)
        StoreValue(conn, sock)
        StoreValue(Add(conn, 8), pid)
        StoreValue(Add(conn, 16), secret)
        StoreValue(Add(conn, 24), tx)
        StoreValue(Add(conn, 32), 1)
        
        Debug("connection_status", level=1) {
            PrintMessage("PG: Connection ready\n")
        }
        ReturnValue(conn)
    }
}

Function.PG_SendStartup {
    Input: sock: Integer
    Input: user: Address
    Input: db: Address
    Output: Integer
    Body: {
        ul = StrLen(user)
        dl = StrLen(db)
        ml = Add(Add(Add(25, ul), dl), 0)
        
        msg = Allocate(ml)
        off = 0
        
        PG_WriteInt32BE(msg, off, ml)
        off = Add(off, 4)
        
        pv = PG.PROTOCOL_VERSION
        PG_WriteInt32BE(msg, off, pv)
        off = Add(off, 4)
        
        off = PG_WriteString(msg, off, "user")
        off = PG_WriteString(msg, off, user)
        off = PG_WriteString(msg, off, "database")
        off = PG_WriteString(msg, off, db)
        
        StoreValue(Add(msg, off), 0)
        
        sent = Socket.Send(sock, msg, ml)
        Deallocate(msg, ml)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Startup send failed\n")
            ReturnValue(0)
        }
        
        Debug("connection_status", level=1) {
            PrintMessage("PG: Startup sent\n")
        }
        ReturnValue(1)
    }
}

Function.PG_Authenticate {
    Input: sock: Integer
    Input: user: Address
    Input: pass: Address
    Output: Integer
    Body: {
        tbuf = Allocate(1)
        tbytes = PG_RecvExact(sock, tbuf, 1)
        IfCondition LessEqual(tbytes, 0) ThenBlock: {
            Deallocate(tbuf, 1)
            ReturnValue(0)
        }
        
        mt = Dereference(tbuf)
        Deallocate(tbuf, 1)
        
        IfCondition NotEqual(mt, 82) ThenBlock: {
            PrintMessage("ERROR: Expected auth request\n")
            ReturnValue(0)
        }
        
        lbuf = Allocate(4)
        PG_RecvExact(sock, lbuf, 4)
        Deallocate(lbuf, 4)
        
        abuf = Allocate(4)
        abytes = PG_RecvExact(sock, abuf, 4)
        IfCondition LessEqual(abytes, 0) ThenBlock: {
            Deallocate(abuf, 4)
            ReturnValue(0)
        }
        
        at = PG_ReadInt32BE(abuf, 0)
        Deallocate(abuf, 4)
        
        IfCondition EqualTo(at, 0) ThenBlock: {
            Debug("auth_status", level=1) {
                PrintMessage("PG: Auth OK (trust)\n")
            }
            ReturnValue(1)
        }
        
        IfCondition EqualTo(at, 3) ThenBlock: {
            Debug("auth_status", level=1) {
                PrintMessage("PG: Cleartext auth\n")
            }
            res = PG_SendPassword(sock, pass)
            ReturnValue(res)
        }
        
        IfCondition EqualTo(at, 5) ThenBlock: {
            saltbuf = Allocate(4)
            PG_RecvExact(sock, saltbuf, 4)
            Deallocate(saltbuf, 4)
            PrintMessage("ERROR: MD5 auth not implemented\n")
            ReturnValue(0)
        }
        
        PrintMessage("ERROR: Unsupported auth type ")
        PrintNumber(at)
        PrintMessage("\n")
        ReturnValue(0)
    }
}


Function.PG_SendPassword {
    Input: sock: Integer
    Input: pass: Address
    Output: Integer
    Body: {
        pl = StrLen(pass)
        ml = Add(Add(pl, 1), 5)
        
        msg = Allocate(ml)
        StoreValue(msg, 112)
        PG_WriteInt32BE(msg, 1, Subtract(ml, 1))
        PG_WriteString(msg, 5, pass)
        
        sent = SocketWrite(sock, msg, ml)
        Deallocate(msg, ml)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Read auth response type
        tbuf = Allocate(1)
        tbytes = SocketRead(sock, tbuf, 1)
        IfCondition LessEqual(tbytes, 0) ThenBlock: {
            Deallocate(tbuf, 1)
            ReturnValue(0)
        }
        
        mt = Dereference(tbuf)
        Deallocate(tbuf, 1)
        
        // Read length
        lbuf = Allocate(4)
        lbytes = SocketRead(sock, lbuf, 4)
        Deallocate(lbuf, 4)
        
        IfCondition EqualTo(mt, 82) ThenBlock: {
            abuf = Allocate(4)
            abytes = Socket.RecvExact(sock, abuf, 4)
            IfCondition LessEqual(abytes, 0) ThenBlock: {
                Deallocate(abuf, 4)
                ReturnValue(0)
            }
            
            at = PG_ReadInt32BE(abuf, 0)
            Deallocate(abuf, 4)
            
            IfCondition EqualTo(at, 0) ThenBlock: {
                Debug("auth_status", level=1) {
                    PrintMessage("PG: Auth successful\n")
                }
                ReturnValue(1)
            }
        }
        
        PrintMessage("ERROR: Auth failed\n")
        ReturnValue(0)
    }
}

Function.PG_Disconnect {
    Input: conn: Address
    Body: {
        IfCondition EqualTo(conn, 0) ThenBlock: { ReturnValue(0) }
        
        connected = Dereference(Add(conn, 32))
        IfCondition EqualTo(connected, 0) ThenBlock: {
            Deallocate(conn, 40)
            ReturnValue(0)
        }
        
        sock = Dereference(conn)
        
        term = Allocate(5)
        StoreValue(term, 88)  // 'X'
        PG_WriteInt32BE(term, 1, 4)
        Socket.Send(sock, term, 5)
        Deallocate(term, 5)
        
        Socket.Close(sock)
        StoreValue(Add(conn, 32), 0)
        Deallocate(conn, 40)
        
        Debug("connection_status", level=1) {
            PrintMessage("PG: Disconnected\n")
        }
    }
}

// ============================================================================
// QUERY EXECUTION
// ============================================================================

Function.PG_Query {
    Input: conn: Address
    Input: sql: Address
    Output: Address  // XArray of HashMaps (rows)
    Body: {
        sock = Dereference(conn)
        
        // Send Query message
        sql_len = StringLength(sql)
        msg_len = Add(Add(sql_len, 1), 5)
        
        msg = Allocate(msg_len)
        StoreValue(msg, 81)  // 'Q'
        PG_WriteInt32BE(msg, 1, Subtract(msg_len, 1))
        PG_WriteString(msg, 5, sql)
        
        sent = Socket.Send(sock, msg, msg_len)
        Deallocate(msg, msg_len)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Query send failed\n")
            ReturnValue(0)
        }
        
        // Read response
        result = PG_ReadQueryResponse(sock)
        ReturnValue(result)
    }
}

Function.PG_ReadQueryResponse {
    Input: sock: Integer
    Output: Address
    Body: {
        Debug("function_entry", level=1) {
            PrintMessage("PG_ReadQueryResponse starting\n")
        }
        
        rows = XArray.XCreate(16)
        fields = 0
        field_count = 0
        
        WhileLoop EqualTo(1, 1) {
            // Read message type (1 byte)
            tbuf = Allocate(1)
            br = PG_RecvExact(sock, tbuf, 1)
            
            IfCondition LessEqual(br, 0) ThenBlock: {
                Deallocate(tbuf, 1)
                BreakLoop
            }
            
            mt = Dereference(tbuf)
            Deallocate(tbuf, 1)
            
            Debug("message_type", level=1) {
                PrintMessage("Message type = ")
                PrintNumber(mt)
                PrintMessage("\n")
            }
            
            // Read message length (4 bytes)
            lbuf = Allocate(4)
            lbytes = PG_RecvExact(sock, lbuf, 4)
            
            IfCondition LessEqual(lbytes, 0) ThenBlock: {
                Deallocate(lbuf, 4)
                BreakLoop
            }
            
            ml = PG_ReadInt32BE(lbuf, 0)
            Deallocate(lbuf, 4)
            
            // Read payload
            pl = Subtract(ml, 4)
            
            // Always read payload if there is one
            pay = 0
            IfCondition GreaterThan(pl, 0) ThenBlock: {
                pay = Allocate(pl)
                pbytes = PG_RecvExact(sock, pay, pl)
                
                IfCondition LessEqual(pbytes, 0) ThenBlock: {
                    Deallocate(pay, pl)
                    BreakLoop
                }
            }
            
            // ParseComplete (1 / 49)
            IfCondition EqualTo(mt, 49) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("ParseComplete\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // BindComplete (2 / 50)
            IfCondition EqualTo(mt, 50) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("BindComplete\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // Row description (T / 84)
            IfCondition EqualTo(mt, 84) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Parsing row description\n")
                }
                fields = PG_ParseRowDesc(pay, pl)
                field_count = XArray.XSize(fields)
                Debug("row_description", level=1) {
                    PrintMessage("PG: ")
                    PrintNumber(field_count)
                    PrintMessage(" columns\n")
                }
                Deallocate(pay, pl)
            }
            
            // Data row (D / 68)
            IfCondition EqualTo(mt, 68) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Parsing data row\n")
                }
                row = PG_ParseDataRow(pay, pl, fields)
                XArray.XPush(rows, row)
                Debug("data_row", level=1) {
                    PrintMessage("Pushed row\n")
                }
                Deallocate(pay, pl)
            }
            
            // Command complete (C / 67)
            IfCondition EqualTo(mt, 67) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Parsing command complete\n")
                }
                tag = PG_ReadString(pay, 0, pl)
                Debug("command_complete_tag", level=1) {
                    PrintMessage("PG: ")
                    PrintString(tag)
                    PrintMessage("\n")
                }
                Deallocate(tag, 0)
                Deallocate(pay, pl)
            }
            
            // Ready for query (Z / 90)
            IfCondition EqualTo(mt, 90) ThenBlock: {
                Debug("ready_for_query", level=1) {
                    PrintMessage("Ready for query - BREAKING\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
                BreakLoop
            }
            
            // Error (E / 69)
            IfCondition EqualTo(mt, 69) ThenBlock: {
                PrintMessage("ERROR:\n")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
                XArray.XDestroy(rows)
                ReturnValue(0)
            }
            
            // Notice (N / 78)
            IfCondition EqualTo(mt, 78) ThenBlock: {
                PrintMessage("NOTICE:\n")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
            }
        }
        
        Debug("function_exit", level=1) {
            PrintMessage("Loop finished\n")
        }
        Debug("result_summary", level=1) {
            PrintMessage("PG: ")
            PrintNumber(XArray.XSize(rows))
            PrintMessage(" rows\n")
        }
        
        ReturnValue(rows)
    }
}


Function.PG_ReadQueryResponseWithFields {
    Input: sock: Integer
    Input: stored_fields: Address
    Output: Address
    Body: {
        Debug("function_entry", level=2) {
            PrintMessage("PG_ReadQueryResponseWithFields starting, fields=")
            PrintNumber(stored_fields)
            PrintMessage("\n")
        }
        
        rows = XArray.XCreate(16)
        fields = stored_fields
        
        WhileLoop EqualTo(1, 1) {
            Debug("loop_iteration", level=2) {
                PrintMessage("Loop iteration - reading message type\n")
            }
            
            // Read message type (1 byte)
            tbuf = Allocate(1)
            br = PG_RecvExact(sock, tbuf, 1)
            
            Debug("socket_read", level=2) {
                PrintMessage("Read message type, bytes=")
                PrintNumber(br)
                PrintMessage("\n")
            }
            
            IfCondition LessEqual(br, 0) ThenBlock: {
                Debug("socket_read", level=1) {
                    PrintMessage("No bytes read, breaking\n")
                }
                Deallocate(tbuf, 1)
                BreakLoop
            }
            
            mt = Dereference(tbuf)
            Deallocate(tbuf, 1)
            
            Debug("message_type", level=1) {
                PrintMessage("Message type = ")
                PrintNumber(mt)
                PrintMessage("\n")
            }
            
            // Read message length (4 bytes)
            lbuf = Allocate(4)
            lbytes = PG_RecvExact(sock, lbuf, 4)
            
            Debug("socket_read", level=2) {
                PrintMessage("Read length, bytes=")
                PrintNumber(lbytes)
                PrintMessage("\n")
            }
            
            IfCondition LessEqual(lbytes, 0) ThenBlock: {
                Debug("socket_read", level=1) {
                    PrintMessage("Length read failed, breaking\n")
                }
                Deallocate(lbuf, 4)
                BreakLoop
            }
            
            ml = PG_ReadInt32BE(lbuf, 0)
            Deallocate(lbuf, 4)
            Debug("message_length", level=2) {
                PrintMessage("Message length = ")
                PrintNumber(ml)
                PrintMessage("\n")
            }
            
            // Read payload
            pl = Subtract(ml, 4)
            Debug("payload_length", level=2) {
                PrintMessage("Payload length = ")
                PrintNumber(pl)
                PrintMessage("\n")
            }
            
            // Always read payload if there is one
            pay = 0
            IfCondition GreaterThan(pl, 0) ThenBlock: {
                Debug("payload_read", level=2) {
                    PrintMessage("Allocating and reading payload\n")
                }
                pay = Allocate(pl)
                pbytes = PG_RecvExact(sock, pay, pl)
                Debug("payload_read", level=2) {
                    PrintMessage("Payload bytes read = ")
                    PrintNumber(pbytes)
                    PrintMessage("\n")
                }
                
                IfCondition LessEqual(pbytes, 0) ThenBlock: {
                    Debug("payload_read", level=1) {
                        PrintMessage("Payload read failed, breaking\n")
                    }
                    Deallocate(pay, pl)
                    BreakLoop
                }
            }
            
            // ParseComplete (1 / 49)
            IfCondition EqualTo(mt, 49) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("ParseComplete\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // BindComplete (2 / 50)
            IfCondition EqualTo(mt, 50) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("BindComplete\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // Row description (T / 84)
            IfCondition EqualTo(mt, 84) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Skipping RowDescription (using cached fields)\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // Data row (D / 68)
            IfCondition EqualTo(mt, 68) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Parsing data row\n")
                }
                row = PG_ParseDataRow(pay, pl, fields)
                XArray.XPush(rows, row)
                Debug("data_row", level=1) {
                    PrintMessage("Pushed row\n")
                }
                Deallocate(pay, pl)
            }
            
            // Command complete (C / 67)
            IfCondition EqualTo(mt, 67) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Parsing command complete\n")
                }
                tag = PG_ReadString(pay, 0, pl)
                Debug("command_complete_tag", level=1) {
                    PrintMessage("PG: ")
                    PrintString(tag)
                    PrintMessage("\n")
                }
                Deallocate(tag, 0)
                Deallocate(pay, pl)
            }
            
            // Ready for query (Z / 90)
            IfCondition EqualTo(mt, 90) ThenBlock: {
                Debug("ready_for_query", level=1) {
                    PrintMessage("Ready for query - BREAKING\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
                BreakLoop
            }
            
            // Error (E / 69)
            IfCondition EqualTo(mt, 69) ThenBlock: {
                PrintMessage("ERROR:\n")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
                XArray.XDestroy(rows)
                ReturnValue(0)
            }
            
            // Notice (N / 78)
            IfCondition EqualTo(mt, 78) ThenBlock: {
                PrintMessage("NOTICE:\n")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
            }
            
            Debug("loop_iteration", level=2) {
                PrintMessage("End of loop iteration\n")
            }
        }
        
        Debug("function_exit", level=1) {
            PrintMessage("Loop finished\n")
        }
        Debug("result_summary", level=1) {
            PrintMessage("PG: ")
            PrintNumber(XArray.XSize(rows))
            PrintMessage(" rows\n")
        }
        
        ReturnValue(rows)
    }
}


Function.PG_ParseRowDesc {
    Input: buf: Address
    Input: len: Integer
    Output: Address
    Body: {
        Debug("function_entry", level=1) {
            PrintMessage("PG_ParseRowDesc: buf=")
            PrintNumber(buf)
            PrintMessage(", len=")
            PrintNumber(len)
            PrintMessage("\n")
        }
        
        // Read field count (first 2 bytes, big-endian)
        fc = PG_ReadInt16BE(buf, 0)
        Debug("field_count", level=1) {
            PrintMessage("Field count = ")
            PrintNumber(fc)
            PrintMessage("\n")
        }
        
        off = 2
        
        // Create XArray with proper capacity
        fields = XArray.XCreate(fc)
        Debug("memory_allocation", level=2) {
            PrintMessage("Created fields XArray with capacity ")
            PrintNumber(fc)
            PrintMessage("\n")
        }
        
        i = 0
        WhileLoop LessThan(i, fc) {
            Debug("field_parsing_detail", level=2) {
                PrintMessage("Processing field ")
                PrintNumber(i)
                PrintMessage(", offset=")
                PrintNumber(off)
                PrintMessage("\n")
            }
            
            // Check bounds before reading string
            IfCondition GreaterEqual(off, len) ThenBlock: {
                PrintMessage("ERROR: Offset exceeds buffer length\n")
                BreakLoop
            }
            
            // Read field name (null-terminated string)
            fname = PG_ReadString(buf, off, Subtract(len, off))
            Debug("field_parsing_detail", level=2) {
                PrintMessage("Field name = ")
                PrintMessage("Field name (leaks here if not freed!) = ")
                PrintString(fname)
                PrintMessage("\n")
            }
            
            fnl = StringLength(fname)
            off = Add(off, Add(fnl, 1))  // +1 for null terminator
            
            Debug("field_parsing_detail", level=2) {
                PrintMessage("Field name length = ")
                PrintNumber(fnl)
                PrintMessage(", new offset = ")
                PrintNumber(off)
                PrintMessage("\n")
            }
            
            // Skip field metadata: table_oid(4) + attr_num(2) + type_oid(4) + type_size(2) + type_mod(4) + format(2) = 18 bytes
            off = Add(off, 18)
            
            Debug("field_parsing_detail", level=2) {
                PrintMessage("After skipping metadata, offset = ")
                PrintNumber(off)
                PrintMessage("\n")
            }
            
            // Push field name to array
            XArray.XPush(fields, fname)
            // DO NOT DEALLOCATE fname, XArray now owns it.
            Debug("field_parsing_detail", level=2) {
                PrintMessage("Pushed field to array\n")
            }
            
            i = Add(i, 1)
        }
        Debug("function_exit", level=1) {
            PrintMessage("PG_ParseRowDesc complete, returning fields\n")
        }
        ReturnValue(fields)
    }
}


Function.PG_ParseDataRow {
    Input: buf: Address
    Input: len: Integer
    Input: fields: Address
    Output: Address
    Body: {
        Debug("function_entry", level=1) {
            PrintMessage("PG_ParseDataRow: buf=")
            PrintNumber(buf)
            PrintMessage(", len=")
            PrintNumber(len)
            PrintMessage(", fields=")
            PrintNumber(fields)
            PrintMessage("\n")
        }
        
        cc = PG_ReadInt16BE(buf, 0)
        Debug("column_count", level=1) {
            PrintMessage("Column count = ")
            PrintNumber(cc)
            PrintMessage("\n")
        }
        
        off = 2
        
        row = HashMap.CreateSimple()
        Debug("memory_allocation", level=2) {
            PrintMessage("Created HashMap\n")
        }
        
        // If we don't have field names, create generic ones
        IfCondition EqualTo(fields, 0) ThenBlock: {
            PrintMessage("WARNING: No field names available, using col0, col1, etc.\n")
        }
        
        i = 0
        WhileLoop LessThan(i, cc) {
            Debug("column_parsing_detail", level=2) {
                PrintMessage("Processing column ")
                PrintNumber(i)
                PrintMessage(", offset=")
                PrintNumber(off)
                PrintMessage("\n")
            }
            
            vl = PG_ReadInt32BE(buf, off)
            Debug("column_parsing_detail", level=2) {
                PrintMessage("Value length = ")
                PrintNumber(vl)
                PrintMessage("\n")
            }
            
            off = Add(off, 4)
            
            // Get field name (or create generic one if fields is null)
            fname = 0
            IfCondition NotEqual(fields, 0) ThenBlock: {
                fname = XArray.XGet(fields, i)
                Debug("column_parsing_detail", level=2) {
                    PrintMessage("Field name = ")
                    PrintString(fname)
                    PrintMessage("\n")
                }
            } ElseBlock: {
                // Create generic field name: "col0", "col1", etc.
                // For now, just skip storing it
                Debug("column_parsing_detail", level=2) {
                    PrintMessage("No field name available\n")
                }
            }
            
            // NULL value (length = -1 = 4294967295 unsigned)
            is_null = EqualTo(vl, 4294967295)
            
            IfCondition is_null ThenBlock: {
                Debug("column_parsing_detail", level=2) {
                    PrintMessage("NULL value\n")
                }
                IfCondition NotEqual(fname, 0) ThenBlock: {
                    HashMap.HSetSimple(row, fname, 0)
                }
            } ElseBlock: {
                Debug("column_parsing_detail", level=2) {
                    PrintMessage("Non-NULL value, length = ")
                    PrintNumber(vl)
                    PrintMessage("\n")
                }
                
                // Check bounds
                IfCondition GreaterThan(Add(off, vl), len) ThenBlock: {
                    PrintMessage("ERROR: Value would exceed buffer bounds\n")
                    IfCondition NotEqual(fname, 0) ThenBlock: {
                        HashMap.HSetSimple(row, fname, 0)
                    }
                } ElseBlock: {
                    // Read value
                    val = PG_ReadString(buf, off, vl)
                    Debug("column_parsing_detail", level=2) {
                        PrintMessage("Read value = ")
                        PrintString(val)
                        PrintMessage("\n")
                    }
                    
                    off = Add(off, vl)
                    
                    IfCondition NotEqual(fname, 0) ThenBlock: {
                        HashMap.HSetSimple(row, fname, val)
                        Debug("column_parsing_detail", level=2) {
                            PrintMessage("Stored in HashMap\n")
                        }
                    } ElseBlock: {
                        // No field name, can't store
                        Deallocate(val, 0)
                    }
                }
            }
            
            i = Add(i, 1)
        }
        
        Debug("function_exit", level=1) {
            PrintMessage("PG_ParseDataRow complete\n")
        }
        ReturnValue(row)
    }
}


Function.PG_ParseError {
    Input: buf: Address
    Input: len: Integer
    Body: {
        Debug("function_entry", level=2) {
            PrintMessage("PG_ParseError called with len=")
            PrintNumber(len)
            PrintMessage("\n")
        }
        
        off = 0
        
        WhileLoop LessThan(off, len) {
            ft = GetByte(buf, off)
            
            Debug("error_parsing_detail", level=2) {
                PrintMessage("Field type=")
                PrintNumber(ft)
                PrintMessage(" at offset=")
                PrintNumber(off)
                PrintMessage("\n")
            }
            
            IfCondition EqualTo(ft, 0) ThenBlock: { 
                Debug("error_parsing_detail", level=2) {
                    PrintMessage("Hit null terminator\n")
                }
                BreakLoop 
            }
            
            off = Add(off, 1)
            
            // Check bounds
            IfCondition GreaterEqual(off, len) ThenBlock: { 
                Debug("error_parsing_detail", level=2) {
                    PrintMessage("Reached end of buffer\n")
                }
                BreakLoop 
            }
            
            fv = PG_ReadString(buf, off, Subtract(len, off))
            Debug("error_parsing_detail", level=2) {
                PrintMessage("Field value=")
                PrintString(fv)
                PrintMessage("\n")
            }
            
            fl = StringLength(fv)
            off = Add(off, Add(fl, 1))
            
            // Severity (S = 83)
            IfCondition EqualTo(ft, 83) ThenBlock: {
                PrintString(fv)
                PrintMessage(": ")
            }
            
            // Message (M = 77)
            IfCondition EqualTo(ft, 77) ThenBlock: {
                PrintString(fv)
            }
            
            // Detail (D = 68)
            IfCondition EqualTo(ft, 68) ThenBlock: {
                PrintMessage(" (Detail: ")
                PrintString(fv)
                PrintMessage(")")
            }
            
            // Hint (H = 72)
            IfCondition EqualTo(ft, 72) ThenBlock: {
                PrintMessage(" [Hint: ")
                PrintString(fv)
                PrintMessage("]")
            }
            
            Deallocate(fv, 0)
        }
        
        PrintMessage("\n")
    }
}



// ============================================================================
// DESCRIBE MESSAGE - Get row description for prepared statements
// ============================================================================

Function.PG_Describe {
    Input: sock: Integer
    Input: stmt_name: Address
    Input: describe_type: Integer  // 'S' for statement, 'P' for portal
    Output: Address
    Body: {
        Debug("function_entry", level=1) {
            PrintMessage("Describing statement '")
            PrintString(stmt_name)
            PrintMessage("'\n")
        }
        
        nl = StringLength(stmt_name)
        
        // Describe message format:
        // 'D' (1 byte - NOT in length field)
        // int32 length (4 bytes - includes itself)
        // type byte ('S' or 'P') (1 byte)
        // name + null (nl + 1)
        // Total in length field: 4 + 1 + (nl + 1) = nl + 6
        
        length_field = Add(nl, 6)
        total_size = Add(length_field, 1)  // +1 for 'D' type byte
        
        Debug("message_construction", level=1) {
            PrintMessage("Describe - nl=")
            PrintNumber(nl)
            PrintMessage(", length_field=")
            PrintNumber(length_field)
            PrintMessage(", total_size=")
            PrintNumber(total_size)
            PrintMessage("\n")
        }
        
        msg = Allocate(total_size)
        off = 0
        
        // Type byte 'D' (68)
        SetByte(msg, off, 68)
        off = Add(off, 1)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Set 'D' at offset 0\n")
        }
        
        // Length (includes itself, type byte, name, null - NOT the 'D')
        PG_WriteInt32BE(msg, off, length_field)
        off = Add(off, 4)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote length=")
            PrintNumber(length_field)
            PrintMessage(" at offset 1-4\n")
        }
        
        // Describe type ('S'=83 for statement, 'P'=80 for portal)
        SetByte(msg, off, describe_type)
        off = Add(off, 1)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote describe_type=")
            PrintNumber(describe_type)
            PrintMessage(" at offset 5\n")
        }
        
        // Statement name (null-terminated)
        i = 0
        WhileLoop LessThan(i, nl) {
            b = GetByte(stmt_name, i)
            SetByte(msg, Add(off, i), b)
            i = Add(i, 1)
        }
        off = Add(off, nl)
        SetByte(msg, off, 0)  // Null terminator
        off = Add(off, 1)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote name '")
            PrintString(stmt_name)
            PrintMessage("' at offset 6-")
            PrintNumber(off)
            PrintMessage("\n")
            PrintMessage("Final offset=")
            PrintNumber(off)
            PrintMessage(", expected=")
            PrintNumber(total_size)
            PrintMessage("\n")
        }
        
        // Send Describe message
        sent = SocketWrite(sock, msg, total_size)
        Deallocate(msg, total_size)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Describe send failed\n")
            ReturnValue(0)
        }
        
        Debug("socket_write", level=1) {
            PrintMessage("Describe message sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Send Sync to get response
        sync = Allocate(5)
        SetByte(sync, 0, 83)  // 'S'
        PG_WriteInt32BE(sync, 1, 4)
        sent = SocketWrite(sock, sync, 5)
        Deallocate(sync, 5)
        Debug("socket_write", level=1) {
            PrintMessage("Sync sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Read response
        fields = PG_ReadDescribeResponse(sock)
        
        ReturnValue(fields)
    }
}

Function.PG_ReadDescribeResponse {
    Input: sock: Integer
    Output: Address
    Body: {
        Debug("function_entry", level=1) {
            PrintMessage("Reading Describe response\n")
        }
        
        fields = 0
        
        WhileLoop EqualTo(1, 1) {
            // Read message type
            tbuf = Allocate(1)
            br = PG_RecvExact(sock, tbuf, 1)
            
            IfCondition LessEqual(br, 0) ThenBlock: {
                Deallocate(tbuf, 1)
                BreakLoop
            }
            
            mt = Dereference(tbuf)
            Deallocate(tbuf, 1)
            
            Debug("message_type", level=1) {
                PrintMessage("Describe response message type = ")
                PrintNumber(mt)
                PrintMessage("\n")
            }
            
            // Read length
            lbuf = Allocate(4)
            PG_RecvExact(sock, lbuf, 4)
            ml = PG_ReadInt32BE(lbuf, 0)
            Deallocate(lbuf, 4)
            
            pl = Subtract(ml, 4)
            
            // Read payload if present
            pay = 0
            IfCondition GreaterThan(pl, 0) ThenBlock: {
                pay = Allocate(pl)
                PG_RecvExact(sock, pay, pl)
            }
            
            // RowDescription (T / 84)
            IfCondition EqualTo(mt, 84) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Got RowDescription\n")
                }
                fields = PG_ParseRowDesc(pay, pl)
                Deallocate(pay, pl)
            }
            
            // NoData (n / 110)
            IfCondition EqualTo(mt, 110) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Got NoData (statement returns no rows)\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // ParameterDescription (t / 116)
            IfCondition EqualTo(mt, 116) ThenBlock: {
                Debug("message_parse", level=1) {
                    PrintMessage("Got ParameterDescription\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
            }
            
            // ReadyForQuery (Z / 90)
            IfCondition EqualTo(mt, 90) ThenBlock: {
                Debug("ready_for_query", level=1) {
                    PrintMessage("Ready after Describe\n")
                }
                IfCondition NotEqual(pay, 0) ThenBlock: {
                    Deallocate(pay, pl)
                }
                BreakLoop
            }
            
            // Error (E / 69)
            IfCondition EqualTo(mt, 69) ThenBlock: {
                PrintMessage("ERROR in Describe:\n")
                PG_ParseError(pay, pl)
                Deallocate(pay, pl)
                ReturnValue(0)
            }
            
            // Cleanup any other messages
            IfCondition NotEqual(pay, 0) ThenBlock: {
                Deallocate(pay, pl)
            }
        }
        
        ReturnValue(fields)
    }
}


// ============================================================================
// TRANSACTIONS
// ============================================================================

Function.PG_Begin {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Query(conn, "BEGIN")
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.PG_Commit {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Query(conn, "COMMIT")
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.PG_Rollback {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Query(conn, "ROLLBACK")
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// ============================================================================
// PREPARED STATEMENTS
// ============================================================================

// Prepared statement: [name, param_count, conn]
Function.PG_Prepare {
    Input: conn: Address
    Input: name: Address
    Input: sql: Address
    Output: Address
    Body: {
        sock = Dereference(conn)
        Debug("prepare_statement", level=1) {
            PrintMessage("PG: Preparing statement '")
            PrintString(name)
            PrintMessage("'\n")
        }
        
        // Calculate lengths
        nl = StringLength(name)
        sl = StringLength(sql)
        
        // Message format:
        // 'P' (1 byte - not in length)
        // int32 length (4 bytes - includes itself)
        // name + null (nl + 1)
        // sql + null (sl + 1)
        // int16 param_count (2 bytes)
        // Total in length field: 4 + (nl+1) + (sl+1) + 2 = nl + sl + 8
        
        msg_length_field = Add(Add(nl, sl), 8)
        total_msg_size = Add(msg_length_field, 1)  // +1 for 'P' type byte
        
        Debug("message_construction", level=1) {
            PrintMessage("Prepare message - nl=")
            PrintNumber(nl)
            PrintMessage(", sl=")
            PrintNumber(sl)
            PrintMessage(", length_field=")
            PrintNumber(msg_length_field)
            PrintMessage(", total=")
            PrintNumber(total_msg_size)
            PrintMessage("\n")
        }
        
        // Allocate message buffer
        msg = Allocate(total_msg_size)
        off = 0
        
        // Type byte 'P' (80)
        SetByte(msg, off, 80)
        off = Add(off, 1)
        
        // Length (int32, big-endian)
        PG_WriteInt32BE(msg, off, msg_length_field)
        off = Add(off, 4)
        
        // Statement name (null-terminated)
        i = 0
        WhileLoop LessThan(i, nl) {
            b = GetByte(name, i)
            SetByte(msg, Add(off, i), b)
            i = Add(i, 1)
        }
        off = Add(off, nl)
        SetByte(msg, off, 0)  // Null terminator
        off = Add(off, 1)
        
        // Query string (null-terminated)
        i = 0
        WhileLoop LessThan(i, sl) {
            b = GetByte(sql, i)
            SetByte(msg, Add(off, i), b)
            i = Add(i, 1)
        }
        off = Add(off, sl)
        SetByte(msg, off, 0)  // Null terminator
        off = Add(off, 1)
        
        // Number of parameter types (int16, big-endian) - 0 means infer all
        PG_WriteInt16BE(msg, off, 0)
        off = Add(off, 2)
        
        Debug("message_construction", level=1) {
            PrintMessage("Built Parse message, offset=")
            PrintNumber(off)
            PrintMessage(", expected=")
            PrintNumber(total_msg_size)
            PrintMessage("\n")
        }
        
        // Send Parse message
        sent = SocketWrite(sock, msg, total_msg_size)
        Deallocate(msg, total_msg_size)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Parse message send failed\n")
            ReturnValue(0)
        }
        
        Debug("socket_write", level=1) {
            PrintMessage("Parse message sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Send Sync to complete Parse phase
        sync = Allocate(5)
        SetByte(sync, 0, 83)  // 'S'
        PG_WriteInt32BE(sync, 1, 4)
        sent = SocketWrite(sock, sync, 5)
        Deallocate(sync, 5)
        Debug("socket_write", level=1) {
            PrintMessage("Sync message sent after Parse, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Wait for ParseComplete + ReadyForQuery
        parse_ok = PG_WaitReady(sock)
        
        IfCondition EqualTo(parse_ok, 0) ThenBlock: {
            PrintMessage("ERROR: Parse failed\n")
            ReturnValue(0)
        }
        
        Debug("protocol_flow", level=1) {
            PrintMessage("Parse complete, now describing\n")
        }
        
        // Now send Describe to get field information
        // 'S' = 83 for Statement (vs 'P' = 80 for Portal)
        fields = PG_Describe(sock, name, 83)
        
        Debug("protocol_flow", level=1) {
            PrintMessage("Describe complete, fields=")
            PrintNumber(fields)
            PrintMessage("\n")
        }
        
        // Create statement handle: [name, param_count, conn, fields]
        stmt = Allocate(32)
        
        // Store a COPY of the name (not the original pointer)
        name_copy = Allocate(Add(nl, 1))
        i = 0
        WhileLoop LessThan(i, nl) {
            b = GetByte(name, i)
            SetByte(name_copy, i, b)
            i = Add(i, 1)
        }
        SetByte(name_copy, nl, 0)
        
        StoreValue(stmt, name_copy)
        StoreValue(Add(stmt, 8), 0)       // param count (TODO: could parse from ParameterDescription)
        StoreValue(Add(stmt, 16), conn)   // connection reference
        StoreValue(Add(stmt, 24), fields) // field descriptions (0 for INSERT/UPDATE/DELETE)
        
        Debug("prepare_statement", level=1) {
            PrintMessage("PG: Prepared statement '")
            PrintString(name)
            PrintMessage("'\n")
        }
        
        ReturnValue(stmt)
    }
}

Function.PG_DestroyStatement {
    Input: stmt: Address
    Body: {
        IfCondition EqualTo(stmt, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the fields array
        fields = Dereference(Add(stmt, 24))
        
        // Destroy fields if they exist
        IfCondition NotEqual(fields, 0) ThenBlock: {
            // This is tricky. PG_DestroyFields assumes it's an array of strings.
            // Let's make sure PG_ParseRowDesc returns an XArray of strings.
            // It does, so we need a function to free an XArray of strings.
            PG_DestroyFields(fields)
        }
        
        // Free statement name string if it exists
        name = Dereference(stmt)
        IfCondition NotEqual(name, 0) ThenBlock: {
            Deallocate(name, 0)
        }
        
        // Free the statement structure itself
        Deallocate(stmt, 32)
    }
}

Function.PG_Execute {
    Input: stmt: Address
    Input: params: Address
    Output: Address
    Body: {
        // Extract statement info
        name = Dereference(stmt)
        conn = Dereference(Add(stmt, 16))
        sock = Dereference(conn)
        stored_fields = Dereference(Add(stmt, 24))  // Get stored field info
        
        Debug("function_entry", level=1) {
            PrintMessage("Execute - stmt=")
            PrintNumber(stmt)
            PrintMessage(", name addr=")
            PrintNumber(name)
            PrintMessage(", fields addr=")
            PrintNumber(stored_fields)
            PrintMessage("\n")
        }
        
        pc = XArray.XSize(params)
        Debug("param_info", level=1) {
            PrintMessage("Executing with ")
            PrintNumber(pc)
            PrintMessage(" params\n")
        }
        
        // Calculate lengths
        nl = StringLength(name)
        Debug("param_info", level=2) {
            PrintMessage("Name length = ")
            PrintNumber(nl)
            PrintMessage("\n")
        }
        
        // Calculate parameter data size
        param_data_size = 0
        i = 0
        WhileLoop LessThan(i, pc) {
            p = XArray.XGet(params, i)
            IfCondition NotEqual(p, 0) ThenBlock: {
                pl = StringLength(p)
                param_data_size = Add(param_data_size, Add(4, pl))  // 4 bytes length + data
            } ElseBlock: {
                param_data_size = Add(param_data_size, 4)  // 4 bytes for -1 (NULL)
            }
            i = Add(i, 1)
        }
        
        Debug("param_info", level=2) {
            PrintMessage("Parameter data size = ")
            PrintNumber(param_data_size)
            PrintMessage("\n")
        }
        
        // Total in length field: 4 + portal(1) + name(nl+1) + fmtcodes(2) + paramcount(2) + paramdata + resultfmt(2)
        // = 4 + 1 + nl + 1 + 2 + 2 + param_data_size + 2
        // = nl + param_data_size + 12
        
        length_field = Add(Add(nl, param_data_size), 12)
        total_size = Add(length_field, 1)  // +1 for 'B' type byte
        
        Debug("message_construction", level=1) {
            PrintMessage("Bind message - length_field=")
            PrintNumber(length_field)
            PrintMessage(", total_size=")
            PrintNumber(total_size)
            PrintMessage("\n")
        }
        
        // Allocate message
        msg = Allocate(total_size)
        off = 0
        
        // Type byte 'B' (66)
        SetByte(msg, off, 66)
        off = Add(off, 1)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Set type byte at offset 0\n")
        }
        
        // Length field
        PG_WriteInt32BE(msg, off, length_field)
        off = Add(off, 4)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote length field at offset 1-4\n")
        }
        
        // Portal name (empty = just null byte)
        SetByte(msg, off, 0)
        off = Add(off, 1)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote empty portal at offset 5\n")
        }
        
        // Statement name (null-terminated)
        i = 0
        WhileLoop LessThan(i, nl) {
            b = GetByte(name, i)
            SetByte(msg, Add(off, i), b)
            i = Add(i, 1)
        }
        off = Add(off, nl)
        SetByte(msg, off, 0)  // Null terminator
        off = Add(off, 1)
        
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote statement name '")
            PrintString(name)
            PrintMessage("' at offset 6-")
            PrintNumber(off)
            PrintMessage("\n")
        }
        
        // Format codes for parameters (0 = all text format)
        PG_WriteInt16BE(msg, off, 0)
        off = Add(off, 2)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote format codes\n")
        }
        
        // Parameter count
        PG_WriteInt16BE(msg, off, pc)
        off = Add(off, 2)
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote param count = ")
            PrintNumber(pc)
            PrintMessage("\n")
        }
        
        // Write each parameter
        i = 0
        WhileLoop LessThan(i, pc) {
            p = XArray.XGet(params, i)
            
            Debug("param_write", level=2) {
                PrintMessage("Param ")
                PrintNumber(i)
                PrintMessage(": ")
            }
            
            IfCondition EqualTo(p, 0) ThenBlock: {
                // NULL parameter (length = -1 = 0xFFFFFFFF)
                PG_WriteInt32BE(msg, off, 4294967295)
                off = Add(off, 4)
                Debug("param_write", level=2) { PrintMessage("NULL\n") }
            } ElseBlock: {
                // Non-NULL parameter
                pl = StringLength(p)
                Debug("param_write", level=2) {
                    PrintMessage("'")
                    PrintString(p)
                    PrintMessage("' (length=")
                    PrintNumber(pl)
                    PrintMessage(")\n")
                }
                
                PG_WriteInt32BE(msg, off, pl)
                off = Add(off, 4)
                
                // Copy parameter bytes
                j = 0
                WhileLoop LessThan(j, pl) {
                    b = GetByte(p, j)
                    SetByte(msg, Add(off, j), b)
                    j = Add(j, 1)
                }
                off = Add(off, pl)
            }
            
            i = Add(i, 1)
        }
        
        Debug("message_construction_detail", level=2) {
            PrintMessage("Wrote all params, offset=")
            PrintNumber(off)
            PrintMessage("\n")
        }
        
        // Result format codes (0 = all text format)
        PG_WriteInt16BE(msg, off, 0)
        off = Add(off, 2)
        
        Debug("message_construction", level=1) {
            PrintMessage("Final offset=")
            PrintNumber(off)
            PrintMessage(", expected=")
            PrintNumber(total_size)
            PrintMessage("\n")
        }
        
        // Send Bind message
        sent = SocketWrite(sock, msg, total_size)
        Deallocate(msg, total_size)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Bind send failed\n")
            ReturnValue(0)
        }
        
        Debug("socket_write", level=1) {
            PrintMessage("Bind sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Build Execute message
        // Format: 'E' + length(4) + portal_name(1) + max_rows(4)
        exec = Allocate(10)
        SetByte(exec, 0, 69)  // 'E'
        PG_WriteInt32BE(exec, 1, 9)  // Length = 9
        SetByte(exec, 5, 0)  // Portal name (empty)
        PG_WriteInt32BE(exec, 6, 0)  // Max rows (0 = unlimited)
        
        sent = SocketWrite(sock, exec, 10)
        Deallocate(exec, 10)
        
        Debug("socket_write", level=1) {
            PrintMessage("Execute sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        // Send Sync
        sync = Allocate(5)
        SetByte(sync, 0, 83)  // 'S'
        PG_WriteInt32BE(sync, 1, 4)
        sent = SocketWrite(sock, sync, 5)
        Deallocate(sync, 5)
        Debug("socket_write", level=1) {
            PrintMessage("Sync sent, bytes=")
            PrintNumber(sent)
            PrintMessage("\n")
        }
        
        Debug("read_response", level=1) {
            PrintMessage("About to read response with fields=")
            PrintNumber(stored_fields)
            PrintMessage("\n")
        }
        
        // Read response - use stored fields
        result = PG_ReadQueryResponseWithFields(sock, stored_fields)
        // CRITICAL: Don't destroy fields here - they belong to stmt
        // Only destroy the result when user calls PG_DestroyResult
        
        ReturnValue(result)
    }
}

Function.PG_WaitReady {
    Input: sock: Integer
    Output: Integer
    Body: {
        WhileLoop EqualTo(1, 1) {
            // Allocate buffer FIRST
            tbuf = Allocate(1)
            bytes_read = PG_RecvExact(sock, tbuf, 1)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                Deallocate(tbuf, 1)
                ReturnValue(0)
            }
            
            mt = Dereference(tbuf)
            Deallocate(tbuf, 1)
            
            // Allocate buffer for length
            lbuf = Allocate(4)
            bytes_read = PG_RecvExact(sock, lbuf, 4)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                Deallocate(lbuf, 4)
                ReturnValue(0)
            }
            
            ml = PG_ReadInt32BE(lbuf, 0)
            Deallocate(lbuf, 4)
            
            pl = Subtract(ml, 4)
            
            IfCondition GreaterThan(pl, 0) ThenBlock: {
                pay = Allocate(pl)
                bytes_read = PG_RecvExact(sock, pay, pl)
                
                IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                    Deallocate(pay, pl)
                    ReturnValue(0)
                }
                
                IfCondition EqualTo(mt, 69) ThenBlock: {  // Error
                    PrintMessage("ERROR: ")
                    PG_ParseError(pay, pl)
                    Deallocate(pay, pl)
                    ReturnValue(0)
                }
                
                Deallocate(pay, pl)
            }
            
            IfCondition EqualTo(mt, 90) ThenBlock: {  // Ready
                ReturnValue(1)
            }
        }
        
        ReturnValue(0)
    }
}