// Library.PostgreSQL_Extended.ailang
// Advanced PostgreSQL features: Prepared Statements, Transactions, Batch Operations

LibraryImport.Socket
LibraryImport.XArrays


// PostgreSQL protocol constants
FixedPool.PGConstants {
    "TX_IDLE": Initialize=0
    "TX_IN_TRANSACTION": Initialize=1
    "TX_ERROR": Initialize=2
}

// ============================================================================
// BINARY PROTOCOL HELPERS
// ============================================================================

// Add these helper functions to Library.PostgreSQL.ailang
// These are missing binary protocol utilities

// Write 32-bit integer in big-endian format
Function.PostgreSQL.WriteInt32BE {
    Input: buffer: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        // Big-endian: most significant byte first
        byte3 = RightShift(value, 24)
        byte2 = BitwiseAnd(RightShift(value, 16), 255)
        byte1 = BitwiseAnd(RightShift(value, 8), 255)
        byte0 = BitwiseAnd(value, 255)
        
        StoreValue(Add(buffer, offset), byte3)
        StoreValue(Add(buffer, Add(offset, 1)), byte2)
        StoreValue(Add(buffer, Add(offset, 2)), byte1)
        StoreValue(Add(buffer, Add(offset, 3)), byte0)
    }
}

// Write 16-bit integer in big-endian format
Function.PostgreSQL.WriteInt16BE {
    Input: buffer: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        byte1 = RightShift(value, 8)
        byte0 = BitwiseAnd(value, 255)
        
        StoreValue(Add(buffer, offset), byte1)
        StoreValue(Add(buffer, Add(offset, 1)), byte0)
    }
}

// Read 32-bit integer from big-endian format
Function.PostgreSQL.ReadInt32BE {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        byte3 = Dereference(Add(buffer, offset), "byte")
        byte2 = Dereference(Add(buffer, Add(offset, 1)), "byte")
        byte1 = Dereference(Add(buffer, Add(offset, 2)), "byte")
        byte0 = Dereference(Add(buffer, Add(offset, 3)), "byte")
        
        value = LeftShift(byte3, 24)
        value = BitwiseOr(value, LeftShift(byte2, 16))
        value = BitwiseOr(value, LeftShift(byte1, 8))
        value = BitwiseOr(value, byte0)
        
        ReturnValue(value)
    }
}

// Write null-terminated string to buffer, returns new offset
Function.PostgreSQL.WriteString {
    Input: buffer: Address
    Input: offset: Integer
    Input: str: Address
    Output: Integer
    Body: {
        len = StringLength(str)
        
        // Copy string bytes
        i = 0
        WhileLoop LessThan(i, len) {
            byte = Dereference(Add(str, i), "byte")
            StoreValue(Add(buffer, Add(offset, i)), byte)
            i = Add(i, 1)
        }
        
        // Add null terminator
        StoreValue(Add(buffer, Add(offset, len)), 0)
        
        // Return new offset (past the null terminator)
        ReturnValue(Add(offset, Add(len, 1)))
    }
}

// Read query response from PostgreSQL server
// Simplified - returns XArray of row data or 0 on error
Function.PostgreSQL.ReadQueryResponse {
    Input: sock: Integer
    Output: Address
    Body: {
        // TODO: Full implementation of PostgreSQL wire protocol
        // For now, return empty result set to allow compilation
        
        result = XArray.XCreate()
        
        // Read messages until we get CommandComplete or ReadyForQuery
        WhileLoop True {
            msg_type_buf = Socket.RecvExact(sock, 1)
            IfCondition EqualTo(msg_type_buf, 0) ThenBlock: {
                XArray.XDestroy(result)
                ReturnValue(0)
            }
            
            msg_type = GetByte(msg_type_buf, 0)
            Deallocate(msg_type_buf, 1)
            
            // Read message length
            len_buf = Socket.RecvExact(sock, 4)
            msg_len = PostgreSQL.ReadInt32BE(len_buf, 0)
            Deallocate(len_buf, 4)
            
            payload_len = Subtract(msg_len, 4)
            
            // Read payload if any
            IfCondition GreaterThan(payload_len, 0) ThenBlock: {
                payload = Socket.RecvExact(sock, payload_len)
                
                // 'C' = CommandComplete
                IfCondition EqualTo(msg_type, 67) ThenBlock: {
                    Deallocate(payload, payload_len)
                }
                
                // 'Z' = ReadyForQuery - we're done
                IfCondition EqualTo(msg_type, 90) ThenBlock: {
                    Deallocate(payload, payload_len)
                    ReturnValue(result)
                }
                
                // 'E' = Error
                IfCondition EqualTo(msg_type, 69) ThenBlock: {
                    PrintMessage("PostgreSQL Error: ")
                    PrintString(payload)
                    Deallocate(payload, payload_len)
                    XArray.XDestroy(result)
                    ReturnValue(0)
                }
                
                // Ignore other message types for now
                Deallocate(payload, payload_len)
            }
        }
        
        ReturnValue(result)
    }
}


// Execute SQL query and return results
// Connection structure: [socket_fd, ...]
Function.PostgreSQL.Query {
    Input: conn: Address
    Input: sql: Address
    Output: Address
    Body: {
        sock = Dereference(conn)
        
        // Build Query message
        // Format: 'Q' + int32(len) + query\0
        sql_len = StringLength(sql)
        msg_len = Add(Add(sql_len, 1), 5)
        
        msg = Allocate(msg_len)
        
        // Message type 'Q' (Query)
        StoreValue(msg, 81)
        
        // Length (excluding type byte)
        PostgreSQL.WriteInt32BE(msg, 1, Subtract(msg_len, 1))
        
        // Copy SQL string
        i = 0
        WhileLoop LessThan(i, sql_len) {
            byte = Dereference(Add(sql, i), "byte")
            StoreValue(Add(msg, Add(5, i)), byte)
            i = Add(i, 1)
        }
        
        // Null terminator
        StoreValue(Add(msg, Add(5, sql_len)), 0)
        
        // Send query
        sent = Socket.Send(sock, msg, msg_len)
        Deallocate(msg, msg_len)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to send query")
            ReturnValue(0)
        }
        
        // Read response
        result = PostgreSQL.ReadQueryResponse(sock)
        
        ReturnValue(result)
    }
}

// Connect to PostgreSQL server
// Returns connection handle or 0 on failure
Function.PostgreSQL.Connect {
    Input: host: Address
    Input: port: Integer
    Input: database: Address
    Input: user: Address
    Input: password: Address
    Output: Address
    Body: {
        Debug("pg_connect", level=1) { PrintMessage("DEBUG: Entered PostgreSQL.Connect") }

        // Create socket
        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Calling Socket.Create") }
        sock = Socket.Create(SocketConstants.AF_INET, SocketConstants.SOCK_STREAM)
        Debug("pg_connect", level=3) {
            PrintMessage("**************************************************")
            PrintMessage(">>> CHECKPOINT: Returned from Socket.Create. Value is:")
            PrintNumber(sock)
            PrintMessage("**************************************************")
        }
        Debug("pg_connect", level=1) {
            PrintMessage("DEBUG: Socket.Create returned socket fd:")
            PrintNumber(sock)
        }

        IfCondition LessThan(sock, 0) ThenBlock: {
            Debug("pg_connect", level=1) { PrintMessage("ERROR: Socket creation failed.") }
            ReturnValue(0)
        }

        // Create address
        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Calling Socket.CreateAddr") }
        addr = Socket.CreateAddr(host, port)
        Debug("pg_connect", level=1) {
            PrintMessage("DEBUG: Socket.CreateAddr returned address pointer:")
            PrintNumber(addr)
        }

        // Connect
        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Calling Socket.Connect") }
        result = Socket.Connect(sock, addr)
        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Socket.Connect returned. Deallocating addr.") }
        Deallocate(addr, 16)
        Debug("pg_connect", level=1) {
            PrintMessage("DEBUG: Socket.Connect returned:")
            PrintNumber(result)
        }

        IfCondition LessThan(result, 0) ThenBlock: {
            Debug("pg_connect", level=1) { PrintMessage("ERROR: Socket connection failed. Closing socket.") }
            Socket.Close(sock)
            ReturnValue(0)
        }

        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Sending PostgreSQL startup message...") }
        // TODO: Implement the actual startup message sending here.
        // This involves creating a buffer with user/database info.
        // For now, we will simulate success.
        Debug("pg_connect", level=2) { PrintMessage("DEBUG: (STUB) Startup message would be sent here.") }

        // TODO: Send PostgreSQL startup message with auth
        // For now, create minimal connection structure

        Debug("pg_connect", level=2) { PrintMessage("DEBUG: Allocating connection structure") }
        conn = Allocate(64)
        StoreValue(conn, sock)
        Debug("pg_connect", level=1) {
            PrintMessage("DEBUG: Connection structure created. Handle:")
            PrintNumber(conn)
        }

        PrintMessage("PostgreSQL: Connected to ")
        PrintString(host)

        Debug("pg_connect", level=1) { PrintMessage("DEBUG: Exiting PostgreSQL.Connect successfully") }
        ReturnValue(conn)
    }
}


// ============================================================================
// PREPARED STATEMENTS
// ============================================================================

// Prepared statement structure: [name, param_count, conn]
Function.PostgreSQL.Prepare {
    Input: conn: Address
    Input: stmt_name: Address
    Input: sql: Address
    Output: Address              // Statement handle or 0
    Body: {
        sock = Dereference(conn)
        
        // Build Parse message
        // Format: 'P' + int32(len) + name\0 + query\0 + int16(0)
        
        name_len = StringLength(stmt_name)
        sql_len = StringLength(sql)
        msg_len = Add(Add(Add(name_len, sql_len), 8), 0)  // type(1) + len(4) + name + null + sql + null + param_types(2)
        
        msg = Allocate(msg_len)
        offset = 0
        
        // Message type 'P' (Parse)
        StoreValue(msg, 80)
        offset = Add(offset, 1)
        
        // Length (excluding type byte)
        PostgreSQL.WriteInt32BE(msg, offset, Subtract(msg_len, 1))
        offset = Add(offset, 4)
        
        // Statement name
        offset = PostgreSQL.WriteString(msg, offset, stmt_name)
        
        // Query string
        offset = PostgreSQL.WriteString(msg, offset, sql)
        
        // Number of parameter data types (0 = infer)
        StoreValue(Add(msg, offset), 0)
        StoreValue(Add(msg, Add(offset, 1)), 0)
        
        // Send Parse message
        sent = Socket.Send(sock, msg, msg_len)
        Deallocate(msg, msg_len)
        
        IfCondition LessThan(sent, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Send Sync message to get immediate response
        sync_msg = Allocate(5)
        StoreValue(sync_msg, 83)  // 'S'
        PostgreSQL.WriteInt32BE(sync_msg, 1, 4)
        Socket.Send(sock, sync_msg, 5)
        Deallocate(sync_msg, 5)
        
        // Read response (ParseComplete + ReadyForQuery)
        success = PostgreSQL.WaitForParseComplete(sock)
        
        IfCondition EqualTo(success, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Create statement handle
        stmt = Allocate(32)
        StoreValue(stmt, stmt_name)
        StoreValue(Add(stmt, 8), 0)  // param_count (will be set on first execute)
        StoreValue(Add(stmt, 16), conn)
        
        // Store in connection's prepared statements hash
        stmts_hash = Dereference(Add(conn, 32))
        HashMap.HSetSimple(stmts_hash, stmt_name, stmt)
        
        PrintMessage("PostgreSQL: Prepared statement '")
        PrintString(stmt_name)
        PrintMessage("'")
        
        ReturnValue(stmt)
    }
}

Function.PostgreSQL.WaitForParseComplete {
    Input: sock: Integer
    Output: Integer
    Body: {
        WhileLoop True {
            msg_type_buf = Socket.RecvExact(sock, 1)
            IfCondition EqualTo(msg_type_buf, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            msg_type = GetByte(msg_type_buf, 0)
            Deallocate(msg_type_buf, 1)
            
            len_buf = Socket.RecvExact(sock, 4)
            msg_len = PostgreSQL.ReadInt32BE(len_buf, 0)
            Deallocate(len_buf, 4)
            
            payload_len = Subtract(msg_len, 4)
            
            IfCondition GreaterThan(payload_len, 0) ThenBlock: {
                payload = Socket.RecvExact(sock, payload_len)
                
                // '1' = ParseComplete
                IfCondition EqualTo(msg_type, 49) ThenBlock: {
                    Deallocate(payload, payload_len)
                    // Continue to ReadyForQuery
                } ElseBlock: {
                    // 'E' = Error
                    IfCondition EqualTo(msg_type, 69) ThenBlock: {
                        PrintMessage("PostgreSQL: Parse error: ")
                        PrintString(payload)
                        Deallocate(payload, payload_len)
                        ReturnValue(0)
                    } ElseBlock: {
                        // 'Z' = ReadyForQuery
                        IfCondition EqualTo(msg_type, 90) ThenBlock: {
                            Deallocate(payload, payload_len)
                            ReturnValue(1)
                        }
                    }
                }
                
                Deallocate(payload, payload_len)
            } ElseBlock: {
                IfCondition EqualTo(msg_type, 90) ThenBlock: {  // ReadyForQuery
                    ReturnValue(1)
                }
            }
        }
        
        ReturnValue(0)
    }
}

Function.PostgreSQL.ExecutePrepared {
    Input: stmt: Address
    Input: params: Address       // XArray of parameter values (as strings)
    Output: Address              // Result set
    Body: {
        conn = Dereference(Add(stmt, 16))
        sock = Dereference(conn)
        stmt_name = Dereference(stmt)
        
        param_count = XArray.XSize(params)
        
        // Build Bind message
        // Format: 'B' + len + portal\0 + stmt_name\0 + param_formats + param_count + params + result_formats
        
        name_len = StringLength(stmt_name)
        
        // Calculate message size (simplified - text format for all params)
        msg_len = Add(Add(Add(20, name_len), 0), Multiply(param_count, 4))
        
        // Add space for each parameter value
        i = 0
        WhileLoop LessThan(i, param_count) {
            param = XArray.XGet(params, i)
            IfCondition NotEqual(param, 0) ThenBlock: {
                param_len = StringLength(param)
                msg_len = Add(msg_len, param_len)
            }
            i = Add(i, 1)
        }
        
        msg = Allocate(msg_len)
        offset = 0
        
        // Message type 'B' (Bind)
        StoreValue(msg, 66)
        offset = Add(offset, 1)
        
        // Length (will update later)
        len_offset = offset
        offset = Add(offset, 4)
        
        // Portal name (empty = unnamed portal)
        StoreValue(Add(msg, offset), 0)
        offset = Add(offset, 1)
        
        // Statement name
        offset = PostgreSQL.WriteString(msg, offset, stmt_name)
        
        // Parameter format codes (0 = all text)
        StoreValue(Add(msg, offset), 0)
        StoreValue(Add(msg, Add(offset, 1)), 0)
        offset = Add(offset, 2)
        
        // Number of parameters
        PostgreSQL.WriteInt16BE(msg, offset, param_count)
        offset = Add(offset, 2)
        
        // Write each parameter
        i = 0
        WhileLoop LessThan(i, param_count) {
            param = XArray.XGet(params, i)
            
            IfCondition EqualTo(param, 0) ThenBlock: {
                // NULL parameter
                PostgreSQL.WriteInt32BE(msg, offset, -1)
                offset = Add(offset, 4)
            } ElseBlock: {
                param_len = StringLength(param)
                PostgreSQL.WriteInt32BE(msg, offset, param_len)
                offset = Add(offset, 4)
                
                // Copy parameter value
                j = 0
                WhileLoop LessThan(j, param_len) {
                    ch = GetByte(param, j)
                    StoreValue(Add(msg, Add(offset, j)), ch)
                    j = Add(j, 1)
                }
                offset = Add(offset, param_len)
            }
            
            i = Add(i, 1)
        }
        
        // Result format codes (0 = all text)
        StoreValue(Add(msg, offset), 0)
        StoreValue(Add(msg, Add(offset, 1)), 0)
        offset = Add(offset, 2)
        
        // Update length field
        actual_len = offset
        PostgreSQL.WriteInt32BE(msg, len_offset, Subtract(actual_len, 1))
        
        // Send Bind message
        Socket.Send(sock, msg, actual_len)
        Deallocate(msg, msg_len)
        
        // Send Execute message
        exec_msg = Allocate(10)
        StoreValue(exec_msg, 69)  // 'E'
        PostgreSQL.WriteInt32BE(exec_msg, 1, 9)
        StoreValue(Add(exec_msg, 5), 0)  // Portal name (empty)
        PostgreSQL.WriteInt32BE(exec_msg, 6, 0)  // Max rows (0 = unlimited)
        Socket.Send(sock, exec_msg, 10)
        Deallocate(exec_msg, 10)
        
        // Send Sync
        sync_msg = Allocate(5)
        StoreValue(sync_msg, 83)  // 'S'
        PostgreSQL.WriteInt32BE(sync_msg, 1, 4)
        Socket.Send(sock, sync_msg, 5)
        Deallocate(sync_msg, 5)
        
        // Read response
        result = PostgreSQL.ReadQueryResponse(sock)
        
        ReturnValue(result)
    }
}

Function.PostgreSQL.WriteInt16BE {
    Input: buffer: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        StoreValue(Add(buffer, offset), RightShift(value, 8))
        StoreValue(Add(buffer, Add(offset, 1)), BitwiseAnd(value, 255))
    }
}

// ============================================================================
// TRANSACTIONS
// ============================================================================

Function.PostgreSQL.Begin {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PostgreSQL.Query(conn, "BEGIN")
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            
            // Update connection transaction status
            StoreValue(Add(conn, 16), PGConstants.TX_IN_TRANSACTION)
            
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.PostgreSQL.Commit {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PostgreSQL.Query(conn, "COMMIT")
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            
            // Update connection transaction status
            StoreValue(Add(conn, 16), PGConstants.TX_IDLE)
            
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.PostgreSQL.Rollback {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PostgreSQL.Query(conn, "ROLLBACK")
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            
            // Update connection transaction status
            StoreValue(Add(conn, 16), PGConstants.TX_IDLE)
            
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.PostgreSQL.Savepoint {
    Input: conn: Address
    Input: savepoint_name: Address
    Output: Integer
    Body: {
        sql = StringConcat("SAVEPOINT ", savepoint_name)
        result = PostgreSQL.Query(conn, sql)
        Deallocate(sql, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.PostgreSQL.RollbackToSavepoint {
    Input: conn: Address
    Input: savepoint_name: Address
    Output: Integer
    Body: {
        sql = StringConcat("ROLLBACK TO SAVEPOINT ", savepoint_name)
        result = PostgreSQL.Query(conn, sql)
        Deallocate(sql, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

Function.PostgreSQL.BatchInsert {
    Input: conn: Address
    Input: table_name: Address
    Input: columns: Address      // XArray of column names
    Input: rows: Address         // XArray of XArrays (rows of values)
    Output: Integer              // Number of rows inserted
    Body: {
        col_count = XArray.XSize(columns)
        row_count = XArray.XSize(rows)
        
        IfCondition EqualTo(row_count, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Start transaction for batch
        PostgreSQL.Begin(conn)
        
        // Build INSERT statement
        sql = StringConcat("INSERT INTO ", table_name)
        sql = StringConcat(sql, " (")
        
        // Add column names
        i = 0
        WhileLoop LessThan(i, col_count) {
            col_name = XArray.XGet(columns, i)
            sql = StringConcat(sql, col_name)
            
            IfCondition LessThan(i, Subtract(col_count, 1)) ThenBlock: {
                sql = StringConcat(sql, ", ")
            }
            
            i = Add(i, 1)
        }
        
        sql = StringConcat(sql, ") VALUES ")
        
        // Add value tuples
        i = 0
        WhileLoop LessThan(i, row_count) {
            row = XArray.XGet(rows, i)
            sql = StringConcat(sql, "(")
            
            j = 0
            WhileLoop LessThan(j, col_count) {
                value = XArray.XGet(row, j)
                
                // Quote string values
                sql = StringConcat(sql, "'")
                sql = StringConcat(sql, value)
                sql = StringConcat(sql, "'")
                
                IfCondition LessThan(j, Subtract(col_count, 1)) ThenBlock: {
                    sql = StringConcat(sql, ", ")
                }
                
                j = Add(j, 1)
            }
            
            sql = StringConcat(sql, ")")
            
            IfCondition LessThan(i, Subtract(row_count, 1)) ThenBlock: {
                sql = StringConcat(sql, ", ")
            }
            
            i = Add(i, 1)
        }
        
        // Execute batch insert
        result = PostgreSQL.Query(conn, sql)
        Deallocate(sql, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            XArray.XDestroy(result)
            PostgreSQL.Commit(conn)
            ReturnValue(row_count)
        } ElseBlock: {
            PostgreSQL.Rollback(conn)
            ReturnValue(0)
        }
    }
}

// ============================================================================
// COPY (BULK LOAD)
// ============================================================================

Function.PostgreSQL.CopyFrom {
    Input: conn: Address
    Input: table_name: Address
    Input: columns: Address      // XArray of column names
    Input: data: Address         // Tab-separated values (TSV format)
    Output: Integer              // Rows loaded
    Body: {
        sock = Dereference(conn)
        
        // Build COPY command
        sql = StringConcat("COPY ", table_name)
        
        IfCondition NotEqual(columns, 0) ThenBlock: {
            sql = StringConcat(sql, " (")
            
            col_count = XArray.XSize(columns)
            i = 0
            WhileLoop LessThan(i, col_count) {
                col = XArray.XGet(columns, i)
                sql = StringConcat(sql, col)
                
                IfCondition LessThan(i, Subtract(col_count, 1)) ThenBlock: {
                    sql = StringConcat(sql, ", ")
                }
                
                i = Add(i, 1)
            }
            
            sql = StringConcat(sql, ")")
        }
        
        sql = StringConcat(sql, " FROM STDIN")
        
        // Send COPY query
        result = PostgreSQL.Query(conn, sql)
        Deallocate(sql, 0)
        
        // Send data followed by end marker
        data_len = StringLength(data)
        Socket.Send(sock, data, data_len)
        
        // Send copy done marker: "\.\n"
        end_marker = Allocate(4)
        StoreValue(end_marker, 92)   // '\'
        StoreValue(Add(end_marker, 1), 46)  // '.'
        StoreValue(Add(end_marker, 2), 10)  // '\n'
        StoreValue(Add(end_marker, 3), 0)
        Socket.Send(sock, end_marker, 3)
        Deallocate(end_marker, 4)
        
        // Read completion response
        // TODO: Parse row count from CommandComplete message
        
        ReturnValue(1)
    }
}