AILANG vs Redis-Style Pool Allocator Benchmark
This repository contains a performance benchmark comparing AILANG, a new programming language, against a Redis-style Simple Dynamic Strings (SDS) allocator and a custom C-based pool allocator. The benchmark tests string concatenation efficiency with varying approaches.
Overview

AILANG: A concise, high-level language with built-in pool allocation.
Redis SDS: A C implementation with pre-allocation and dynamic resizing.
C Pool: A custom mmap-based pool allocator for comparison.
Makefile: Orchestrates building and running both benchmarks.

Benchmark Results (500 Concatenations)
Speed Comparison

Standard C: ~44,136 cycles (1,001 mallocs).
Redis SDS: ~4,860 cycles (1-2 allocations).
C Pool (estimated): ~14,400 cycles (1 mmap, pending fix).
AILANG Pooled: ~4,338 cycles (1 mmap).
Visualization: Speed Comparison Chart

Lines of Code (LOC)

C (redis_pool_bench.c): 171 LOC.
AILANG (test_pool_real.ailang): 61 LOC.
Ratio: AILANG is ~35.7% of C’s LOC, a 2.8x reduction.

Binary Size

redis_pool_bench: 16,824 bytes.
test_pool_real_exec: 12,884 bytes.
Observation: AILANG’s binary is ~76.6% of C’s size, indicating a more compact executable, likely due to less compiled code despite the Python runtime overhead.

Setup

Ensure WSL or a Linux environment with gcc and python3.
Place redis_pool_bench.c, test_pool_real.ailang, main.py, and benchmark.mak in the repo directory.
Run: make -f benchmark.mak benchmark.

Issues

C Pool Segfault: Occurs at 1,000 concatenations due to pool overflow (fixed with 1MB pool, pending retest).
AILANG Bug: Reports 0 bytes used and truncated results ("A") at 1,000x, likely a 512-character limit.

Future Work

Fix C pool segfault with 1MB pool and retest at 500x.
Resolve AILANG’s pool tracking bug.
Scale to 1,000+ concatenations with larger pools.

License
See github repo
Last Updated
09:03 PM EDT, Wednesday, September 10, 2025
