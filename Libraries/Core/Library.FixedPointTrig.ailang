// Library.FixedPointTrig.ailang
// Fixed-point trigonometry library for AILANG
// Uses integer arithmetic with scale factor of 10000 (4 decimal places)
// Angles in degrees for simplicity

PrintMessage("Loading Fixed-Point Trigonometry Library v1.0")
PrintMessage("==============================================")

// Fixed-point configuration
// Scale: 10000 = 1.0000 in fixed-point
// This gives us 4 decimal places of precision
FixedPool.FixedPointTrig {
    "scale": Initialize=10000,
    "pi": Initialize=31416,           // 3.1416 * 10000
    "half_pi": Initialize=15708,      // 1.5708 * 10000
    "two_pi": Initialize=62832,       // 6.2832 * 10000
    "e": Initialize=27183,            // 2.7183 * 10000
    "deg_to_rad": Initialize=175,     // 0.0175 * 10000 (pi/180)
    "rad_to_deg": Initialize=572958   // 57.2958 * 10000 (180/pi)
}

// Sin lookup table (0-90 degrees, every degree)
// Values are multiplied by 10000
FixedPool.SinTable {
    "sin_0": Initialize=0,      // sin(0°) = 0.0000
    "sin_1": Initialize=175,    // sin(1°) = 0.0175
    "sin_2": Initialize=349,    // sin(2°) = 0.0349
    "sin_3": Initialize=523,    // sin(3°) = 0.0523
    "sin_4": Initialize=698,    // sin(4°) = 0.0698
    "sin_5": Initialize=872,    // sin(5°) = 0.0872
    "sin_6": Initialize=1045,   // sin(6°) = 0.1045
    "sin_7": Initialize=1219,   // sin(7°) = 0.1219
    "sin_8": Initialize=1392,   // sin(8°) = 0.1392
    "sin_9": Initialize=1564,   // sin(9°) = 0.1564
    "sin_10": Initialize=1736,  // sin(10°) = 0.1736
    "sin_15": Initialize=2588,  // sin(15°) = 0.2588
    "sin_20": Initialize=3420,  // sin(20°) = 0.3420
    "sin_25": Initialize=4226,  // sin(25°) = 0.4226
    "sin_30": Initialize=5000,  // sin(30°) = 0.5000
    "sin_35": Initialize=5736,  // sin(35°) = 0.5736
    "sin_40": Initialize=6428,  // sin(40°) = 0.6428
    "sin_45": Initialize=7071,  // sin(45°) = 0.7071
    "sin_50": Initialize=7660,  // sin(50°) = 0.7660
    "sin_55": Initialize=8192,  // sin(55°) = 0.8192
    "sin_60": Initialize=8660,  // sin(60°) = 0.8660
    "sin_65": Initialize=9063,  // sin(65°) = 0.9063
    "sin_70": Initialize=9397,  // sin(70°) = 0.9397
    "sin_75": Initialize=9659,  // sin(75°) = 0.9659
    "sin_80": Initialize=9848,  // sin(80°) = 0.9848
    "sin_85": Initialize=9962,  // sin(85°) = 0.9962
    "sin_90": Initialize=10000  // sin(90°) = 1.0000
}

// === CONVERSION FUNCTIONS ===

Function.FixedPoint.FromInt {
    Input: value: Integer
    Output: Integer
    Body: {
        // Convert integer to fixed-point
        ReturnValue(Multiply(value, FixedPointTrig.scale))
    }
}

Function.FixedPoint.ToInt {
    Input: fixed: Integer
    Output: Integer
    Body: {
        // Convert fixed-point to integer (with rounding)
        half_scale = Divide(FixedPointTrig.scale, 2)
        rounded = Add(fixed, half_scale)
        ReturnValue(Divide(rounded, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Multiply {
    Input: a: Integer
    Input: b: Integer
    Output: Integer
    Body: {
        // Multiply two fixed-point numbers
        product = Multiply(a, b)
        ReturnValue(Divide(product, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Divide {
    Input: a: Integer
    Input: b: Integer
    Output: Integer
    Body: {
        // Divide two fixed-point numbers
        // Check for divide by zero
        is_zero = EqualTo(b, 0)
        IfCondition is_zero ThenBlock {
            PrintMessage("ERROR: Fixed-point divide by zero")
            ReturnValue(0)
        }
        
        // Scale numerator before division
        scaled_a = Multiply(a, FixedPointTrig.scale)
        ReturnValue(Divide(scaled_a, b))
    }
}

// === ANGLE NORMALIZATION ===

Function.Trig.NormalizeDegrees {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Normalize angle to 0-359 range
        angle = degrees
        
        // Handle negative angles
        WhileLoop LessThan(angle, 0) {
            angle = Add(angle, 360)
        }
        
        // Handle angles >= 360
        WhileLoop GreaterEqual(angle, 360) {
            angle = Subtract(angle, 360)
        }
        
        ReturnValue(angle)
    }
}

// === TRIGONOMETRIC FUNCTIONS ===

Function.Trig.Sin {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Returns sin(degrees) in fixed-point format
        angle = Trig.NormalizeDegrees(degrees)
        
        // Determine quadrant and adjust
        quadrant = 1
        
        IfCondition GreaterThan(angle, 270) ThenBlock {
            quadrant = 4
            angle = Subtract(360, angle)
            // sin(360-x) = -sin(x)
        } ElseBlock {
            IfCondition GreaterThan(angle, 180) ThenBlock {
                quadrant = 3
                angle = Subtract(angle, 180)
                // sin(180+x) = -sin(x)
            } ElseBlock {
                IfCondition GreaterThan(angle, 90) ThenBlock {
                    quadrant = 2
                    angle = Subtract(180, angle)
                    // sin(180-x) = sin(x)
                }
            }
        }
        
        // Look up value for 0-90 range
        result = Trig.SinLookup(angle)
        
        // Apply sign based on quadrant
        IfCondition EqualTo(quadrant, 3) ThenBlock {
            result = Subtract(0, result)
        }
        IfCondition EqualTo(quadrant, 4) ThenBlock {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.SinLookup {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Simple lookup for key angles (extend as needed)
        IfCondition EqualTo(degrees, 0) ThenBlock { ReturnValue(SinTable.sin_0) }
        IfCondition EqualTo(degrees, 1) ThenBlock { ReturnValue(SinTable.sin_1) }
        IfCondition EqualTo(degrees, 2) ThenBlock { ReturnValue(SinTable.sin_2) }
        IfCondition EqualTo(degrees, 3) ThenBlock { ReturnValue(SinTable.sin_3) }
        IfCondition EqualTo(degrees, 4) ThenBlock { ReturnValue(SinTable.sin_4) }
        IfCondition EqualTo(degrees, 5) ThenBlock { ReturnValue(SinTable.sin_5) }
        IfCondition EqualTo(degrees, 10) ThenBlock { ReturnValue(SinTable.sin_10) }
        IfCondition EqualTo(degrees, 15) ThenBlock { ReturnValue(SinTable.sin_15) }
        IfCondition EqualTo(degrees, 20) ThenBlock { ReturnValue(SinTable.sin_20) }
        IfCondition EqualTo(degrees, 25) ThenBlock { ReturnValue(SinTable.sin_25) }
        IfCondition EqualTo(degrees, 30) ThenBlock { ReturnValue(SinTable.sin_30) }
        IfCondition EqualTo(degrees, 35) ThenBlock { ReturnValue(SinTable.sin_35) }
        IfCondition EqualTo(degrees, 40) ThenBlock { ReturnValue(SinTable.sin_40) }
        IfCondition EqualTo(degrees, 45) ThenBlock { ReturnValue(SinTable.sin_45) }
        IfCondition EqualTo(degrees, 50) ThenBlock { ReturnValue(SinTable.sin_50) }
        IfCondition EqualTo(degrees, 55) ThenBlock { ReturnValue(SinTable.sin_55) }
        IfCondition EqualTo(degrees, 60) ThenBlock { ReturnValue(SinTable.sin_60) }
        IfCondition EqualTo(degrees, 65) ThenBlock { ReturnValue(SinTable.sin_65) }
        IfCondition EqualTo(degrees, 70) ThenBlock { ReturnValue(SinTable.sin_70) }
        IfCondition EqualTo(degrees, 75) ThenBlock { ReturnValue(SinTable.sin_75) }
        IfCondition EqualTo(degrees, 80) ThenBlock { ReturnValue(SinTable.sin_80) }
        IfCondition EqualTo(degrees, 85) ThenBlock { ReturnValue(SinTable.sin_85) }
        IfCondition EqualTo(degrees, 90) ThenBlock { ReturnValue(SinTable.sin_90) }
        
        // For angles not in table, use linear interpolation
        // This is simplified - just return nearest
        IfCondition LessThan(degrees, 8) ThenBlock {
            ReturnValue(Multiply(degrees, 175))  // Approximate
        }
        
        // Default fallback
        ReturnValue(0)
    }
}

Function.Trig.Cos {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // cos(x) = sin(x + 90)
        shifted = Add(degrees, 90)
        ReturnValue(Trig.Sin(shifted))
    }
}

Function.Trig.Tan {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // tan(x) = sin(x) / cos(x)
        sin_val = Trig.Sin(degrees)
        cos_val = Trig.Cos(degrees)
        
        // Check for divide by zero (cos = 0 at 90, 270)
        is_zero = EqualTo(cos_val, 0)
        IfCondition is_zero ThenBlock {
            // Return large value for "infinity"
            is_positive = GreaterThan(sin_val, 0)
            IfCondition is_positive ThenBlock {
                ReturnValue(999999)
            }
            ReturnValue(-999999)
        }
        
        ReturnValue(FixedPoint.Divide(sin_val, cos_val))
    }
}

// === INVERSE TRIG FUNCTIONS (using approximations) ===

Function.Trig.Atan {
    Input: fixed_value: Integer
    Output: Integer  // Returns degrees
    Body: {
        // Simple atan approximation using table lookup
        // For now, just handle common angles
        
        abs_val = fixed_value
        is_negative = LessThan(fixed_value, 0)
        IfCondition is_negative ThenBlock {
            abs_val = Subtract(0, fixed_value)
        }
        
        // Check common values (in fixed-point)
        IfCondition LessEqual(abs_val, 175) ThenBlock {
            result = 1  // atan(0.0175) ≈ 1°
        } ElseBlock {
            IfCondition LessEqual(abs_val, 364) ThenBlock {
                result = 2  // atan(0.0364) ≈ 2°
            } ElseBlock {
                IfCondition LessEqual(abs_val, 5773) ThenBlock {
                    result = 30  // atan(0.5773) ≈ 30°
                } ElseBlock {
                    IfCondition LessEqual(abs_val, 10000) ThenBlock {
                        result = 45  // atan(1.0) = 45°
                    } ElseBlock {
                        IfCondition LessEqual(abs_val, 17321) ThenBlock {
                            result = 60  // atan(1.732) ≈ 60°
                        } ElseBlock {
                            result = 89  // Near 90°
                        }
                    }
                }
            }
        }
        
        IfCondition is_negative ThenBlock {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Atan2 {
    Input: y: Integer
    Input: x: Integer
    Output: Integer  // Returns degrees
    Body: {
        // atan2(y, x) - handles all quadrants
        
        // Handle special cases
        is_x_zero = EqualTo(x, 0)
        is_y_zero = EqualTo(y, 0)
        
        IfCondition is_x_zero ThenBlock {
            IfCondition is_y_zero ThenBlock {
                ReturnValue(0)  // Undefined, return 0
            }
            IfCondition GreaterThan(y, 0) ThenBlock {
                ReturnValue(90)
            }
            ReturnValue(270)
        }
        
        IfCondition is_y_zero ThenBlock {
            IfCondition GreaterThan(x, 0) ThenBlock {
                ReturnValue(0)
            }
            ReturnValue(180)
        }
        
        // Calculate atan(y/x) and adjust for quadrant
        ratio = FixedPoint.Divide(y, x)
        angle = Trig.Atan(ratio)
        
        IfCondition LessThan(x, 0) ThenBlock {
            IfCondition GreaterEqual(y, 0) ThenBlock {
                angle = Add(angle, 180)
            } ElseBlock {
                angle = Subtract(angle, 180)
            }
        }
        
        ReturnValue(Trig.NormalizeDegrees(angle))
    }
}

// === EXPONENTIAL AND LOGARITHM (using series approximations) ===

Function.Math.Exp {
    Input: x: Integer  // Fixed-point input
    Output: Integer    // Fixed-point output
    Body: {
        // exp(x) using Taylor series: 1 + x + x²/2! + x³/3! + ...
        // Limited to small x for accuracy
        
        // Start with 1.0 in fixed-point
        result = FixedPointTrig.scale
        term = FixedPointTrig.scale
        
        // Calculate first 8 terms
        i = 1
        WhileLoop LessEqual(i, 8) {
            term = FixedPoint.Multiply(term, x)
            term = Divide(term, i)  // Divide by factorial
            result = Add(result, term)
            
            // Early exit if term becomes too small
            IfCondition LessThan(term, 10) ThenBlock {
                BreakLoop
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

Function.Math.Log {
    Input: x: Integer  // Fixed-point input > 0
    Output: Integer    // Fixed-point output
    Body: {
        // Natural log using series approximation
        // ln(x) = ln(1+y) where y = (x-1)
        // Series: y - y²/2 + y³/3 - y⁴/4 + ...
        
        IfCondition LessEqual(x, 0) ThenBlock {
            PrintMessage("ERROR: Log of non-positive number")
            ReturnValue(0)
        }
        
        // For x close to 1, use series
        y = Subtract(x, FixedPointTrig.scale)
        
        // If x is far from 1, scale it first
        scale_count = 0
        temp_x = x
        WhileLoop GreaterThan(temp_x, Multiply(2, FixedPointTrig.scale)) {
            temp_x = Divide(temp_x, 2)
            scale_count = Add(scale_count, 1)
        }
        
        // Now compute log of scaled value
        y = Subtract(temp_x, FixedPointTrig.scale)
        result = 0
        term = y
        sign = 1
        
        i = 1
        WhileLoop LessEqual(i, 10) {
            divisor = Multiply(i, FixedPointTrig.scale)
            term_contribution = FixedPoint.Divide(term, divisor)
            
            IfCondition EqualTo(sign, 1) ThenBlock {
                result = Add(result, term_contribution)
            } ElseBlock {
                result = Subtract(result, term_contribution)
            }
            
            term = FixedPoint.Multiply(term, y)
            sign = Subtract(0, sign)
            i = Add(i, 1)
        }
        
        // Add back the scaling: log(2) = 0.693147 * scale_count
        log2 = 6931  // log(2) * 10000
        result = Add(result, Multiply(scale_count, log2))
        
        ReturnValue(result)
    }
}

Function.Math.Pow {
    Input: base: Integer    // Fixed-point
    Input: exponent: Integer // Fixed-point
    Output: Integer         // Fixed-point
    Body: {
        // pow(a, b) = exp(b * log(a))
        
        // Special cases
        IfCondition EqualTo(exponent, 0) ThenBlock {
            ReturnValue(FixedPointTrig.scale)  // Return 1.0
        }
        
        IfCondition EqualTo(base, 0) ThenBlock {
            ReturnValue(0)
        }
        
        // For integer exponents, use repeated multiplication
        is_int_exp = EqualTo(Modulo(exponent, FixedPointTrig.scale), 0)
        IfCondition is_int_exp ThenBlock {
            int_exp = Divide(exponent, FixedPointTrig.scale)
            result = FixedPointTrig.scale  // 1.0
            
            i = 0
            WhileLoop LessThan(i, int_exp) {
                result = FixedPoint.Multiply(result, base)
                i = Add(i, 1)
            }
            
            ReturnValue(result)
        }
        
        // General case: exp(exponent * log(base))
        log_base = Math.Log(base)
        product = FixedPoint.Multiply(exponent, log_base)
        ReturnValue(Math.Exp(product))
    }
}

// === HYPERBOLIC FUNCTIONS ===

Function.Trig.Sinh {
    Input: x: Integer  // Fixed-point
    Output: Integer    // Fixed-point
    Body: {
        // sinh(x) = (e^x - e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        diff = Subtract(exp_x, exp_neg_x)
        ReturnValue(Divide(diff, 2))
    }
}

Function.Trig.Cosh {
    Input: x: Integer  // Fixed-point
    Output: Integer    // Fixed-point
    Body: {
        // cosh(x) = (e^x + e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        sum = Add(exp_x, exp_neg_x)
        ReturnValue(Divide(sum, 2))
    }
}

Function.Trig.Tanh {
    Input: x: Integer  // Fixed-point
    Output: Integer    // Fixed-point
    Body: {
        // tanh(x) = sinh(x) / cosh(x)
        sinh_val = Trig.Sinh(x)
        cosh_val = Trig.Cosh(x)
        
        ReturnValue(FixedPoint.Divide(sinh_val, cosh_val))
    }
}

// === INTEGER SQUARE ROOT (for distance calculations) ===

Function.Math.ISqrt {
    Input: n: Integer
    Output: Integer
    Body: {
        // Integer square root using Newton's method
        IfCondition LessEqual(n, 0) ThenBlock {
            ReturnValue(0)
        }
        
        x = n
        y = Divide(Add(x, 1), 2)
        
        WhileLoop LessThan(y, x) {
            x = y
            y = Divide(Add(y, Divide(n, y)), 2)
        }
        
        ReturnValue(x)
    }
}

// === UTILITY FUNCTIONS ===

Function.Math.Distance2D {
    Input: x1: Integer
    Input: y1: Integer
    Input: x2: Integer
    Input: y2: Integer
    Output: Integer
    Body: {
        dx = Subtract(x2, x1)
        dy = Subtract(y2, y1)
        
        // Fixed-point squares
        dx_sq = FixedPoint.Multiply(dx, dx)
        dy_sq = FixedPoint.Multiply(dy, dy)
        
        sum = Add(dx_sq, dy_sq)
        
        // Convert to integer for ISqrt, then back to fixed-point
        sum_int = FixedPoint.ToInt(sum)
        sqrt_int = Math.ISqrt(sum_int)
        
        ReturnValue(FixedPoint.FromInt(sqrt_int))
    }
}

// === TEST THE LIBRARY ===

PrintMessage("")
PrintMessage("Testing Fixed-Point Trig Library:")
PrintMessage("----------------------------------")

// Test basic trig
sin30 = Trig.Sin(30)
PrintMessage("sin(30°) = 0.5000, got:")
PrintNumber(sin30)

cos60 = Trig.Cos(60)
PrintMessage("cos(60°) = 0.5000, got:")
PrintNumber(cos60)

tan45 = Trig.Tan(45)
PrintMessage("tan(45°) = 1.0000, got:")
PrintNumber(tan45)

// Test fixed-point multiplication
a = FixedPoint.FromInt(3)
b = FixedPoint.FromInt(4)
product = FixedPoint.Multiply(a, b)
PrintMessage("3 * 4 = 12, got:")
PrintNumber(FixedPoint.ToInt(product))

// Test distance
dist = Math.Distance2D(0, 0, 30000, 40000)  // 3,4 in fixed-point
PrintMessage("Distance from (0,0) to (3,4) = 5, got:")
PrintNumber(FixedPoint.ToInt(dist))

PrintMessage("")
PrintMessage("Library ready for use!")
PrintMessage("Note: All trig functions use degrees")
PrintMessage("Fixed-point scale: 10000 (4 decimal places)")