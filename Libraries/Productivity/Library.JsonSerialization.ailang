// ============================================================================
// AILANG Unified JSON & Serialization Library
// High-Performance Data Interchange with Cache-Optimized Parsing
// Merged from Library.JsonSerialization.ailang + Library.Json.ailang.Json
// ============================================================================

// Cache-Optimized Memory Pools for High-Performance JSON Operations
Pool.JSON.Parser = DynamicPool {
    "parse_buffers": ElementType-Byte, MaximumLength-1073741824,  // 1GB for large JSON
    "token_streams": ElementType-JSONToken, MaximumLength-10000000,
    "parse_stack": ElementType-Address, MaximumLength-1000000,
    "string_buffer": ElementType-Byte, MaximumLength-10485760,  // 10MB for strings
    "cache_policy": Initialize-"L2", CanChange-False
}

Pool.JSON.Objects = DynamicPool {
    "json_objects": ElementType-JSONObject, MaximumLength-1000000,
    "json_arrays": ElementType-JSONArray, MaximumLength-1000000,
    "json_values": ElementType-JSONValue, MaximumLength-10000000,
    "cache_alignment": Initialize-64, CanChange-False
}

Pool.JSON.Strings = TemporalPool {
    "string_pool": ElementType-Text, MaximumLength-10000000,
    "escaped_strings": ElementType-Text, MaximumLength-1000000,
    "unicode_cache": ElementType-Text, MaximumLength-100000,
    "lifetime": Initialize-"parse_scope", CanChange-False
}

Pool.Serialization.Binary = FixedPool {
    "msgpack_buffers": ElementType-Byte, MaximumLength-536870912,  // 512MB
    "protobuf_buffers": ElementType-Byte, MaximumLength-268435456,  // 256MB
    "custom_buffers": ElementType-Byte, MaximumLength-268435456,
    "cache_policy": Initialize-"L1", CanChange-False
}

Pool.Serialization.Schema = FixedPool {
    "schemas": ElementType-SchemaDefinition, MaximumLength-10000,
    "field_definitions": ElementType-FieldDef, MaximumLength-100000,
    "type_mappings": ElementType-TypeMapping, MaximumLength-100000,
    "validation_cache": ElementType-Address, MaximumLength-10000
}

Pool.JSON.Output = TemporalPool {
    "output_buffers": ElementType-Byte, MaximumLength-104857600,  // 100MB buffer
    "formatted_strings": ElementType-Text, MaximumLength-100000,
    "serialization_cache": ElementType-Address, MaximumLength-10000,
    "lifetime": Initialize-"function_scope", CanChange-False
}

// ============================================================================
// Enhanced Core Data Types
// ============================================================================

JSONValue = Record {
    type: Text,  // "null", "boolean", "number", "string", "array", "object"
    value: Any,
    source_position: UInt32,  // For enhanced error reporting
    line: UInt32,             // Line number in source
    column: UInt32,           // Column number in source
    cached_string: OptionalType[Text],
    hash_cache: OptionalType[UInt64]
}

JSONObject = Record {
    fields: Map[Text, JSONValue],
    field_count: UInt32,
    insertion_order: Array[Text],  // Preserve field order
    hash_cache: OptionalType[UInt64],
    validation_cache: OptionalType[Boolean]
}

JSONArray = Record {
    elements: Array[JSONValue],
    element_count: UInt32,
    homogeneous_type: OptionalType[Text],  // Optimization for typed arrays
    size_cache: OptionalType[UInt32],
    validation_cache: OptionalType[Boolean]
}

JSONToken = Record {
    type: Text,  // "left_brace", "right_brace", "left_bracket", "right_bracket", "comma", "colon", "string", "number", "boolean", "null"
    value: Text,
    position: UInt32,
    line: UInt32,
    column: UInt32,
    raw_value: OptionalType[Text]  // Original unescaped value
}

JSONParseContext = Record {
    input: Text,
    position: UInt32,
    length: UInt32,
    line: UInt32,
    column: UInt32,
    tokens: Array[JSONToken],
    token_index: UInt32,
    current_token: UInt32,
    error_message: OptionalType[Text],
    parse_options: JSONParseOptions
}

JSONParseOptions = Record {
    allow_comments: Boolean,
    allow_trailing_commas: Boolean,
    allow_unquoted_keys: Boolean,
    max_depth: UInt32,
    string_pool_enabled: Boolean,
    validate_utf8: Boolean,
    cache_strings: Boolean,
    strict_mode: Boolean
}

JSONSerializeOptions = Record {
    pretty_print: Boolean,
    indent_size: Integer,
    indent_string: Text,
    sort_keys: Boolean,
    escape_unicode: Boolean,
    compact: Boolean,
    cache_output: Boolean
}

SerializationFormat = Record {
    name: Text,  // "JSON", "MessagePack", "ProtoBuf", "BSON", "Custom"
    version: Text,
    options: Map[Text, Any],
    performance_profile: Text  // "speed", "size", "compatibility"
}

SchemaDefinition = Record {
    name: Text,
    version: Text,
    fields: Array[FieldDef],
    required_fields: Array[Text],
    validation_rules: Array[ValidationRule],
    cache_enabled: Boolean
}

FieldDef = Record {
    name: Text,
    type: Text,
    required: Boolean,
    default_value: OptionalType[Any],
    constraints: Array[FieldConstraint],
    validation_function: OptionalType[Function]
}

ValidationRule = Record {
    field_name: Text,
    rule_type: Text,  // "range", "length", "pattern", "custom"
    parameters: Array[Any],
    error_message: Text,
    severity: Text  // "error", "warning", "info"
}

FieldConstraint = Record {
    type: Text,  // "min", "max", "length", "pattern", "enum"
    value: Any,
    error_message: OptionalType[Text]
}

TypeMapping = Record {
    source_type: Text,
    target_type: Text,
    conversion_function: OptionalType[Function],
    bidirectional: Boolean
}

// ============================================================================
// Enhanced JSON Parsing with Robust Tokenization
// ============================================================================

Function.JSON.Parse {
    Input: (
        json_string: Text,
        options: OptionalType[JSONParseOptions] = Null
    )
    Output: JSONValue
    Body: {
        IfCondition EqualTo(StringLength(json_string), 0) ThenBlock {
            TryBlock: {} CatchError.EmptyJSONInput {
                PrintMessage("Empty JSON input")
                ReturnValue(JSON.CreateNull())
            }
        }
        
        IfCondition EqualTo(options, Null) ThenBlock {
            options = JSON.GetDefaultParseOptions()
        }
        
        // Create enhanced parse context
        context = JSON.CreateParseContext(json_string, options)
        
        TryBlock: {
            // Enhanced tokenization with better error handling
            JSON.Tokenize(context)
            
            // Parse tokens into JSON value with position tracking
            result = JSON.ParseValue(context)
            
            // Verify we consumed all tokens
            IfCondition LessThan(context.current_token, ArrayLength(context.tokens)) ThenBlock {
                remaining_token = context.tokens[context.current_token]
                TryBlock: {} CatchError.ExtraTokens {
                    PrintMessage(StringConcat(
                        "Unexpected token '", remaining_token.value, 
                        "' at line ", NumberToString(remaining_token.line),
                        ", column ", NumberToString(remaining_token.column)
                    ))
                }
            }
            
            ReturnValue(result)
        }
        CatchError.ParseError {
            error_msg = StringConcat(
                "JSON Parse Error at line ", NumberToString(context.line),
                ", column ", NumberToString(context.column)
            )
            IfCondition NotEqual(context.error_message, Null) ThenBlock {
                error_msg = StringConcat(error_msg, ": ", context.error_message)
            }
            
            PrintMessage(error_msg)
            ReturnValue(JSON.CreateNull())
        }
    }
}

Function.JSON.CreateParseContext {
    Input: (input: Text, options: JSONParseOptions)
    Output: JSONParseContext
    Body: {
        Pool.JSON.Parser.Allocate(context)
        context.input = input
        context.position = 0
        context.length = StringLength(input)
        context.line = 1
        context.column = 1
        context.tokens = Array.Create()
        context.token_index = 0
        context.current_token = 0
        context.error_message = Null
        context.parse_options = options
        
        ReturnValue(context)
    }
}

Function.JSON.Tokenize {
    Input: (context: JSONParseContext)
    Body: {
        WhileLoop LessThan(context.position, context.length) {
            JSON.SkipWhitespace(context)
            
            IfCondition GreaterEqual(context.position, context.length) ThenBlock {
                BreakLoop
            }
            
            // Handle comments if allowed
            IfCondition context.parse_options.allow_comments ThenBlock {
                IfCondition JSON.TrySkipComment(context) ThenBlock {
                    ContinueLoop
                }
            }
            
            char = StringCharAt(context.input, context.position)
            
            ChoosePath char {
                CaseOption "{": JSON.AddSimpleToken(context, "left_brace", "{")
                CaseOption "}": JSON.AddSimpleToken(context, "right_brace", "}")
                CaseOption "[": JSON.AddSimpleToken(context, "left_bracket", "[")
                CaseOption "]": JSON.AddSimpleToken(context, "right_bracket", "]")
                CaseOption ",": JSON.AddSimpleToken(context, "comma", ",")
                CaseOption ":": JSON.AddSimpleToken(context, "colon", ":")
                CaseOption "\"": JSON.ParseStringToken(context)
                CaseOption "t": JSON.ParseLiteralToken(context, "true", "boolean")
                CaseOption "f": JSON.ParseLiteralToken(context, "false", "boolean")
                CaseOption "n": JSON.ParseLiteralToken(context, "null", "null")
                DefaultOption: {
                    IfCondition Or(Or(JSON.IsDigit(char), StringEquals(char, "-")), StringEquals(char, "+")) ThenBlock {
                        JSON.ParseNumberToken(context)
                    } ElseBlock {
                        context.error_message = StringConcat("Unexpected character: ", char)
                        TryBlock: {} CatchError.UnexpectedCharacter {}
                    }
                }
            }
        }
    }
}

Function.JSON.SkipWhitespace {
    Input: (context: JSONParseContext)
    Body: {
        WhileLoop And(
            LessThan(context.position, context.length),
            JSON.IsWhitespace(StringCharAt(context.input, context.position))
        ) {
            char = StringCharAt(context.input, context.position)
            
            IfCondition StringEquals(char, "\n") ThenBlock {
                context.line = Add(context.line, 1)
                context.column = 1
            } ElseBlock {
                context.column = Add(context.column, 1)
            }
            
            context.position = Add(context.position, 1)
        }
    }
}

Function.JSON.TrySkipComment {
    Input: (context: JSONParseContext)
    Output: Boolean
    Body: {
        IfCondition And(
            LessThan(Add(context.position, 1), context.length),
            StringEquals(StringCharAt(context.input, context.position), "/")
        ) ThenBlock {
            next_char = StringCharAt(context.input, Add(context.position, 1))
            
            IfCondition StringEquals(next_char, "/") ThenBlock {
                // Single-line comment
                JSON.SkipToEndOfLine(context)
                ReturnValue(True)
            } ElseBox {
                IfCondition StringEquals(next_char, "*") ThenBlock {
                    // Multi-line comment
                    JSON.SkipMultiLineComment(context)
                    ReturnValue(True)
                }
            }
        }
        
        ReturnValue(False)
    }
}

Function.JSON.AddSimpleToken {
    Input: (context: JSONParseContext, type: Text, value: Text)
    Body: {
        Pool.JSON.Parser.Allocate(token)
        token.type = type
        token.value = value
        token.position = context.position
        token.line = context.line
        token.column = context.column
        token.raw_value = value
        
        Array.Push(context.tokens, token)
        
        context.position = Add(context.position, 1)
        context.column = Add(context.column, 1)
    }
}

Function.JSON.ParseStringToken {
    Input: (context: JSONParseContext)
    Body: {
        start_pos = context.position
        start_line = context.line
        start_column = context.column
        
        context.position = Add(context.position, 1)  // Skip opening quote
        context.column = Add(context.column, 1)
        
        Pool.JSON.Strings.Allocate(string_buffer, size-4096)
        buffer_pos = 0
        
        WhileLoop LessThan(context.position, context.length) {
            char = StringCharAt(context.input, context.position)
            
            IfCondition StringEquals(char, "\"") ThenBlock {
                // End of string
                context.position = Add(context.position, 1)
                context.column = Add(context.column, 1)
                
                string_value = String.FromBytes(string_buffer, buffer_pos)
                
                // Create token with enhanced information
                Pool.JSON.Parser.Allocate(token)
                token.type = "string"
                token.value = string_value
                token.position = start_pos
                token.line = start_line
                token.column = start_column
                token.raw_value = StringSubstring(context.input, start_pos, Add(context.position, start_pos))
                
                Array.Push(context.tokens, token)
                ReturnValue()
            } ElseBlock {
                IfCondition StringEquals(char, "\\") ThenBlock {
                    // Enhanced escape sequence handling
                    context.position = Add(context.position, 1)
                    context.column = Add(context.column, 1)
                    
                    IfCondition GreaterEqual(context.position, context.length) ThenBlock {
                        context.error_message = "Unterminated string escape sequence"
                        TryBlock: {} CatchError.UnterminatedString {}
                    }
                    
                    escape_char = StringCharAt(context.input, context.position)
                    
                    ChoosePath escape_char {
                        CaseOption "\"": string_buffer[buffer_pos] = 34  // "
                        CaseOption "\\": string_buffer[buffer_pos] = 92  // \
                        CaseOption "/": string_buffer[buffer_pos] = 47   // /
                        CaseOption "b": string_buffer[buffer_pos] = 8    // backspace
                        CaseOption "f": string_buffer[buffer_pos] = 12   // form feed
                        CaseOption "n": string_buffer[buffer_pos] = 10   // newline
                        CaseOption "r": string_buffer[buffer_pos] = 13   // carriage return
                        CaseOption "t": string_buffer[buffer_pos] = 9    // tab
                        CaseOption "u": {
                            // Enhanced Unicode escape sequence
                            unicode_value = JSON.ParseUnicodeEscape(context)
                            utf8_bytes = JSON.UnicodeToUTF8(unicode_value)
                            
                            ForEvery byte_val in utf8_bytes {
                                IfCondition GreaterEqual(buffer_pos, 4096) ThenBlock {
                                    context.error_message = "String too long"
                                    TryBlock: {} CatchError.StringTooLong {}
                                }
                                string_buffer[buffer_pos] = byte_val
                                buffer_pos = Add(buffer_pos, 1)
                            }
                            buffer_pos = Subtract(buffer_pos, 1)  // Will be incremented below
                        }
                        DefaultOption: {
                            context.error_message = StringConcat("Invalid escape sequence: \\", escape_char)
                            TryBlock: {} CatchError.InvalidEscapeSequence {}
                        }
                    }
                    
                    buffer_pos = Add(buffer_pos, 1)
                    context.position = Add(context.position, 1)
                    context.column = Add(context.column, 1)
                } ElseBlock {
                    // Handle newlines in strings
                    IfCondition StringEquals(char, "\n") ThenBlock {
                        context.line = Add(context.line, 1)
                        context.column = 1
                    } ElseBlock {
                        context.column = Add(context.column, 1)
                    }
                    
                    // UTF-8 validation if enabled
                    IfCondition context.parse_options.validate_utf8 ThenBlock {
                        IfCondition Not(JSON.IsValidUTF8Char(char)) ThenBlock {
                            context.error_message = "Invalid UTF-8 character in string"
                            TryBlock: {} CatchError.InvalidUTF8 {}
                        }
                    }
                    
                    IfCondition GreaterEqual(buffer_pos, 4096) ThenBlock {
                        context.error_message = "String too long"
                        TryBlock: {} CatchError.StringTooLong {}
                    }
                    
                    string_buffer[buffer_pos] = CharToCode(char)
                    buffer_pos = Add(buffer_pos, 1)
                    context.position = Add(context.position, 1)
                }
            }
        }
        
        context.error_message = "Unterminated string"
        TryBlock: {} CatchError.UnterminatedString {}
    }
}

Function.JSON.ParseUnicodeEscape {
    Input: (context: JSONParseContext)
    Output: UInt32
    Body: {
        // Parse \uXXXX sequence
        IfCondition GreaterThan(Add(context.position, 4), context.length) ThenBlock {
            context.error_message = "Incomplete Unicode escape sequence"
            TryBlock: {} CatchError.IncompleteUnicodeEscape {}
        }
        
        hex_value = 0
        
        ForEvery i in Range(1, 5) {  // Skip the 'u', read 4 hex digits
            char = StringCharAt(context.input, Add(context.position, i))
            
            IfCondition JSON.IsHexDigit(char) ThenBlock {
                digit_value = JSON.HexCharToValue(char)
                hex_value = Add(Multiply(hex_value, 16), digit_value)
            } ElseBlock {
                context.error_message = StringConcat("Invalid hex digit in Unicode escape: ", char)
                TryBlock: {} CatchError.InvalidHexDigit {}
            }
        }
        
        context.position = Add(context.position, 4)  // Skip the 4 hex digits
        context.column = Add(context.column, 4)
        
        ReturnValue(hex_value)
    }
}

Function.JSON.ParseNumberToken {
    Input: (context: JSONParseContext)
    Body: {
        start_pos = context.position
        start_line = context.line
        start_column = context.column
        
        // Enhanced number parsing with validation
        // Handle optional minus sign
        IfCondition StringEquals(StringCharAt(context.input, context.position), "-") ThenBlock {
            context.position = Add(context.position, 1)
            context.column = Add(context.column, 1)
        }
        
        // Parse integer part with validation
        IfCondition GreaterEqual(context.position, context.length) ThenBlock {
            context.error_message = "Expected digit after minus sign"
            TryBlock: {} CatchError.InvalidNumber {}
        }
        
        first_digit = StringCharAt(context.input, context.position)
        IfCondition Not(JSON.IsDigit(first_digit)) ThenBlock {
            context.error_message = StringConcat("Expected digit, found: ", first_digit)
            TryBlock: {} CatchError.InvalidNumber {}
        }
        
        IfCondition StringEquals(first_digit, "0") ThenBlock {
            context.position = Add(context.position, 1)
            context.column = Add(context.column, 1)
            
            // After leading zero, must be decimal point, exponent, or end
            IfCondition And(
                LessThan(context.position, context.length),
                JSON.IsDigit(StringCharAt(context.input, context.position))
            ) ThenBlock {
                context.error_message = "Leading zeros not allowed"
                TryBlock: {} CatchError.InvalidNumber {}
            }
        } ElseBlock {
            // Parse remaining integer digits
            WhileLoop And(
                LessThan(context.position, context.length),
                JSON.IsDigit(StringCharAt(context.input, context.position))
            ) {
                context.position = Add(context.position, 1)
                context.column = Add(context.column, 1)
            }
        }
        
        // Parse optional fractional part
        IfCondition And(
            LessThan(context.position, context.length),
            StringEquals(StringCharAt(context.input, context.position), ".")
        ) ThenBlock {
            context.position = Add(context.position, 1)
            context.column = Add(context.column, 1)
            
            IfCondition Or(
                GreaterEqual(context.position, context.length),
                Not(JSON.IsDigit(StringCharAt(context.input, context.position)))
            ) ThenBlock {
                context.error_message = "Expected digit after decimal point"
                TryBlock: {} CatchError.InvalidNumber {}
            }
            
            WhileLoop And(
                LessThan(context.position, context.length),
                JSON.IsDigit(StringCharAt(context.input, context.position))
            ) {
                context.position = Add(context.position, 1)
                context.column = Add(context.column, 1)
            }
        }
        
        // Parse optional exponent part
        IfCondition And(
            LessThan(context.position, context.length),
            Or(
                StringEquals(StringCharAt(context.input, context.position), "e"),
                StringEquals(StringCharAt(context.input, context.position), "E")
            )
        ) ThenBlock {
            context.position = Add(context.position, 1)
            context.column = Add(context.column, 1)
            
            // Optional exponent sign
            IfCondition And(
                LessThan(context.position, context.length),
                Or(
                    StringEquals(StringCharAt(context.input, context.position), "+"),
                    StringEquals(StringCharAt(context.input, context.position), "-")
                )
            ) ThenBlock {
                context.position = Add(context.position, 1)
                context.column = Add(context.column, 1)
            }
            
            IfCondition Or(
                GreaterEqual(context.position, context.length),
                Not(JSON.IsDigit(StringCharAt(context.input, context.position)))
            ) ThenBlock {
                context.error_message = "Expected digit in exponent"
                TryBlock: {} CatchError.InvalidNumber {}
            }
            
            WhileLoop And(
                LessThan(context.position, context.length),
                JSON.IsDigit(StringCharAt(context.input, context.position))
            ) {
                context.position = Add(context.position, 1)
                context.column = Add(context.column, 1)
            }
        }
        
        number_string = StringSubstring(context.input, start_pos, Subtract(context.position, start_pos))
        
        // Create enhanced token
        Pool.JSON.Parser.Allocate(token)
        token.type = "number"
        token.value = number_string
        token.position = start_pos
        token.line = start_line
        token.column = start_column
        token.raw_value = number_string
        
        Array.Push(context.tokens, token)
    }
}

Function.JSON.ParseLiteralToken {
    Input: (context: JSONParseContext, literal: Text, token_type: Text)
    Body: {
        start_pos = context.position
        start_line = context.line
        start_column = context.column
        literal_length = StringLength(literal)
        
        IfCondition GreaterThan(Add(context.position, literal_length), context.length) ThenBlock {
            context.error_message = StringConcat("Unexpected end of input while parsing ", literal)
            TryBlock: {} CatchError.UnexpectedEndOfInput {}
        }
        
        found_literal = StringSubstring(context.input, context.position, literal_length)
        
        IfCondition StringEquals(found_literal, literal) ThenBlock {
            context.position = Add(context.position, literal_length)
            context.column = Add(context.column, literal_length)
            
            Pool.JSON.Parser.Allocate(token)
            token.type = token_type
            token.value = literal
            token.position = start_pos
            token.line = start_line
            token.column = start_column
            token.raw_value = literal
            
            Array.Push(context.tokens, token)
        } ElseBlock {
            context.error_message = StringConcat("Expected '", literal, "', found '", found_literal, "'")
            TryBlock: {} CatchError.InvalidLiteral {}
        }
    }
}

// ============================================================================
// Enhanced JSON Value Parsing with Better Error Handling
// ============================================================================

Function.JSON.ParseValue {
    Input: (context: JSONParseContext)
    Output: JSONValue
    Body: {
        IfCondition GreaterEqual(context.current_token, ArrayLength(context.tokens)) ThenBlock {
            context.error_message = "Unexpected end of input"
            TryBlock: {} CatchError.UnexpectedEndOfInput {}
        }
        
        token = context.tokens[context.current_token]
        
        ChoosePath token.type {
            CaseOption "null": {
                context.current_token = Add(context.current_token, 1)
                result = JSON.CreateNull()
                JSON.SetSourcePosition(result, token)
                ReturnValue(result)
            }
            CaseOption "boolean": {
                context.current_token = Add(context.current_token, 1)
                value = StringEquals(token.value, "true")
                result = JSON.CreateBoolean(value)
                JSON.SetSourcePosition(result, token)
                ReturnValue(result)
            }
            CaseOption "number": {
                context.current_token = Add(context.current_token, 1)
                number_value = StringToNumber(token.value)
                result = JSON.CreateNumber(number_value)
                JSON.SetSourcePosition(result, token)
                ReturnValue(result)
            }
            CaseOption "string": {
                context.current_token = Add(context.current_token, 1)
                result = JSON.CreateString(token.value)
                JSON.SetSourcePosition(result, token)
                ReturnValue(result)
            }
            CaseOption "left_bracket": {
                result = JSON.ParseArray(context)
                ReturnValue(result)
            }
            CaseOption "left_brace": {
                result = JSON.ParseObject(context)
                ReturnValue(result)
            }
            DefaultOption: {
                context.error_message = StringConcat("Unexpected token: ", token.type, " ('", token.value, "')")
                TryBlock: {} CatchError.UnexpectedToken {}
            }
        }
    }
}

Function.JSON.ParseArray {
    Input: (context: JSONParseContext)
    Output: JSONValue
    Body: {
        start_token = JSON.ExpectToken(context, "left_bracket")
        
        elements = Array.Create()
        
        // Check for empty array
        IfCondition JSON.PeekToken(context, "right_bracket") ThenBlock {
            end_token = JSON.ExpectToken(context, "right_bracket")
            array = JSON.CreateArray(elements)
            result = JSON.CreateArrayValue(array)
            JSON.SetSourcePosition(result, start_token)
            ReturnValue(result)
        }
        
        // Parse first element
        element = JSON.ParseValue(context)
        Array.Push(elements, element)
        
        // Parse remaining elements
        WhileLoop JSON.PeekToken(context, "comma") {
            JSON.ExpectToken(context, "comma")  // consume comma
            
            // Handle trailing comma if allowed
            IfCondition context.parse_options.allow_trailing_commas ThenBlock {
                IfCondition JSON.PeekToken(context, "right_bracket") ThenBlock {
                    BreakLoop
                }
            }
            
            element = JSON.ParseValue(context)
            Array.Push(elements, element)
        }
        
        end_token = JSON.ExpectToken(context, "right_bracket")
        
        array = JSON.CreateArray(elements)
        result = JSON.CreateArrayValue(array)
        JSON.SetSourcePosition(result, start_token)
        
        ReturnValue(result)
    }
}

Function.JSON.ParseObject {
    Input: (context: JSONParseContext)
    Output: JSONValue
    Body: {
        start_token = JSON.ExpectToken(context, "left_brace")
        
        obj = JSON.CreateObject()
        
        // Check for empty object
        IfCondition JSON.PeekToken(context, "right_brace") ThenBlock {
            end_token = JSON.ExpectToken(context, "right_brace")
            result = JSON.CreateObjectValue(obj)
            JSON.SetSourcePosition(result, start_token)
            ReturnValue(result)
        }
        
        // Parse first property
        JSON.ParseObjectProperty(context, obj)
        
        // Parse remaining properties
        WhileLoop JSON.PeekToken(context, "comma") {
            JSON.ExpectToken(context, "comma")  // consume comma
            
            // Handle trailing comma if allowed
            IfCondition context.parse_options.allow_trailing_commas ThenBlock {
                IfCondition JSON.PeekToken(context, "right_brace") ThenBlock {
                    BreakLoop
                }
            }
            
            JSON.ParseObjectProperty(context, obj)
        }
        
        end_token = JSON.ExpectToken(context, "right_brace")
        
        result = JSON.CreateObjectValue(obj)
        JSON.SetSourcePosition(result, start_token)
        
        ReturnValue(result)
    }
}

Function.JSON.ParseObjectProperty {
    Input: (context: JSONParseContext, obj: JSONObject)
    Body: {
        // Parse key - enhanced to support unquoted keys if allowed
        key_token = IfCondition context.parse_options.allow_unquoted_keys ThenBlock {
            JSON.ParseObjectKey(context)
        } ElseBlock {
            JSON.ExpectToken(context, "string")
        }
        
        key = key_token.value
        
        // Parse colon
        JSON.ExpectToken(context, "colon")
        
        // Parse value
        value = JSON.ParseValue(context)
        
        JSON.Object.Set(obj, key, value)
    }
}

Function.JSON.ExpectToken {
    Input: (context: JSONParseContext, expected_type: Text)
    Output: JSONToken
    Body: {
        IfCondition GreaterEqual(context.current_token, ArrayLength(context.tokens)) ThenBlock {
            context.error_message = StringConcat("Expected ", expected_type, " but reached end of input")
            TryBlock: {} CatchError.UnexpectedEndOfInput {}
        }
        
        token = context.tokens[context.current_token]
        
        IfCondition NotEqual(token.type, expected_type) ThenBlock {
            context.error_message = StringConcat(
                "Expected ", expected_type, 
                " but found ", token.type, " ('", token.value, "')",
                " at line ", NumberToString(token.line),
                ", column ", NumberToString(token.column)
            )
            TryBlock: {} CatchError.UnexpectedToken {}
        }
        
        context.current_token = Add(context.current_token, 1)
        ReturnValue(token)
    }
}

Function.JSON.PeekToken {
    Input: (context: JSONParseContext, expected_type: Text)
    Output: Boolean
    Body: {
        IfCondition GreaterEqual(context.current_token, ArrayLength(context.tokens)) ThenBlock {
            ReturnValue(False)
        }
        
        token = context.tokens[context.current_token]
        ReturnValue(StringEquals(token.type, expected_type))
    }
}

// ============================================================================
// Enhanced JSON Value Creators with Performance Optimizations
// ============================================================================

Function.JSON.CreateNull {
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "null"
        value.value = Null
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = "null"  // Pre-cache null string
        value.hash_cache = 0  // Null has hash 0
        
        ReturnValue(value)
    }
}

Function.JSON.CreateBoolean {
    Input: (bool_value: Boolean)
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "boolean"
        value.value = bool_value
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = IfCondition bool_value ThenBlock { "true" } ElseBlock { "false" }
        value.hash_cache = IfCondition bool_value ThenBlock { 1 } ElseBlock { 0 }
        
        ReturnValue(value)
    }
}

Function.JSON.CreateNumber {
    Input: (number_value: FloatingPoint)
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "number"
        value.value = number_value
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = Null  // Lazy cache
        value.hash_cache = Null     // Lazy cache
        
        ReturnValue(value)
    }
}

Function.JSON.CreateString {
    Input: (string_value: Text)
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "string"
        value.value = string_value
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = Null  // Will be computed on serialization
        value.hash_cache = Null     // Lazy cache
        
        ReturnValue(value)
    }
}

Function.JSON.CreateArray {
    Input: (elements: OptionalType[Array[JSONValue]] = Null)
    Output: JSONArray
    Body: {
        Pool.JSON.Objects.Allocate(array)
        
        IfCondition EqualTo(elements, Null) ThenBlock {
            array.elements = Array.Create()
        } ElseBlock {
            array.elements = elements
        }
        
        array.element_count = ArrayLength(array.elements)
        array.homogeneous_type = Null
        array.size_cache = array.element_count
        array.validation_cache = Null
        
        // Enhanced homogeneous type detection for performance
        IfCondition GreaterThan(array.element_count, 0) ThenBlock {
            first_type = array.elements[0].type
            homogeneous = True
            
            // Check up to first 10 elements for performance
            check_count = IfCondition LessThan(array.element_count, 10) ThenBlock {
                array.element_count
            } ElseBlock {
                10
            }
            
            ForEvery i in Range(1, check_count) {
                IfCondition NotEqual(array.elements[i].type, first_type) ThenBlock {
                    homogeneous = False
                    Break
                }
            }
            
            IfCondition homogeneous ThenBlock {
                array.homogeneous_type = first_type
            }
        }
        
        ReturnValue(array)
    }
}

Function.JSON.CreateObject {
    Output: JSONObject
    Body: {
        Pool.JSON.Objects.Allocate(obj)
        obj.fields = Map.Create()
        obj.field_count = 0
        obj.insertion_order = Array.Create()
        obj.hash_cache = Null
        obj.validation_cache = Null
        
        ReturnValue(obj)
    }
}

Function.JSON.CreateArrayValue {
    Input: (array: JSONArray)
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "array"
        value.value = array
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = Null
        value.hash_cache = Null
        
        ReturnValue(value)
    }
}

Function.JSON.CreateObjectValue {
    Input: (obj: JSONObject)
    Output: JSONValue
    Body: {
        Pool.JSON.Objects.Allocate(value)
        value.type = "object"
        value.value = obj
        value.source_position = 0
        value.line = 0
        value.column = 0
        value.cached_string = Null
        value.hash_cache = Null
        
        ReturnValue(value)
    }
}

// ============================================================================
// Enhanced JSON Object Operations
// ============================================================================

Function.JSON.Object.Set {
    Input: (obj: JSONObject, key: Text, value: JSONValue)
    Body: {
        // Check if key already exists
        IfCondition Not(Map.ContainsKey(obj.fields, key)) ThenBlock {
            obj.field_count = Add(obj.field_count, 1)
            Array.Push(obj.insertion_order, key)
        }
        
        Map.Set(obj.fields, key, value)
        obj.hash_cache = Null        // Invalidate hash cache
        obj.validation_cache = Null  // Invalidate validation cache
    }
}

Function.JSON.Object.Get {
    Input: (obj: JSONObject, key: Text)
    Output: OptionalType[JSONValue]
    Body: {
        ReturnValue(Map.Get(obj.fields, key))
    }
}

Function.JSON.Object.Has {
    Input: (obj: JSONObject, key: Text)
    Output: Boolean
    Body: {
        ReturnValue(Map.ContainsKey(obj.fields, key))
    }
}

Function.JSON.Object.Remove {
    Input: (obj: JSONObject, key: Text)
    Output: Boolean
    Body: {
        IfCondition Map.ContainsKey(obj.fields, key) ThenBlock {
            Map.Remove(obj.fields, key)
            obj.field_count = Subtract(obj.field_count, 1)
            
            // Remove from insertion order
            ForEvery i in Range(0, ArrayLength(obj.insertion_order)) {
                IfCondition StringEquals(obj.insertion_order[i], key) ThenBlock {
                    Array.RemoveAt(obj.insertion_order, i)
                    Break
                }
            }
            
            obj.hash_cache = Null
            obj.validation_cache = Null
            ReturnValue(True)
        }
        
        ReturnValue(False)
    }
}

Function.JSON.Object.Keys {
    Input: (obj: JSONObject)
    Output: Array[Text]
    Body: {
        ReturnValue(obj.insertion_order)
    }
}

Function.JSON.Object.Values {
    Input: (obj: JSONObject)
    Output: Array[JSONValue]
    Body: {
        values = Array.Create()
        
        ForEvery key in obj.insertion_order {
            value = Map.Get(obj.fields, key)
            Array.Push(values, value)
        }
        
        ReturnValue(values)
    }
}

// ============================================================================
// Enhanced JSON Array Operations
// ============================================================================

Function.JSON.Array.Push {
    Input: (array: JSONArray, value: JSONValue)
    Body: {
        Array.Push(array.elements, value)
        array.element_count = Add(array.element_count, 1)
        array.size_cache = array.element_count
        array.validation_cache = Null
        
        // Update homogeneous type check
        IfCondition EqualTo(array.element_count, 1) ThenBlock {
            array.homogeneous_type = value.type
        } ElseBlock {
            IfCondition NotEqual(array.homogeneous_type, Null) ThenBlock {
                IfCondition NotEqual(value.type, array.homogeneous_type) ThenBlock {
                    array.homogeneous_type = Null
                }
            }
        }
    }
}

Function.JSON.Array.Get {
    Input: (array: JSONArray, index: UInt32)
    Output: OptionalType[JSONValue]
    Body: {
        IfCondition LessThan(index, array.element_count) ThenBlock {
            ReturnValue(array.elements[index])
        }
        
        ReturnValue(Null)
    }
}

Function.JSON.Array.Set {
    Input: (array: JSONArray, index: UInt32, value: JSONValue)
    Body: {
        IfCondition LessThan(index, array.element_count) ThenBlock {
            array.elements[index] = value
            array.validation_cache = Null
            
            // Update homogeneous type check
            IfCondition NotEqual(array.homogeneous_type, Null) ThenBlock {
                IfCondition NotEqual(value.type, array.homogeneous_type) ThenBlock {
                    array.homogeneous_type = Null
                }
            }
        } ElseBlock {
            TryBlock: {} CatchError.IndexOutOfBounds {
                PrintMessage(StringConcat("Array index out of bounds: ", NumberToString(index)))
            }
        }
    }
}

Function.JSON.Array.Pop {
    Input: (array: JSONArray)
    Output: OptionalType[JSONValue]
    Body: {
        IfCondition GreaterThan(array.element_count, 0) ThenBlock {
            last_index = Subtract(array.element_count, 1)
            value = array.elements[last_index]
            Array.RemoveAt(array.elements, last_index)
            array.element_count = Subtract(array.element_count, 1)
            array.size_cache = array.element_count
            array.validation_cache = Null
            ReturnValue(value)
        }
        
        ReturnValue(Null)
    }
}

Function.JSON.Array.Length {
    Input: (array: JSONArray)
    Output: UInt32
    Body: {
        ReturnValue(array.element_count)
    }
}

// ============================================================================
// Enhanced JSON Serialization with Caching
// ============================================================================

Function.JSON.Stringify {
    Input: (
        value: JSONValue,
        pretty: Boolean = False,
        indent: Text = "  "
    )
    Output: Text
    Body: {
        options = JSON.CreateSerializeOptions(pretty, indent)
        ReturnValue(JSON.StringifyWithOptions(value, options))
    }
}

Function.JSON.StringifyWithOptions {
    Input: (value: JSONValue, options: JSONSerializeOptions)
    Output: Text
    Body: {
        // Check cache first if caching enabled
        IfCondition options.cache_output ThenBlock {
            cached = JSON.GetCachedSerialization(value, options)
            IfCondition NotEqual(cached, Null) ThenBlock {
                ReturnValue(cached)
            }
        }
        
        Pool.JSON.Output.Allocate(buffer, size-65536)  // 64KB initial buffer
        
        JSON.SerializeValue(value, buffer, options, 0)
        
        result = String.FromBytes(buffer.data, buffer.used)
        
        // Cache result if enabled
        IfCondition options.cache_output ThenBlock {
            JSON.CacheSerialization(value, options, result)
        }
        
        ReturnValue(result)
    }
}

Function.JSON.CreateSerializeOptions {
    Input: (pretty: Boolean, indent: Text)
    Output: JSONSerializeOptions
    Body: {
        options = JSONSerializeOptions.Create()
        options.pretty_print = pretty
        options.indent_size = StringLength(indent)
        options.indent_string = indent
        options.sort_keys = False
        options.escape_unicode = False
        options.compact = Not(pretty)
        options.cache_output = True
        
        ReturnValue(options)
    }
}

// ============================================================================
// MessagePack Serialization (Enhanced)
// ============================================================================

Function.MessagePack.Serialize {
    Input: (value: JSONValue, options: OptionalType[Map[Text, Any]] = Null)
    Output: Array[Byte]
    Body: {
        Pool.Serialization.Binary.Allocate(buffer, size-65536)
        context = MessagePack.CreateContext(buffer, options)
        
        MessagePack.SerializeValue(value, context)
        
        // Return actual used portion of buffer
        result = Array.Slice(buffer.data, 0, context.position)
        ReturnValue(result)
    }
}

Function.MessagePack.Deserialize {
    Input: (data: Array[Byte], options: OptionalType[Map[Text, Any]] = Null)
    Output: JSONValue
    Body: {
        context = MessagePack.CreateReadContext(data, options)
        
        TryBlock: {
            result = MessagePack.DeserializeValue(context)
            ReturnValue(result)
        }
        CatchError.DeserializationError {
            error_msg = StringConcat(
                "MessagePack deserialization failed at position ",
                NumberToString(context.position)
            )
            PrintMessage(error_msg)
            ReturnValue(JSON.CreateNull())
        }
    }
}

// ============================================================================
// Enhanced Schema Validation
// ============================================================================

Function.JSON.Schema.Create {
    Input: (name: Text, version: Text = "1.0")
    Output: SchemaDefinition
    Body: {
        Pool.Serialization.Schema.Allocate(schema)
        schema.name = name
        schema.version = version
        schema.fields = Array.Create()
        schema.required_fields = Array.Create()
        schema.validation_rules = Array.Create()
        schema.cache_enabled = True
        
        ReturnValue(schema)
    }
}

Function.JSON.Schema.AddField {
    Input: (
        schema: SchemaDefinition,
        name: Text,
        type: Text,
        required: Boolean = False,
        default_value: OptionalType[Any] = Null
    )
    Body: {
        Pool.Serialization.Schema.Allocate(field)
        field.name = name
        field.type = type
        field.required = required
        field.default_value = default_value
        field.constraints = Array.Create()
        field.validation_function = Null
        
        Array.Push(schema.fields, field)
        
        IfCondition required ThenBlock {
            Array.Push(schema.required_fields, name)
        }
    }
}

Function.JSON.Schema.Validate {
    Input: (schema: SchemaDefinition, value: JSONValue)
    Output: Boolean
    Body: {
        // Check validation cache
        IfCondition schema.cache_enabled ThenBlock {
            cached_result = JSON.Schema.GetCachedValidation(schema, value)
            IfCondition NotEqual(cached_result, Null) ThenBlock {
                ReturnValue(cached_result)
            }
        }
        
        IfCondition NotEqual(value.type, "object") ThenBlock {
            PrintMessage("Schema validation requires JSON object")
            ReturnValue(False)
        }
        
        obj = value.value
        validation_result = True
        
        // Check required fields
        ForEvery required_field in schema.required_fields {
            IfCondition Not(JSON.Object.Has(obj, required_field)) ThenBlock {
                PrintMessage(StringConcat("Missing required field: ", required_field))
                validation_result = False
            }
        }
        
        // Validate each field
        IfCondition validation_result ThenBlock {
            ForEvery field in schema.fields {
                field_value = JSON.Object.Get(obj, field.name)
                
                IfCondition NotEqual(field_value, Null) ThenBlock {
                    valid = JSON.Schema.ValidateField(field, field_value)
                    IfCondition Not(valid) ThenBlock {
                        validation_result = False
                        Break
                    }
                }
            }
        }
        
        // Run validation rules
        IfCondition validation_result ThenBlock {
            ForEvery rule in schema.validation_rules {
                valid = JSON.Schema.ApplyValidationRule(rule, obj)
                IfCondition Not(valid) ThenBlock {
                    PrintMessage(rule.error_message)
                    validation_result = False
                    Break
                }
            }
        }
        
        // Cache result
        IfCondition schema.cache_enabled ThenBlock {
            JSON.Schema.CacheValidation(schema, value, validation_result)
        }
        
        ReturnValue(validation_result)
    }
}

// ============================================================================
// Configuration File Support (Enhanced)
// ============================================================================

Function.JSON.Config.Load {
    Input: (filename: Text, options: OptionalType[JSONParseOptions] = Null)
    Output: JSONObject
    Body: {
        IfCondition Not(FileExists(filename)) ThenBlock {
            PrintMessage(StringConcat("Config file not found: ", filename))
            ReturnValue(JSON.CreateObject())
        }
        
        content = ReadTextFile(filename)
        
        TryBlock: {
            parsed_value = JSON.Parse(content, options)
            
            IfCondition NotEqual(parsed_value.type, "object") ThenBlock {
                PrintMessage(StringConcat("Config file must contain JSON object: ", filename))
                ReturnValue(JSON.CreateObject())
            }
            
            ReturnValue(parsed_value.value)
        }
        CatchError.ParseError {
            PrintMessage(StringConcat("Failed to parse config file: ", filename))
            ReturnValue(JSON.CreateObject())
        }
    }
}

Function.JSON.Config.Save {
    Input: (filename: Text, config: JSONObject, pretty: Boolean = True)
    Body: {
        json_value = JSON.CreateObjectValue(config)
        json_string = JSON.Stringify(json_value, pretty, "  ")
        
        TryBlock: {
            WriteTextFile(filename, json_string)
        }
        CatchError.FileWriteError {
            PrintMessage(StringConcat("Failed to save config file: ", filename))
        }
    }
}

Function.JSON.Config.Get {
    Input: (config: JSONObject, path: Text, default_value: OptionalType[Any] = Null)
    Output: OptionalType[Any]
    Body: {
        // Support dot notation: "database.host"
        parts = StringSplit(path, ".")
        current_obj = config
        
        ForEvery i in Range(0, ArrayLength(parts)) {
            part = parts[i]
            value = JSON.Object.Get(current_obj, part)
            
            IfCondition EqualTo(value, Null) ThenBlock {
                ReturnValue(default_value)
            }
            
            // If not last part, must be object
            IfCondition LessThan(i, Subtract(ArrayLength(parts), 1)) ThenBlock {
                IfCondition NotEqual(value.type, "object") ThenBlock {
                    ReturnValue(default_value)
                }
                current_obj = value.value
            } ElseBlock {
                // Last part - return the value
                ReturnValue(value.value)
            }
        }
        
        ReturnValue(default_value)
    }
}

// ============================================================================
// Utility Functions (Enhanced)
// ============================================================================

Function.JSON.GetDefaultParseOptions {
    Output: JSONParseOptions
    Body: {
        options = JSONParseOptions.Create()
        options.allow_comments = False
        options.allow_trailing_commas = False
        options.allow_unquoted_keys = False
        options.max_depth = 1000
        options.string_pool_enabled = True
        options.validate_utf8 = True
        options.cache_strings = True
        options.strict_mode = True
        
        ReturnValue(options)
    }
}

Function.JSON.Clone {
    Input: (value: JSONValue)
    Output: JSONValue
    Body: {
        // Deep clone by serializing and parsing
        json_string = JSON.Stringify(value, False)
        ReturnValue(JSON.Parse(json_string))
    }
}

Function.JSON.Equals {
    Input: (value1: JSONValue, value2: JSONValue)
    Output: Boolean
    Body: {
        IfCondition NotEqual(value1.type, value2.type) ThenBlock {
            ReturnValue(False)
        }
        
        ChoosePath value1.type {
            CaseOption "null": ReturnValue(True)
            CaseOption "boolean": ReturnValue(EqualTo(value1.value, value2.value))
            CaseOption "number": ReturnValue(EqualTo(value1.value, value2.value))
            CaseOption "string": ReturnValue(StringEquals(value1.value, value2.value))
            CaseOption "array": ReturnValue(JSON.Array.Equals(value1.value, value2.value))
            CaseOption "object": ReturnValue(JSON.Object.Equals(value1.value, value2.value))
            DefaultOption: ReturnValue(False)
        }
    }
}

Function.JSON.Merge {
    Input: (obj1: JSONObject, obj2: JSONObject)
    Output: JSONObject
    Body: {
        result = JSON.CreateObject()
        
        // Copy fields from obj1
        ForEvery key in obj1.insertion_order {
            value = JSON.Object.Get(obj1, key)
            JSON.Object.Set(result, key, value)
        }
        
        // Add/override fields from obj2
        ForEvery key in obj2.insertion_order {
            value = JSON.Object.Get(obj2, key)
            JSON.Object.Set(result, key, value)
        }
        
        ReturnValue(result)
    }
}

Function.JSON.Pretty {
    Input: (json_string: Text)
    Output: Text
    Body: {
        value = JSON.Parse(json_string)
        ReturnValue(JSON.Stringify(value, True, "  "))
    }
}

Function.JSON.Minify {
    Input: (json_string: Text)
    Output: Text
    Body: {
        value = JSON.Parse(json_string)
        ReturnValue(JSON.Stringify(value, False))
    }
}

// ============================================================================
// Enhanced Utility Functions
// ============================================================================

Function.JSON.IsDigit {
    Input: (char: Text)
    Output: Boolean
    Body: {
        char_code = CharToCode(char)
        ReturnValue(And(GreaterEqual(char_code, 48), LessEqual(char_code, 57)))
    }
}

Function.JSON.IsHexDigit {
    Input: (char: Text)
    Output: Boolean
    Body: {
        char_code = CharToCode(char)
        ReturnValue(Or(
            And(GreaterEqual(char_code, 48), LessEqual(char_code, 57)),  // 0-9
            Or(
                And(GreaterEqual(char_code, 65), LessEqual(char_code, 70)),  // A-F
                And(GreaterEqual(char_code, 97), LessEqual(char_code, 102))  // a-f
            )
        ))
    }
}

Function.JSON.HexCharToValue {
    Input: (char: Text)
    Output: UInt32
    Body: {
        char_code = CharToCode(char)
        
        IfCondition And(GreaterEqual(char_code, 48), LessEqual(char_code, 57)) ThenBlock {
            ReturnValue(Subtract(char_code, 48))  // 0-9
        } ElseBox {
            IfCondition And(GreaterEqual(char_code, 65), LessEqual(char_code, 70)) ThenBlock {
                ReturnValue(Subtract(char_code, 55))  // A-F
            } ElseBlock {
                ReturnValue(Subtract(char_code, 87))  // a-f
            }
        }
    }
}

Function.JSON.IsWhitespace {
    Input: (char: Text)
    Output: Boolean
    Body: {
        ReturnValue(Or(
            Or(StringEquals(char, " "), StringEquals(char, "\t")),
            Or(StringEquals(char, "\n"), StringEquals(char, "\r"))
        ))
    }
}

Function.JSON.IsValidUTF8Char {
    Input: (char: Text)
    Output: Boolean
    Body: {
        // Simplified UTF-8 validation
        char_code = CharToCode(char)
        ReturnValue(LessEqual(char_code, 1114111))  // Valid Unicode range
    }
}

Function.JSON.UnicodeToUTF8 {
    Input: (unicode_value: UInt32)
    Output: Array[UInt8]
    Body: {
        utf8_bytes = Array.Create()
        
        IfCondition LessEqual(unicode_value, 127) ThenBlock {
            // 1-byte sequence
            Array.Push(utf8_bytes, unicode_value)
        } ElseBox {
            IfCondition LessEqual(unicode_value, 2047) ThenBlock {
                // 2-byte sequence
                Array.Push(utf8_bytes, Or(192, ShiftRight(unicode_value, 6)))
                Array.Push(utf8_bytes, Or(128, And(unicode_value, 63)))
            } ElseBlock {
                IfCondition LessEqual(unicode_value, 65535) ThenBlock {
                    // 3-byte sequence
                    Array.Push(utf8_bytes, Or(224, ShiftRight(unicode_value, 12)))
                    Array.Push(utf8_bytes, Or(128, And(ShiftRight(unicode_value, 6), 63)))
                    Array.Push(utf8_bytes, Or(128, And(unicode_value, 63)))
                } ElseBlock {
                    // 4-byte sequence
                    Array.Push(utf8_bytes, Or(240, ShiftRight(unicode_value, 18)))
                    Array.Push(utf8_bytes, Or(128, And(ShiftRight(unicode_value, 12), 63)))
                    Array.Push(utf8_bytes, Or(128, And(ShiftRight(unicode_value, 6), 63)))
                    Array.Push(utf8_bytes, Or(128, And(unicode_value, 63)))
                }
            }
        }
        
        ReturnValue(utf8_bytes)
    }
}

Function.JSON.SetSourcePosition {
    Input: (value: JSONValue, token: JSONToken)
    Body: {
        value.source_position = token.position
        value.line = token.line
        value.column = token.column
    }
}

// ============================================================================
// High-Level Convenience Functions
// ============================================================================

Function.JSON.FromAILANGObject {
    Input: (obj: Any)
    Output: JSONValue
    Body: {
        type_name = GetTypeName(obj)
        
        ChoosePath type_name {
            CaseOption "Null": ReturnValue(JSON.CreateNull())
            CaseOption "Boolean": ReturnValue(JSON.CreateBoolean(obj))
            CaseOption "Integer": ReturnValue(JSON.CreateNumber(FloatingPoint(obj)))
            CaseOption "FloatingPoint": ReturnValue(JSON.CreateNumber(obj))
            CaseOption "Text": ReturnValue(JSON.CreateString(obj))
            CaseOption "Array": {
                json_elements = Array.Create()
                ForEvery element in obj {
                    json_element = JSON.FromAILANGObject(element)
                    Array.Push(json_elements, json_element)
                }
                array = JSON.CreateArray(json_elements)
                ReturnValue(JSON.CreateArrayValue(array))
            }
            CaseOption "Map": {
                json_obj = JSON.CreateObject()
                ForEvery key in Map.Keys(obj) {
                    value = Map.Get(obj, key)
                    json_value = JSON.FromAILANGObject(value)
                    JSON.Object.Set(json_obj, ToString(key), json_value)
                }
                ReturnValue(JSON.CreateObjectValue(json_obj))
            }
            DefaultOption: {
                // For complex objects, try to serialize as string
                ReturnValue(JSON.CreateString(ToString(obj)))
            }
        }
    }
}

Function.JSON.ToAILANGObject {
    Input: (json_value: JSONValue)
    Output: Any
    Body: {
        ChoosePath json_value.type {
            CaseOption "null": ReturnValue(Null)
            CaseOption "boolean": ReturnValue(json_value.value)
            CaseOption "number": ReturnValue(json_value.value)
            CaseOption "string": ReturnValue(json_value.value)
            CaseOption "array": {
                json_array = json_value.value
                ailang_array = Array.Create()
                
                ForEvery element in json_array.elements {
                    ailang_element = JSON.ToAILANGObject(element)
                    Array.Push(ailang_array, ailang_element)
                }
                
                ReturnValue(ailang_array)
            }
            CaseOption "object": {
                json_object = json_value.value
                ailang_map = Map.Create()
                
                ForEvery key in json_object.insertion_order {
                    value = Map.Get(json_object.fields, key)
                    ailang_value = JSON.ToAILANGObject(value)
                    Map.Set(ailang_map, key, ailang_value)
                }
                
                ReturnValue(ailang_map)
            }
            DefaultOption: ReturnValue(Null)
        }
    }
}